{"ast":null,"code":"/**\r\n * A collection of Map-related utility functions.\r\n */\nimport * as $array from \"../../core/utils/Array\";\nimport * as d3geo from \"d3-geo\";\n/**\r\n * Converts a multi-part polygon in X/Y coordinates to a geo-multipolygon in\r\n * geo-points (lat/long).\r\n *\r\n * @param multiPolygon  Source multi-polygon\r\n * @return Geo-multipolygon\r\n */\n\nexport function multiPolygonToGeo(multiPolygon) {\n  return $array.map(multiPolygon, function (polygon) {\n    var surface = polygon[0];\n    var hole = polygon[1]; //let holePoints: Array<IGeoPoint> = [];\n\n    var geoArea = [];\n\n    if (surface) {\n      geoArea.push(multiPointToGeo(surface));\n    }\n\n    if (hole) {\n      geoArea.push(multiPointToGeo(hole));\n    }\n\n    return geoArea;\n  });\n}\n/**\r\n * Converts a multiline in X/Y coordinates to a geo-multiline in geo-points\r\n * (lat/long).\r\n *\r\n * @param multiLine  Source multiline\r\n * @return Geo-multiline\r\n */\n\nexport function multiLineToGeo(multiLine) {\n  return $array.map(multiLine, function (multiLine) {\n    return multiPointToGeo(multiLine);\n  });\n}\n/**\r\n * Converts multiple X/Y points into a lat/long geo-points.\r\n *\r\n * @param points  Source points\r\n * @return Geo-points\r\n */\n\nexport function multiPointToGeo(points) {\n  return $array.map(points, function (point) {\n    return pointToGeo(point);\n  });\n}\n/**\r\n * Converts multiple X/Y points into a lat/long geo-points.\r\n *\r\n * @param points  Source points\r\n * @return Geo-points\r\n */\n\nexport function multiGeoToPoint(geoPoints) {\n  return $array.map(geoPoints, geoToPoint);\n}\n/**\r\n * Converts X/Y point into a lat/long geo-point.\r\n *\r\n * @param point  Source point\r\n * @return Geo-point\r\n */\n\nexport function pointToGeo(point) {\n  return {\n    longitude: point[0],\n    latitude: point[1]\n  };\n}\n/**\r\n * Converts lat/long geo-point into a X/Y point.\r\n *\r\n * @param point  Source geo-point\r\n * @return X/Y point\r\n */\n\nexport function geoToPoint(geoPoint) {\n  return [geoPoint.longitude, geoPoint.latitude];\n}\n/**\r\n * Converts geo line (collection of lat/long coordinates) to screen line (x/y).\r\n *\r\n * @param   multiGeoLine  Source geo line\r\n * @return                Screen line\r\n */\n\nexport function multiGeoLineToMultiLine(multiGeoLine) {\n  return $array.map(multiGeoLine, function (segment) {\n    return $array.map(segment, geoToPoint);\n  });\n}\n/**\r\n * Converts a geo polygon (collection of lat/long coordinates) to screen\r\n * polygon (x/y).\r\n *\r\n * @param   multiGeoPolygon  Source polygon\r\n * @return                   Screen polygon\r\n */\n\nexport function multiGeoPolygonToMultipolygon(multiGeoPolygon) {\n  return $array.map(multiGeoPolygon, function (geoPolygon) {\n    var surface = geoPolygon[0];\n    var hole = geoPolygon[1];\n    var multiPolygon = [];\n\n    if (surface) {\n      multiPolygon.push(multiGeoToPoint(surface));\n    }\n\n    if (hole) {\n      multiPolygon.push(multiGeoToPoint(hole));\n    }\n\n    return multiPolygon;\n  });\n}\n/**\r\n * Returns a set of geographical coordinates for the circle with a center\r\n * at specific lat/long coordinates and radius (in degrees).\r\n *\r\n * @since 4.3.0\r\n * @param   longitude  Center longitude\r\n * @param   latitude   Center latitude\r\n * @param   radius     Radius (degrees)\r\n * @return             Circle coordinates\r\n */\n\nexport function getCircle(longitude, latitude, radius) {\n  return [d3geo.geoCircle().center([longitude, latitude]).radius(radius)().coordinates];\n}\n/**\r\n * Returns a set of screen coordinates that represents a \"background\" area\r\n * between provided extremities.\r\n *\r\n * @since 4.3.0\r\n * @param   north  North latitude\r\n * @param   east   East longitude\r\n * @param   south  South latitude\r\n * @param   west   West longitude\r\n * @return         Polygon\r\n */\n\nexport function getBackground(north, east, south, west) {\n  var multiPolygon = [];\n\n  if (west == -180) {\n    west = -179.9999;\n  }\n\n  if (south == -90) {\n    south = -89.9999;\n  }\n\n  if (north == 90) {\n    north = 89.9999;\n  }\n\n  if (east == 180) {\n    east = 179.9999;\n  }\n\n  var stepLong = Math.min(90, (east - west) / Math.ceil((east - west) / 90));\n  var stepLat = (north - south) / Math.ceil((north - south) / 90);\n\n  for (var ln = west; ln < east; ln = ln + stepLong) {\n    var surface = [];\n    multiPolygon.push([surface]);\n\n    if (ln + stepLong > east) {\n      stepLong = east - ln;\n    }\n\n    for (var ll = ln; ll <= ln + stepLong; ll = ll + 5) {\n      surface.push([ll, north]);\n    }\n\n    for (var lt = north; lt >= south; lt = lt - stepLat) {\n      surface.push([ln + stepLong, lt]);\n    }\n\n    for (var ll = ln + stepLong; ll >= ln; ll = ll - 5) {\n      surface.push([ll, south]);\n    }\n\n    for (var lt = south; lt <= north; lt = lt + stepLat) {\n      surface.push([ln, lt]);\n    }\n  }\n\n  return multiPolygon;\n}","map":null,"metadata":{},"sourceType":"module"}