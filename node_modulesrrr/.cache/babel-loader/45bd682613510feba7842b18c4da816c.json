{"ast":null,"code":"import { abs, epsilon, epsilon2 } from \"./math.js\"; // Approximate Newton-Raphson\n// Solve f(x) = y, start from x\n\nexport function solve(f, y, x) {\n  var steps = 100,\n      delta,\n      f0,\n      f1;\n  x = x === undefined ? 0 : +x;\n  y = +y;\n\n  do {\n    f0 = f(x);\n    f1 = f(x + epsilon);\n    if (f0 === f1) f1 = f0 + epsilon;\n    x -= delta = -1 * epsilon * (f0 - y) / (f0 - f1);\n  } while (steps-- > 0 && abs(delta) > epsilon);\n\n  return steps < 0 ? NaN : x;\n} // Approximate Newton-Raphson in 2D\n// Solve f(a,b) = [x,y]\n\nexport function solve2d(f, MAX_ITERATIONS, eps) {\n  if (MAX_ITERATIONS === undefined) MAX_ITERATIONS = 40;\n  if (eps === undefined) eps = epsilon2;\n  return function (x, y, a, b) {\n    var err2, da, db;\n    a = a === undefined ? 0 : +a;\n    b = b === undefined ? 0 : +b;\n\n    for (var i = 0; i < MAX_ITERATIONS; i++) {\n      var p = f(a, b),\n          // diffs\n      tx = p[0] - x,\n          ty = p[1] - y;\n      if (abs(tx) < eps && abs(ty) < eps) break; // we're there!\n      // backtrack if we overshot\n\n      var h = tx * tx + ty * ty;\n\n      if (h > err2) {\n        a -= da /= 2;\n        b -= db /= 2;\n        continue;\n      }\n\n      err2 = h; // partial derivatives\n\n      var ea = (a > 0 ? -1 : 1) * eps,\n          eb = (b > 0 ? -1 : 1) * eps,\n          pa = f(a + ea, b),\n          pb = f(a, b + eb),\n          dxa = (pa[0] - p[0]) / ea,\n          dya = (pa[1] - p[1]) / ea,\n          dxb = (pb[0] - p[0]) / eb,\n          dyb = (pb[1] - p[1]) / eb,\n          // determinant\n      D = dyb * dxa - dya * dxb,\n          // newton step â€” or half-step for small D\n      l = (abs(D) < 0.5 ? 0.5 : 1) / D;\n      da = (ty * dxb - tx * dyb) * l;\n      db = (tx * dya - ty * dxa) * l;\n      a += da;\n      b += db;\n      if (abs(da) < eps && abs(db) < eps) break; // we're crawling\n    }\n\n    return [a, b];\n  };\n}","map":null,"metadata":{},"sourceType":"module"}