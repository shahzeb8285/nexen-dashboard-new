{"ast":null,"code":"/*\n Highcharts JS v8.1.2 (2020-06-16)\n\n (c) 2009-2018 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (T, O) {\n  \"object\" === typeof module && module.exports ? (O[\"default\"] = O, module.exports = T.document ? O(T) : O) : \"function\" === typeof define && define.amd ? define(\"highcharts/highcharts\", function () {\n    return O(T);\n  }) : (T.Highcharts && T.Highcharts.error(16, !0), T.Highcharts = O(T));\n})(\"undefined\" !== typeof window ? window : this, function (T) {\n  function O(g, c, R, y) {\n    g.hasOwnProperty(c) || (g[c] = y.apply(null, R));\n  }\n\n  var q = {};\n  O(q, \"parts/Globals.js\", [], function () {\n    var g = \"undefined\" !== typeof T ? T : \"undefined\" !== typeof window ? window : {},\n        c = g.document,\n        R = g.navigator && g.navigator.userAgent || \"\",\n        y = c && c.createElementNS && !!c.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGRect,\n        q = /(edge|msie|trident)/i.test(R) && !g.opera,\n        H = -1 !== R.indexOf(\"Firefox\"),\n        D = -1 !== R.indexOf(\"Chrome\"),\n        J = H && 4 > parseInt(R.split(\"Firefox/\")[1], 10);\n    return {\n      product: \"Highcharts\",\n      version: \"8.1.2\",\n      deg2rad: 2 * Math.PI / 360,\n      doc: c,\n      hasBidiBug: J,\n      hasTouch: !!g.TouchEvent,\n      isMS: q,\n      isWebKit: -1 !== R.indexOf(\"AppleWebKit\"),\n      isFirefox: H,\n      isChrome: D,\n      isSafari: !D && -1 !== R.indexOf(\"Safari\"),\n      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(R),\n      SVG_NS: \"http://www.w3.org/2000/svg\",\n      chartCount: 0,\n      seriesTypes: {},\n      symbolSizes: {},\n      svg: y,\n      win: g,\n      marginNames: [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"],\n      noop: function noop() {},\n      charts: [],\n      dateFormats: {}\n    };\n  });\n  O(q, \"parts/Utilities.js\", [q[\"parts/Globals.js\"]], function (g) {\n    function c(b, h, e, z) {\n      var a = h ? \"Highcharts error\" : \"Highcharts warning\";\n      32 === b && (b = a + \": Deprecated member\");\n      var x = I(b),\n          f = x ? a + \" #\" + b + \": www.highcharts.com/errors/\" + b + \"/\" : b.toString();\n\n      a = function a() {\n        if (h) throw Error(f);\n        G.console && -1 === c.messages.indexOf(f) && console.log(f);\n      };\n\n      if (\"undefined\" !== typeof z) {\n        var d = \"\";\n        x && (f += \"?\");\n        W(z, function (b, h) {\n          d += \"\\n - \" + h + \": \" + b;\n          x && (f += encodeURI(h) + \"=\" + encodeURI(b));\n        });\n        f += d;\n      }\n\n      e ? da(e, \"displayError\", {\n        code: b,\n        message: f,\n        params: z\n      }, a) : a();\n      c.messages.push(f);\n    }\n\n    function R() {\n      var b,\n          h = arguments,\n          e = {},\n          z = function z(b, h) {\n        \"object\" !== typeof b && (b = {});\n        W(h, function (e, a) {\n          !y(e, !0) || C(e) || r(e) ? b[a] = h[a] : b[a] = z(b[a] || {}, e);\n        });\n        return b;\n      };\n\n      !0 === h[0] && (e = h[1], h = Array.prototype.slice.call(h, 2));\n      var a = h.length;\n\n      for (b = 0; b < a; b++) e = z(e, h[b]);\n\n      return e;\n    }\n\n    function y(b, h) {\n      return !!b && \"object\" === typeof b && (!h || !n(b));\n    }\n\n    function q(b, h, e) {\n      var a;\n      K(h) ? m(e) ? b.setAttribute(h, e) : b && b.getAttribute && ((a = b.getAttribute(h)) || \"class\" !== h || (a = b.getAttribute(h + \"Name\"))) : W(h, function (h, e) {\n        b.setAttribute(e, h);\n      });\n      return a;\n    }\n\n    function H() {\n      for (var b = arguments, h = b.length, e = 0; e < h; e++) {\n        var a = b[e];\n        if (\"undefined\" !== typeof a && null !== a) return a;\n      }\n    }\n\n    function D(b, h) {\n      if (!b) return h;\n      var e = b.split(\".\").reverse();\n      if (1 === e.length) return h[b];\n\n      for (b = e.pop(); \"undefined\" !== typeof b && \"undefined\" !== typeof h && null !== h;) h = h[b], b = e.pop();\n\n      return h;\n    }\n\n    g.timers = [];\n    var J = g.charts,\n        t = g.doc,\n        G = g.win;\n    (c || (c = {})).messages = [];\n    g.error = c;\n\n    var L = function () {\n      function b(b, h, e) {\n        this.options = h;\n        this.elem = b;\n        this.prop = e;\n      }\n\n      b.prototype.dSetter = function () {\n        var b = this.paths,\n            h = b && b[0];\n        b = b && b[1];\n        var e = [],\n            a = this.now || 0;\n        if (1 !== a && h && b) {\n          if (h.length === b.length && 1 > a) for (var z = 0; z < b.length; z++) {\n            for (var x = h[z], f = b[z], d = [], k = 0; k < f.length; k++) {\n              var N = x[k],\n                  l = f[k];\n              d[k] = \"number\" === typeof N && \"number\" === typeof l && (\"A\" !== f[0] || 4 !== k && 5 !== k) ? N + a * (l - N) : l;\n            }\n\n            e.push(d);\n          } else e = b;\n        } else e = this.toD || [];\n        this.elem.attr(\"d\", e, void 0, !0);\n      };\n\n      b.prototype.update = function () {\n        var b = this.elem,\n            h = this.prop,\n            e = this.now,\n            a = this.options.step;\n        if (this[h + \"Setter\"]) this[h + \"Setter\"]();else b.attr ? b.element && b.attr(h, e, null, !0) : b.style[h] = e + this.unit;\n        a && a.call(b, e, this);\n      };\n\n      b.prototype.run = function (b, h, e) {\n        var a = this,\n            z = a.options,\n            x = function x(b) {\n          return x.stopped ? !1 : a.step(b);\n        },\n            f = G.requestAnimationFrame || function (b) {\n          setTimeout(b, 13);\n        },\n            d = function d() {\n          for (var b = 0; b < g.timers.length; b++) g.timers[b]() || g.timers.splice(b--, 1);\n\n          g.timers.length && f(d);\n        };\n\n        b !== h || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = b, this.end = h, this.unit = e, this.now = this.start, this.pos = 0, x.elem = this.elem, x.prop = this.prop, x() && 1 === g.timers.push(x) && f(d)) : (delete z.curAnim[this.prop], z.complete && 0 === Object.keys(z.curAnim).length && z.complete.call(this.elem));\n      };\n\n      b.prototype.step = function (b) {\n        var h = +new Date(),\n            e = this.options,\n            a = this.elem,\n            z = e.complete,\n            x = e.duration,\n            f = e.curAnim;\n        if (a.attr && !a.element) b = !1;else if (b || h >= x + this.startTime) {\n          this.now = this.end;\n          this.pos = 1;\n          this.update();\n          var d = f[this.prop] = !0;\n          W(f, function (b) {\n            !0 !== b && (d = !1);\n          });\n          d && z && z.call(a);\n          b = !1;\n        } else this.pos = e.easing((h - this.startTime) / x), this.now = this.start + (this.end - this.start) * this.pos, this.update(), b = !0;\n        return b;\n      };\n\n      b.prototype.initPath = function (b, h, e) {\n        function a(b, h) {\n          for (; b.length < u;) {\n            var e = b[0],\n                a = h[u - b.length];\n            a && \"M\" === e[0] && (b[0] = \"C\" === a[0] ? [\"C\", e[1], e[2], e[1], e[2], e[1], e[2]] : [\"L\", e[1], e[2]]);\n            b.unshift(e);\n            d && b.push(b[b.length - 1]);\n          }\n        }\n\n        function z(b, h) {\n          for (; b.length < u;) if (h = b[b.length / k - 1].slice(), \"C\" === h[0] && (h[1] = h[5], h[2] = h[6]), d) {\n            var e = b[b.length / k].slice();\n            b.splice(b.length / 2, 0, h, e);\n          } else b.push(h);\n        }\n\n        var x = b.startX,\n            f = b.endX;\n        h = h && h.slice();\n        e = e.slice();\n        var d = b.isArea,\n            k = d ? 2 : 1;\n        if (!h) return [e, e];\n\n        if (x && f) {\n          for (b = 0; b < x.length; b++) if (x[b] === f[0]) {\n            var N = b;\n            break;\n          } else if (x[0] === f[f.length - x.length + b]) {\n            N = b;\n            var l = !0;\n            break;\n          } else if (x[x.length - 1] === f[f.length - x.length + b]) {\n            N = x.length - b;\n            break;\n          }\n\n          \"undefined\" === typeof N && (h = []);\n        }\n\n        if (h.length && I(N)) {\n          var u = e.length + N * k;\n          l ? (a(h, e), z(e, h)) : (a(e, h), z(h, e));\n        }\n\n        return [h, e];\n      };\n\n      b.prototype.fillSetter = function () {\n        b.prototype.strokeSetter.apply(this, arguments);\n      };\n\n      b.prototype.strokeSetter = function () {\n        this.elem.attr(this.prop, g.color(this.start).tweenTo(g.color(this.end), this.pos), null, !0);\n      };\n\n      return b;\n    }();\n\n    g.Fx = L;\n    g.merge = R;\n\n    var v = g.pInt = function (b, h) {\n      return parseInt(b, h || 10);\n    },\n        K = g.isString = function (b) {\n      return \"string\" === typeof b;\n    },\n        n = g.isArray = function (b) {\n      b = Object.prototype.toString.call(b);\n      return \"[object Array]\" === b || \"[object Array Iterator]\" === b;\n    };\n\n    g.isObject = y;\n\n    var r = g.isDOMElement = function (b) {\n      return y(b) && \"number\" === typeof b.nodeType;\n    },\n        C = g.isClass = function (b) {\n      var h = b && b.constructor;\n      return !(!y(b, !0) || r(b) || !h || !h.name || \"Object\" === h.name);\n    },\n        I = g.isNumber = function (b) {\n      return \"number\" === typeof b && !isNaN(b) && Infinity > b && -Infinity < b;\n    },\n        p = g.erase = function (b, h) {\n      for (var e = b.length; e--;) if (b[e] === h) {\n        b.splice(e, 1);\n        break;\n      }\n    },\n        m = g.defined = function (b) {\n      return \"undefined\" !== typeof b && null !== b;\n    };\n\n    g.attr = q;\n\n    var d = g.splat = function (b) {\n      return n(b) ? b : [b];\n    },\n        l = g.syncTimeout = function (b, h, e) {\n      if (0 < h) return setTimeout(b, h, e);\n      b.call(0, e);\n      return -1;\n    },\n        k = g.clearTimeout = function (b) {\n      m(b) && clearTimeout(b);\n    },\n        f = g.extend = function (b, h) {\n      var e;\n      b || (b = {});\n\n      for (e in h) b[e] = h[e];\n\n      return b;\n    };\n\n    g.pick = H;\n\n    var a = g.css = function (b, h) {\n      g.isMS && !g.svg && h && \"undefined\" !== typeof h.opacity && (h.filter = \"alpha(opacity=\" + 100 * h.opacity + \")\");\n      f(b.style, h);\n    },\n        A = g.createElement = function (b, h, e, z, x) {\n      b = t.createElement(b);\n      h && f(b, h);\n      x && a(b, {\n        padding: \"0\",\n        border: \"none\",\n        margin: \"0\"\n      });\n      e && a(b, e);\n      z && z.appendChild(b);\n      return b;\n    },\n        u = g.extendClass = function (b, h) {\n      var e = function e() {};\n\n      e.prototype = new b();\n      f(e.prototype, h);\n      return e;\n    },\n        E = g.pad = function (b, h, e) {\n      return Array((h || 2) + 1 - String(b).replace(\"-\", \"\").length).join(e || \"0\") + b;\n    },\n        P = g.relativeLength = function (b, h, e) {\n      return /%$/.test(b) ? h * parseFloat(b) / 100 + (e || 0) : parseFloat(b);\n    },\n        w = g.wrap = function (b, h, e) {\n      var a = b[h];\n\n      b[h] = function () {\n        var b = Array.prototype.slice.call(arguments),\n            h = arguments,\n            z = this;\n\n        z.proceed = function () {\n          a.apply(z, arguments.length ? arguments : h);\n        };\n\n        b.unshift(a);\n        b = e.apply(this, b);\n        z.proceed = null;\n        return b;\n      };\n    },\n        M = g.format = function (b, h, e) {\n      var a = \"{\",\n          z = !1,\n          x = [],\n          f = /f$/,\n          d = /\\.([0-9])/,\n          k = g.defaultOptions.lang,\n          N = e && e.time || g.time;\n\n      for (e = e && e.numberFormatter || Y; b;) {\n        var l = b.indexOf(a);\n        if (-1 === l) break;\n        var u = b.slice(0, l);\n\n        if (z) {\n          u = u.split(\":\");\n          a = D(u.shift() || \"\", h);\n          if (u.length && \"number\" === typeof a) if (u = u.join(\":\"), f.test(u)) {\n            var m = parseInt((u.match(d) || [\"\", \"-1\"])[1], 10);\n            null !== a && (a = e(a, m, k.decimalPoint, -1 < u.indexOf(\",\") ? k.thousandsSep : \"\"));\n          } else a = N.dateFormat(u, a);\n          x.push(a);\n        } else x.push(u);\n\n        b = b.slice(l + 1);\n        a = (z = !z) ? \"}\" : \"{\";\n      }\n\n      x.push(b);\n      return x.join(\"\");\n    },\n        F = g.getMagnitude = function (b) {\n      return Math.pow(10, Math.floor(Math.log(b) / Math.LN10));\n    },\n        Q = g.normalizeTickInterval = function (b, h, e, a, z) {\n      var x = b;\n      e = H(e, 1);\n      var f = b / e;\n      h || (h = z ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === a && (1 === e ? h = h.filter(function (b) {\n        return 0 === b % 1;\n      }) : .1 >= e && (h = [1 / e])));\n\n      for (a = 0; a < h.length && !(x = h[a], z && x * e >= b || !z && f <= (h[a] + (h[a + 1] || h[a])) / 2); a++);\n\n      return x = N(x * e, -Math.round(Math.log(.001) / Math.LN10));\n    },\n        e = g.stableSort = function (b, h) {\n      var e = b.length,\n          a,\n          z;\n\n      for (z = 0; z < e; z++) b[z].safeI = z;\n\n      b.sort(function (b, e) {\n        a = h(b, e);\n        return 0 === a ? b.safeI - e.safeI : a;\n      });\n\n      for (z = 0; z < e; z++) delete b[z].safeI;\n    },\n        b = g.arrayMin = function (b) {\n      for (var h = b.length, e = b[0]; h--;) b[h] < e && (e = b[h]);\n\n      return e;\n    },\n        h = g.arrayMax = function (b) {\n      for (var h = b.length, e = b[0]; h--;) b[h] > e && (e = b[h]);\n\n      return e;\n    },\n        z = g.destroyObjectProperties = function (b, h) {\n      W(b, function (e, a) {\n        e && e !== h && e.destroy && e.destroy();\n        delete b[a];\n      });\n    },\n        x = g.discardElement = function (b) {\n      var h = g.garbageBin;\n      h || (h = A(\"div\"));\n      b && h.appendChild(b);\n      h.innerHTML = \"\";\n    },\n        N = g.correctFloat = function (b, h) {\n      return parseFloat(b.toPrecision(h || 14));\n    },\n        aa = g.setAnimation = function (b, h) {\n      h.renderer.globalAnimation = H(b, h.options.chart.animation, !0);\n    },\n        Z = g.animObject = function (b) {\n      return y(b) ? R(b) : {\n        duration: b ? 500 : 0\n      };\n    },\n        V = g.timeUnits = {\n      millisecond: 1,\n      second: 1E3,\n      minute: 6E4,\n      hour: 36E5,\n      day: 864E5,\n      week: 6048E5,\n      month: 24192E5,\n      year: 314496E5\n    },\n        Y = g.numberFormat = function (b, h, e, a) {\n      b = +b || 0;\n      h = +h;\n      var z = g.defaultOptions.lang,\n          x = (b.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n          f = b.toString().split(\"e\");\n      if (-1 === h) h = Math.min(x, 20);else if (!I(h)) h = 2;else if (h && f[1] && 0 > f[1]) {\n        var d = h + +f[1];\n        0 <= d ? (f[0] = (+f[0]).toExponential(d).split(\"e\")[0], h = d) : (f[0] = f[0].split(\".\")[0] || 0, b = 20 > h ? (f[0] * Math.pow(10, f[1])).toFixed(h) : 0, f[1] = 0);\n      }\n      var k = (Math.abs(f[1] ? f[0] : b) + Math.pow(10, -Math.max(h, x) - 1)).toFixed(h);\n      x = String(v(k));\n      d = 3 < x.length ? x.length % 3 : 0;\n      e = H(e, z.decimalPoint);\n      a = H(a, z.thousandsSep);\n      b = (0 > b ? \"-\" : \"\") + (d ? x.substr(0, d) + a : \"\");\n      b += x.substr(d).replace(/(\\d{3})(?=\\d)/g, \"$1\" + a);\n      h && (b += e + k.slice(-h));\n      f[1] && 0 !== +b && (b += \"e\" + f[1]);\n      return b;\n    };\n\n    Math.easeInOutSine = function (b) {\n      return -.5 * (Math.cos(Math.PI * b) - 1);\n    };\n\n    var ba = g.getStyle = function (b, h, e) {\n      if (\"width\" === h) return h = Math.min(b.offsetWidth, b.scrollWidth), e = b.getBoundingClientRect && b.getBoundingClientRect().width, e < h && e >= h - 1 && (h = Math.floor(e)), Math.max(0, h - g.getStyle(b, \"padding-left\") - g.getStyle(b, \"padding-right\"));\n      if (\"height\" === h) return Math.max(0, Math.min(b.offsetHeight, b.scrollHeight) - g.getStyle(b, \"padding-top\") - g.getStyle(b, \"padding-bottom\"));\n      G.getComputedStyle || c(27, !0);\n      if (b = G.getComputedStyle(b, void 0)) b = b.getPropertyValue(h), H(e, \"opacity\" !== h) && (b = v(b));\n      return b;\n    },\n        U = g.inArray = function (b, h, e) {\n      c(32, !1, void 0, {\n        \"Highcharts.inArray\": \"use Array.indexOf\"\n      });\n      return h.indexOf(b, e);\n    },\n        X = g.find = Array.prototype.find ? function (b, h) {\n      return b.find(h);\n    } : function (b, h) {\n      var e,\n          a = b.length;\n\n      for (e = 0; e < a; e++) if (h(b[e], e)) return b[e];\n    };\n\n    g.keys = function (b) {\n      c(32, !1, void 0, {\n        \"Highcharts.keys\": \"use Object.keys\"\n      });\n      return Object.keys(b);\n    };\n\n    var ia = g.offset = function (b) {\n      var h = t.documentElement;\n      b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {\n        top: 0,\n        left: 0\n      };\n      return {\n        top: b.top + (G.pageYOffset || h.scrollTop) - (h.clientTop || 0),\n        left: b.left + (G.pageXOffset || h.scrollLeft) - (h.clientLeft || 0)\n      };\n    },\n        S = g.stop = function (b, h) {\n      for (var e = g.timers.length; e--;) g.timers[e].elem !== b || h && h !== g.timers[e].prop || (g.timers[e].stopped = !0);\n    },\n        W = g.objectEach = function (b, h, e) {\n      for (var a in b) Object.hasOwnProperty.call(b, a) && h.call(e || b[a], b[a], a, b);\n    };\n\n    W({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (b, h) {\n      g[h] = function (e) {\n        var a;\n        c(32, !1, void 0, (a = {}, a[\"Highcharts.\" + h] = \"use Array.\" + b, a));\n        return Array.prototype[b].apply(e, [].slice.call(arguments, 1));\n      };\n    });\n\n    var ja = g.addEvent = function (b, h, e, a) {\n      void 0 === a && (a = {});\n      var z = b.addEventListener || g.addEventListenerPolyfill;\n      var x = \"function\" === typeof b && b.prototype ? b.prototype.protoEvents = b.prototype.protoEvents || {} : b.hcEvents = b.hcEvents || {};\n      g.Point && b instanceof g.Point && b.series && b.series.chart && (b.series.chart.runTrackerClick = !0);\n      z && z.call(b, h, e, !1);\n      x[h] || (x[h] = []);\n      x[h].push({\n        fn: e,\n        order: \"number\" === typeof a.order ? a.order : Infinity\n      });\n      x[h].sort(function (b, h) {\n        return b.order - h.order;\n      });\n      return function () {\n        ea(b, h, e);\n      };\n    },\n        ea = g.removeEvent = function (b, h, e) {\n      function a(h, e) {\n        var a = b.removeEventListener || g.removeEventListenerPolyfill;\n        a && a.call(b, h, e, !1);\n      }\n\n      function z(e) {\n        var z;\n\n        if (b.nodeName) {\n          if (h) {\n            var x = {};\n            x[h] = !0;\n          } else x = e;\n\n          W(x, function (b, h) {\n            if (e[h]) for (z = e[h].length; z--;) a(h, e[h][z].fn);\n          });\n        }\n      }\n\n      var x;\n      [\"protoEvents\", \"hcEvents\"].forEach(function (f, d) {\n        var k = (d = d ? b : b.prototype) && d[f];\n        k && (h ? (x = k[h] || [], e ? (k[h] = x.filter(function (b) {\n          return e !== b.fn;\n        }), a(h, e)) : (z(k), k[h] = [])) : (z(k), d[f] = {}));\n      });\n    },\n        da = g.fireEvent = function (b, h, e, a) {\n      var z;\n      e = e || {};\n\n      if (t.createEvent && (b.dispatchEvent || b.fireEvent)) {\n        var x = t.createEvent(\"Events\");\n        x.initEvent(h, !0, !0);\n        f(x, e);\n        b.dispatchEvent ? b.dispatchEvent(x) : b.fireEvent(h, x);\n      } else e.target || f(e, {\n        preventDefault: function preventDefault() {\n          e.defaultPrevented = !0;\n        },\n        target: b,\n        type: h\n      }), function (h, a) {\n        void 0 === h && (h = []);\n        void 0 === a && (a = []);\n        var x = 0,\n            f = 0,\n            d = h.length + a.length;\n\n        for (z = 0; z < d; z++) !1 === (h[x] ? a[f] ? h[x].order <= a[f].order ? h[x++] : a[f++] : h[x++] : a[f++]).fn.call(b, e) && e.preventDefault();\n      }(b.protoEvents && b.protoEvents[h], b.hcEvents && b.hcEvents[h]);\n\n      a && !e.defaultPrevented && a.call(b, e);\n    },\n        ka = g.animate = function (b, h, e) {\n      var a,\n          z = \"\",\n          x,\n          f;\n\n      if (!y(e)) {\n        var d = arguments;\n        e = {\n          duration: d[2],\n          easing: d[3],\n          complete: d[4]\n        };\n      }\n\n      I(e.duration) || (e.duration = 400);\n      e.easing = \"function\" === typeof e.easing ? e.easing : Math[e.easing] || Math.easeInOutSine;\n      e.curAnim = R(h);\n      W(h, function (d, k) {\n        S(b, k);\n        f = new L(b, e, k);\n        x = null;\n        \"d\" === k && n(h.d) ? (f.paths = f.initPath(b, b.pathArray, h.d), f.toD = h.d, a = 0, x = 1) : b.attr ? a = b.attr(k) : (a = parseFloat(ba(b, k)) || 0, \"opacity\" !== k && (z = \"px\"));\n        x || (x = d);\n        x && x.match && x.match(\"px\") && (x = x.replace(/px/g, \"\"));\n        f.run(a, x, z);\n      });\n    },\n        la = g.seriesType = function (b, h, e, a, x) {\n      var z = fa(),\n          f = g.seriesTypes;\n      z.plotOptions[b] = R(z.plotOptions[h], e);\n      f[b] = u(f[h] || function () {}, a);\n      f[b].prototype.type = b;\n      x && (f[b].prototype.pointClass = u(g.Point, x));\n      return f[b];\n    },\n        ca,\n        ha = g.uniqueKey = function () {\n      var b = Math.random().toString(36).substring(2, 9) + \"-\",\n          h = 0;\n      return function () {\n        return \"highcharts-\" + (ca ? \"\" : b) + h++;\n      };\n    }(),\n        ma = g.useSerialIds = function (b) {\n      return ca = H(b, ca);\n    },\n        O = g.isFunction = function (b) {\n      return \"function\" === typeof b;\n    },\n        fa = g.getOptions = function () {\n      return g.defaultOptions;\n    },\n        na = g.setOptions = function (b) {\n      g.defaultOptions = R(!0, g.defaultOptions, b);\n      (b.time || b.global) && g.time.update(R(g.defaultOptions.global, g.defaultOptions.time, b.global, b.time));\n      return g.defaultOptions;\n    };\n\n    G.jQuery && (G.jQuery.fn.highcharts = function () {\n      var b = [].slice.call(arguments);\n      if (this[0]) return b[0] ? (new g[K(b[0]) ? b.shift() : \"Chart\"](this[0], b[0], b[1]), this) : J[q(this[0], \"data-highcharts-chart\")];\n    });\n    return {\n      Fx: g.Fx,\n      addEvent: ja,\n      animate: ka,\n      animObject: Z,\n      arrayMax: h,\n      arrayMin: b,\n      attr: q,\n      clamp: function clamp(b, h, e) {\n        return b > h ? b < e ? b : e : h;\n      },\n      clearTimeout: k,\n      correctFloat: N,\n      createElement: A,\n      css: a,\n      defined: m,\n      destroyObjectProperties: z,\n      discardElement: x,\n      erase: p,\n      error: c,\n      extend: f,\n      extendClass: u,\n      find: X,\n      fireEvent: da,\n      format: M,\n      getMagnitude: F,\n      getNestedProperty: D,\n      getOptions: fa,\n      getStyle: ba,\n      inArray: U,\n      isArray: n,\n      isClass: C,\n      isDOMElement: r,\n      isFunction: O,\n      isNumber: I,\n      isObject: y,\n      isString: K,\n      merge: R,\n      normalizeTickInterval: Q,\n      numberFormat: Y,\n      objectEach: W,\n      offset: ia,\n      pad: E,\n      pick: H,\n      pInt: v,\n      relativeLength: P,\n      removeEvent: ea,\n      seriesType: la,\n      setAnimation: aa,\n      setOptions: na,\n      splat: d,\n      stableSort: e,\n      stop: S,\n      syncTimeout: l,\n      timeUnits: V,\n      uniqueKey: ha,\n      useSerialIds: ma,\n      wrap: w\n    };\n  });\n  O(q, \"parts/Color.js\", [q[\"parts/Globals.js\"], q[\"parts/Utilities.js\"]], function (g, c) {\n    var R = c.isNumber,\n        y = c.merge,\n        q = c.pInt;\n\n    c = function () {\n      function c(g) {\n        this.parsers = [{\n          regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n          parse: function parse(c) {\n            return [q(c[1]), q(c[2]), q(c[3]), parseFloat(c[4], 10)];\n          }\n        }, {\n          regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n          parse: function parse(c) {\n            return [q(c[1]), q(c[2]), q(c[3]), 1];\n          }\n        }];\n        this.rgba = [];\n        if (!(this instanceof c)) return new c(g);\n        this.init(g);\n      }\n\n      c.parse = function (g) {\n        return new c(g);\n      };\n\n      c.prototype.init = function (g) {\n        var J, t;\n        if ((this.input = g = c.names[g && g.toLowerCase ? g.toLowerCase() : \"\"] || g) && g.stops) this.stops = g.stops.map(function (v) {\n          return new c(v[1]);\n        });else {\n          if (g && g.charAt && \"#\" === g.charAt()) {\n            var G = g.length;\n            g = parseInt(g.substr(1), 16);\n            7 === G ? J = [(g & 16711680) >> 16, (g & 65280) >> 8, g & 255, 1] : 4 === G && (J = [(g & 3840) >> 4 | (g & 3840) >> 8, (g & 240) >> 4 | g & 240, (g & 15) << 4 | g & 15, 1]);\n          }\n\n          if (!J) for (t = this.parsers.length; t-- && !J;) {\n            var L = this.parsers[t];\n            (G = L.regex.exec(g)) && (J = L.parse(G));\n          }\n        }\n        this.rgba = J || [];\n      };\n\n      c.prototype.get = function (c) {\n        var g = this.input,\n            t = this.rgba;\n\n        if (\"undefined\" !== typeof this.stops) {\n          var G = y(g);\n          G.stops = [].concat(G.stops);\n          this.stops.forEach(function (g, v) {\n            G.stops[v] = [G.stops[v][0], g.get(c)];\n          });\n        } else G = t && R(t[0]) ? \"rgb\" === c || !c && 1 === t[3] ? \"rgb(\" + t[0] + \",\" + t[1] + \",\" + t[2] + \")\" : \"a\" === c ? t[3] : \"rgba(\" + t.join(\",\") + \")\" : g;\n\n        return G;\n      };\n\n      c.prototype.brighten = function (c) {\n        var g,\n            t = this.rgba;\n        if (this.stops) this.stops.forEach(function (g) {\n          g.brighten(c);\n        });else if (R(c) && 0 !== c) for (g = 0; 3 > g; g++) t[g] += q(255 * c), 0 > t[g] && (t[g] = 0), 255 < t[g] && (t[g] = 255);\n        return this;\n      };\n\n      c.prototype.setOpacity = function (c) {\n        this.rgba[3] = c;\n        return this;\n      };\n\n      c.prototype.tweenTo = function (c, g) {\n        var t = this.rgba,\n            G = c.rgba;\n        G.length && t && t.length ? (c = 1 !== G[3] || 1 !== t[3], g = (c ? \"rgba(\" : \"rgb(\") + Math.round(G[0] + (t[0] - G[0]) * (1 - g)) + \",\" + Math.round(G[1] + (t[1] - G[1]) * (1 - g)) + \",\" + Math.round(G[2] + (t[2] - G[2]) * (1 - g)) + (c ? \",\" + (G[3] + (t[3] - G[3]) * (1 - g)) : \"\") + \")\") : g = c.input || \"none\";\n        return g;\n      };\n\n      c.names = {\n        white: \"#ffffff\",\n        black: \"#000000\"\n      };\n      return c;\n    }();\n\n    g.Color = c;\n    g.color = c.parse;\n    return g.Color;\n  });\n  O(q, \"parts/SVGElement.js\", [q[\"parts/Color.js\"], q[\"parts/Globals.js\"], q[\"parts/Utilities.js\"]], function (g, c, q) {\n    var y = c.deg2rad,\n        B = c.doc,\n        H = c.hasTouch,\n        D = c.isFirefox,\n        J = c.noop,\n        t = c.svg,\n        G = c.SVG_NS,\n        L = c.win,\n        v = q.animate,\n        K = q.animObject,\n        n = q.attr,\n        r = q.createElement,\n        C = q.css,\n        I = q.defined,\n        p = q.erase,\n        m = q.extend,\n        d = q.fireEvent,\n        l = q.isArray,\n        k = q.isFunction,\n        f = q.isNumber,\n        a = q.isString,\n        A = q.merge,\n        u = q.objectEach,\n        E = q.pick,\n        P = q.pInt,\n        w = q.stop,\n        M = q.uniqueKey;\n    \"\";\n\n    q = function () {\n      function F() {\n        this.height = this.element = void 0;\n        this.opacity = 1;\n        this.renderer = void 0;\n        this.SVG_NS = G;\n        this.symbolCustomAttribs = \"x y width height r start end innerR anchorX anchorY rounded\".split(\" \");\n        this.width = void 0;\n      }\n\n      F.prototype._defaultGetter = function (a) {\n        a = E(this[a + \"Value\"], this[a], this.element ? this.element.getAttribute(a) : null, 0);\n        /^[\\-0-9\\.]+$/.test(a) && (a = parseFloat(a));\n        return a;\n      };\n\n      F.prototype._defaultSetter = function (a, e, b) {\n        b.setAttribute(e, a);\n      };\n\n      F.prototype.add = function (a) {\n        var e = this.renderer,\n            b = this.element;\n        a && (this.parentGroup = a);\n        this.parentInverted = a && a.inverted;\n        \"undefined\" !== typeof this.textStr && \"text\" === this.element.nodeName && e.buildText(this);\n        this.added = !0;\n        if (!a || a.handleZ || this.zIndex) var h = this.zIndexSetter();\n        h || (a ? a.element : e.box).appendChild(b);\n        if (this.onAdd) this.onAdd();\n        return this;\n      };\n\n      F.prototype.addClass = function (a, e) {\n        var b = e ? \"\" : this.attr(\"class\") || \"\";\n        a = (a || \"\").split(/ /g).reduce(function (h, e) {\n          -1 === b.indexOf(e) && h.push(e);\n          return h;\n        }, b ? [b] : []).join(\" \");\n        a !== b && this.attr(\"class\", a);\n        return this;\n      };\n\n      F.prototype.afterSetters = function () {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      };\n\n      F.prototype.align = function (f, e, b) {\n        var h,\n            z = {};\n        var x = this.renderer;\n        var d = x.alignedObjects;\n        var k, l;\n\n        if (f) {\n          if (this.alignOptions = f, this.alignByTranslate = e, !b || a(b)) this.alignTo = h = b || \"renderer\", p(d, this), d.push(this), b = void 0;\n        } else f = this.alignOptions, e = this.alignByTranslate, h = this.alignTo;\n\n        b = E(b, x[h], x);\n        h = f.align;\n        x = f.verticalAlign;\n        d = (b.x || 0) + (f.x || 0);\n        var u = (b.y || 0) + (f.y || 0);\n        \"right\" === h ? k = 1 : \"center\" === h && (k = 2);\n        k && (d += (b.width - (f.width || 0)) / k);\n        z[e ? \"translateX\" : \"x\"] = Math.round(d);\n        \"bottom\" === x ? l = 1 : \"middle\" === x && (l = 2);\n        l && (u += (b.height - (f.height || 0)) / l);\n        z[e ? \"translateY\" : \"y\"] = Math.round(u);\n        this[this.placed ? \"animate\" : \"attr\"](z);\n        this.placed = !0;\n        this.alignAttr = z;\n        return this;\n      };\n\n      F.prototype.alignSetter = function (a) {\n        var e = {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        };\n        e[a] && (this.alignValue = a, this.element.setAttribute(\"text-anchor\", e[a]));\n      };\n\n      F.prototype.animate = function (a, e, b) {\n        var h = K(E(e, this.renderer.globalAnimation, !0));\n        E(B.hidden, B.msHidden, B.webkitHidden, !1) && (h.duration = 0);\n        0 !== h.duration ? (b && (h.complete = b), v(this, a, h)) : (this.attr(a, void 0, b), u(a, function (b, e) {\n          h.step && h.step.call(this, b, {\n            prop: e,\n            pos: 1\n          });\n        }, this));\n        return this;\n      };\n\n      F.prototype.applyTextOutline = function (a) {\n        var e = this.element,\n            b;\n        -1 !== a.indexOf(\"contrast\") && (a = a.replace(/contrast/g, this.renderer.getContrast(e.style.fill)));\n        a = a.split(\" \");\n        var h = a[a.length - 1];\n\n        if ((b = a[0]) && \"none\" !== b && c.svg) {\n          this.fakeTS = !0;\n          a = [].slice.call(e.getElementsByTagName(\"tspan\"));\n          this.ySetter = this.xSetter;\n          b = b.replace(/(^[\\d\\.]+)(.*?)$/g, function (b, h, e) {\n            return 2 * h + e;\n          });\n          this.removeTextOutline(a);\n          var z = e.textContent ? /^[\\u0591-\\u065F\\u066A-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC]/.test(e.textContent) : !1;\n          var x = e.firstChild;\n          a.forEach(function (a, f) {\n            0 === f && (a.setAttribute(\"x\", e.getAttribute(\"x\")), f = e.getAttribute(\"y\"), a.setAttribute(\"y\", f || 0), null === f && e.setAttribute(\"y\", 0));\n            f = a.cloneNode(!0);\n            n(z && !D ? a : f, {\n              \"class\": \"highcharts-text-outline\",\n              fill: h,\n              stroke: h,\n              \"stroke-width\": b,\n              \"stroke-linejoin\": \"round\"\n            });\n            e.insertBefore(f, x);\n          });\n          z && D && a[0] && (a = a[0].cloneNode(!0), a.textContent = \" \", e.insertBefore(a, x));\n        }\n      };\n\n      F.prototype.attr = function (a, e, b, h) {\n        var z = this.element,\n            x,\n            f = this,\n            d,\n            k,\n            l = this.symbolCustomAttribs;\n\n        if (\"string\" === typeof a && \"undefined\" !== typeof e) {\n          var m = a;\n          a = {};\n          a[m] = e;\n        }\n\n        \"string\" === typeof a ? f = (this[a + \"Getter\"] || this._defaultGetter).call(this, a, z) : (u(a, function (b, e) {\n          d = !1;\n          h || w(this, e);\n          this.symbolName && -1 !== l.indexOf(e) && (x || (this.symbolAttr(a), x = !0), d = !0);\n          !this.rotation || \"x\" !== e && \"y\" !== e || (this.doTransform = !0);\n          d || (k = this[e + \"Setter\"] || this._defaultSetter, k.call(this, b, e, z), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(e) && this.updateShadows(e, b, k));\n        }, this), this.afterSetters());\n        b && b.call(this);\n        return f;\n      };\n\n      F.prototype.clip = function (a) {\n        return this.attr(\"clip-path\", a ? \"url(\" + this.renderer.url + \"#\" + a.id + \")\" : \"none\");\n      };\n\n      F.prototype.crisp = function (a, e) {\n        e = e || a.strokeWidth || 0;\n        var b = Math.round(e) % 2 / 2;\n        a.x = Math.floor(a.x || this.x || 0) + b;\n        a.y = Math.floor(a.y || this.y || 0) + b;\n        a.width = Math.floor((a.width || this.width || 0) - 2 * b);\n        a.height = Math.floor((a.height || this.height || 0) - 2 * b);\n        I(a.strokeWidth) && (a.strokeWidth = e);\n        return a;\n      };\n\n      F.prototype.complexColor = function (a, e, b) {\n        var h = this.renderer,\n            z,\n            x,\n            f,\n            k,\n            m,\n            p,\n            w,\n            C,\n            Q,\n            r,\n            E = [],\n            S;\n        d(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          a.radialGradient ? x = \"radialGradient\" : a.linearGradient && (x = \"linearGradient\");\n\n          if (x) {\n            f = a[x];\n            m = h.gradients;\n            p = a.stops;\n            Q = b.radialReference;\n            l(f) && (a[x] = f = {\n              x1: f[0],\n              y1: f[1],\n              x2: f[2],\n              y2: f[3],\n              gradientUnits: \"userSpaceOnUse\"\n            });\n            \"radialGradient\" === x && Q && !I(f.gradientUnits) && (k = f, f = A(f, h.getRadialAttr(Q, k), {\n              gradientUnits: \"userSpaceOnUse\"\n            }));\n            u(f, function (b, h) {\n              \"id\" !== h && E.push(h, b);\n            });\n            u(p, function (b) {\n              E.push(b);\n            });\n            E = E.join(\",\");\n            if (m[E]) r = m[E].attr(\"id\");else {\n              f.id = r = M();\n              var d = m[E] = h.createElement(x).attr(f).add(h.defs);\n              d.radAttr = k;\n              d.stops = [];\n              p.forEach(function (b) {\n                0 === b[1].indexOf(\"rgba\") ? (z = g.parse(b[1]), w = z.get(\"rgb\"), C = z.get(\"a\")) : (w = b[1], C = 1);\n                b = h.createElement(\"stop\").attr({\n                  offset: b[0],\n                  \"stop-color\": w,\n                  \"stop-opacity\": C\n                }).add(d);\n                d.stops.push(b);\n              });\n            }\n            S = \"url(\" + h.url + \"#\" + r + \")\";\n            b.setAttribute(e, S);\n            b.gradient = E;\n\n            a.toString = function () {\n              return S;\n            };\n          }\n        });\n      };\n\n      F.prototype.css = function (a) {\n        var e = this.styles,\n            b = {},\n            h = this.element,\n            z = \"\",\n            x = !e,\n            f = [\"textOutline\", \"textOverflow\", \"width\"];\n        a && a.color && (a.fill = a.color);\n        e && u(a, function (h, a) {\n          e && e[a] !== h && (b[a] = h, x = !0);\n        });\n\n        if (x) {\n          e && (a = m(e, b));\n          if (a) if (null === a.width || \"auto\" === a.width) delete this.textWidth;else if (\"text\" === h.nodeName.toLowerCase() && a.width) var d = this.textWidth = P(a.width);\n          this.styles = a;\n          d && !t && this.renderer.forExport && delete a.width;\n\n          if (h.namespaceURI === this.SVG_NS) {\n            var k = function k(b, h) {\n              return \"-\" + h.toLowerCase();\n            };\n\n            u(a, function (b, h) {\n              -1 === f.indexOf(h) && (z += h.replace(/([A-Z])/g, k) + \":\" + b + \";\");\n            });\n            z && n(h, \"style\", z);\n          } else C(h, a);\n\n          this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), a && a.textOutline && this.applyTextOutline(a.textOutline));\n        }\n\n        return this;\n      };\n\n      F.prototype.dashstyleSetter = function (a) {\n        var e = this[\"stroke-width\"];\n        \"inherit\" === e && (e = 1);\n\n        if (a = a && a.toLowerCase()) {\n          var b = a.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n\n          for (a = b.length; a--;) b[a] = \"\" + P(b[a]) * E(e, NaN);\n\n          a = b.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", a);\n        }\n      };\n\n      F.prototype.destroy = function () {\n        var a = this,\n            e = a.element || {},\n            b = a.renderer,\n            h = b.isSVG && \"SPAN\" === e.nodeName && a.parentGroup || void 0,\n            z = e.ownerSVGElement;\n        e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null;\n        w(a);\n\n        if (a.clipPath && z) {\n          var x = a.clipPath;\n          [].forEach.call(z.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (b) {\n            -1 < b.getAttribute(\"clip-path\").indexOf(x.element.id) && b.removeAttribute(\"clip-path\");\n          });\n          a.clipPath = x.destroy();\n        }\n\n        if (a.stops) {\n          for (z = 0; z < a.stops.length; z++) a.stops[z].destroy();\n\n          a.stops.length = 0;\n          a.stops = void 0;\n        }\n\n        a.safeRemoveChild(e);\n\n        for (b.styledMode || a.destroyShadows(); h && h.div && 0 === h.div.childNodes.length;) e = h.parentGroup, a.safeRemoveChild(h.div), delete h.div, h = e;\n\n        a.alignTo && p(b.alignedObjects, a);\n        u(a, function (b, h) {\n          a[h] && a[h].parentGroup === a && a[h].destroy && a[h].destroy();\n          delete a[h];\n        });\n      };\n\n      F.prototype.destroyShadows = function () {\n        (this.shadows || []).forEach(function (a) {\n          this.safeRemoveChild(a);\n        }, this);\n        this.shadows = void 0;\n      };\n\n      F.prototype.destroyTextPath = function (a, e) {\n        var b = a.getElementsByTagName(\"text\")[0];\n\n        if (b) {\n          if (b.removeAttribute(\"dx\"), b.removeAttribute(\"dy\"), e.element.setAttribute(\"id\", \"\"), this.textPathWrapper && b.getElementsByTagName(\"textPath\").length) {\n            for (a = this.textPathWrapper.element.childNodes; a.length;) b.appendChild(a[0]);\n\n            b.removeChild(this.textPathWrapper.element);\n          }\n        } else if (a.getAttribute(\"dx\") || a.getAttribute(\"dy\")) a.removeAttribute(\"dx\"), a.removeAttribute(\"dy\");\n\n        this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());\n      };\n\n      F.prototype.dSetter = function (a, e, b) {\n        l(a) && (\"string\" === typeof a[0] && (a = this.renderer.pathToSegments(a)), this.pathArray = a, a = a.reduce(function (b, a, e) {\n          return a && a.join ? (e ? b + \" \" : \"\") + a.join(\" \") : (a || \"\").toString();\n        }, \"\"));\n        /(NaN| {2}|^$)/.test(a) && (a = \"M 0 0\");\n        this[e] !== a && (b.setAttribute(e, a), this[e] = a);\n      };\n\n      F.prototype.fadeOut = function (a) {\n        var e = this;\n        e.animate({\n          opacity: 0\n        }, {\n          duration: E(a, 150),\n          complete: function complete() {\n            e.attr({\n              y: -9999\n            }).hide();\n          }\n        });\n      };\n\n      F.prototype.fillSetter = function (a, e, b) {\n        \"string\" === typeof a ? b.setAttribute(e, a) : a && this.complexColor(a, e, b);\n      };\n\n      F.prototype.getBBox = function (a, e) {\n        var b,\n            h = this.renderer,\n            z = this.element,\n            x = this.styles,\n            f = this.textStr,\n            d = h.cache,\n            l = h.cacheKeys,\n            u = z.namespaceURI === this.SVG_NS;\n        e = E(e, this.rotation, 0);\n        var A = h.styledMode ? z && F.prototype.getStyle.call(z, \"font-size\") : x && x.fontSize;\n\n        if (I(f)) {\n          var p = f.toString();\n          -1 === p.indexOf(\"<\") && (p = p.replace(/[0-9]/g, \"0\"));\n          p += [\"\", e, A, this.textWidth, x && x.textOverflow, x && x.fontWeight].join();\n        }\n\n        p && !a && (b = d[p]);\n\n        if (!b) {\n          if (u || h.forExport) {\n            try {\n              var w = this.fakeTS && function (b) {\n                [].forEach.call(z.querySelectorAll(\".highcharts-text-outline\"), function (h) {\n                  h.style.display = b;\n                });\n              };\n\n              k(w) && w(\"none\");\n              b = z.getBBox ? m({}, z.getBBox()) : {\n                width: z.offsetWidth,\n                height: z.offsetHeight\n              };\n              k(w) && w(\"\");\n            } catch (X) {\n              \"\";\n            }\n\n            if (!b || 0 > b.width) b = {\n              width: 0,\n              height: 0\n            };\n          } else b = this.htmlGetBBox();\n\n          h.isSVG && (a = b.width, h = b.height, u && (b.height = h = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[x && x.fontSize + \",\" + Math.round(h)] || h), e && (x = e * y, b.width = Math.abs(h * Math.sin(x)) + Math.abs(a * Math.cos(x)), b.height = Math.abs(h * Math.cos(x)) + Math.abs(a * Math.sin(x))));\n\n          if (p && 0 < b.height) {\n            for (; 250 < l.length;) delete d[l.shift()];\n\n            d[p] || l.push(p);\n            d[p] = b;\n          }\n        }\n\n        return b;\n      };\n\n      F.prototype.getStyle = function (a) {\n        return L.getComputedStyle(this.element || this, \"\").getPropertyValue(a);\n      };\n\n      F.prototype.hasClass = function (a) {\n        return -1 !== (\"\" + this.attr(\"class\")).split(\" \").indexOf(a);\n      };\n\n      F.prototype.hide = function (a) {\n        a ? this.attr({\n          y: -9999\n        }) : this.attr({\n          visibility: \"hidden\"\n        });\n        return this;\n      };\n\n      F.prototype.htmlGetBBox = function () {\n        return {\n          height: 0,\n          width: 0,\n          x: 0,\n          y: 0\n        };\n      };\n\n      F.prototype.init = function (a, e) {\n        this.element = \"span\" === e ? r(e) : B.createElementNS(this.SVG_NS, e);\n        this.renderer = a;\n        d(this, \"afterInit\");\n      };\n\n      F.prototype.invert = function (a) {\n        this.inverted = a;\n        this.updateTransform();\n        return this;\n      };\n\n      F.prototype.on = function (a, e) {\n        var b,\n            h,\n            z = this.element,\n            x;\n        H && \"click\" === a ? (z.ontouchstart = function (a) {\n          b = a.touches[0].clientX;\n          h = a.touches[0].clientY;\n        }, z.ontouchend = function (a) {\n          b && 4 <= Math.sqrt(Math.pow(b - a.changedTouches[0].clientX, 2) + Math.pow(h - a.changedTouches[0].clientY, 2)) || e.call(z, a);\n          x = !0;\n          a.preventDefault();\n        }, z.onclick = function (b) {\n          x || e.call(z, b);\n        }) : z[\"on\" + a] = e;\n        return this;\n      };\n\n      F.prototype.opacitySetter = function (a, e, b) {\n        this[e] = a;\n        b.setAttribute(e, a);\n      };\n\n      F.prototype.removeClass = function (f) {\n        return this.attr(\"class\", (\"\" + this.attr(\"class\")).replace(a(f) ? new RegExp(\"(^| )\" + f + \"( |$)\") : f, \" \").replace(/ +/g, \" \").trim());\n      };\n\n      F.prototype.removeTextOutline = function (a) {\n        for (var e = a.length, b; e--;) b = a[e], \"highcharts-text-outline\" === b.getAttribute(\"class\") && p(a, this.element.removeChild(b));\n      };\n\n      F.prototype.safeRemoveChild = function (a) {\n        var e = a.parentNode;\n        e && e.removeChild(a);\n      };\n\n      F.prototype.setRadialReference = function (a) {\n        var e = this.element.gradient && this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = a;\n        e && e.radAttr && e.animate(this.renderer.getRadialAttr(a, e.radAttr));\n        return this;\n      };\n\n      F.prototype.setTextPath = function (a, e) {\n        var b = this.element,\n            h = {\n          textAnchor: \"text-anchor\"\n        },\n            z = !1,\n            x = this.textPathWrapper,\n            d = !x;\n        e = A(!0, {\n          enabled: !0,\n          attributes: {\n            dy: -5,\n            startOffset: \"50%\",\n            textAnchor: \"middle\"\n          }\n        }, e);\n        var k = e.attributes;\n\n        if (a && e && e.enabled) {\n          x && null === x.element.parentNode ? (d = !0, x = x.destroy()) : x && this.removeTextOutline.call(x.parentGroup, [].slice.call(b.getElementsByTagName(\"tspan\")));\n          this.options && this.options.padding && (k.dx = -this.options.padding);\n          x || (this.textPathWrapper = x = this.renderer.createElement(\"textPath\"), z = !0);\n          var l = x.element;\n          (e = a.element.getAttribute(\"id\")) || a.element.setAttribute(\"id\", e = M());\n          if (d) for (a = b.getElementsByTagName(\"tspan\"); a.length;) a[0].setAttribute(\"y\", 0), f(k.dx) && a[0].setAttribute(\"x\", -k.dx), l.appendChild(a[0]);\n          z && x && x.add({\n            element: this.text ? this.text.element : b\n          });\n          l.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", this.renderer.url + \"#\" + e);\n          I(k.dy) && (l.parentNode.setAttribute(\"dy\", k.dy), delete k.dy);\n          I(k.dx) && (l.parentNode.setAttribute(\"dx\", k.dx), delete k.dx);\n          u(k, function (b, a) {\n            l.setAttribute(h[a] || a, b);\n          });\n          b.removeAttribute(\"transform\");\n          this.removeTextOutline.call(x, [].slice.call(b.getElementsByTagName(\"tspan\")));\n          this.text && !this.renderer.styledMode && this.attr({\n            fill: \"none\",\n            \"stroke-width\": 0\n          });\n          this.applyTextOutline = this.updateTransform = J;\n        } else x && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(b, a), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));\n\n        return this;\n      };\n\n      F.prototype.shadow = function (a, e, b) {\n        var h = [],\n            z = this.element,\n            x = !1,\n            f = this.oldShadowOptions;\n        var d = {\n          color: \"#000000\",\n          offsetX: 1,\n          offsetY: 1,\n          opacity: .15,\n          width: 3\n        };\n        var k;\n        !0 === a ? k = d : \"object\" === typeof a && (k = m(d, a));\n        k && (k && f && u(k, function (b, h) {\n          b !== f[h] && (x = !0);\n        }), x && this.destroyShadows(), this.oldShadowOptions = k);\n        if (!k) this.destroyShadows();else if (!this.shadows) {\n          var l = k.opacity / k.width;\n          var A = this.parentInverted ? \"translate(-1,-1)\" : \"translate(\" + k.offsetX + \", \" + k.offsetY + \")\";\n\n          for (d = 1; d <= k.width; d++) {\n            var p = z.cloneNode(!1);\n            var w = 2 * k.width + 1 - 2 * d;\n            n(p, {\n              stroke: a.color || \"#000000\",\n              \"stroke-opacity\": l * d,\n              \"stroke-width\": w,\n              transform: A,\n              fill: \"none\"\n            });\n            p.setAttribute(\"class\", (p.getAttribute(\"class\") || \"\") + \" highcharts-shadow\");\n            b && (n(p, \"height\", Math.max(n(p, \"height\") - w, 0)), p.cutHeight = w);\n            e ? e.element.appendChild(p) : z.parentNode && z.parentNode.insertBefore(p, z);\n            h.push(p);\n          }\n\n          this.shadows = h;\n        }\n        return this;\n      };\n\n      F.prototype.show = function (a) {\n        return this.attr({\n          visibility: a ? \"inherit\" : \"visible\"\n        });\n      };\n\n      F.prototype.strokeSetter = function (a, e, b) {\n        this[e] = a;\n        this.stroke && this[\"stroke-width\"] ? (F.prototype.fillSetter.call(this, this.stroke, \"stroke\", b), b.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0) : \"stroke-width\" === e && 0 === a && this.hasStroke ? (b.removeAttribute(\"stroke\"), this.hasStroke = !1) : this.renderer.styledMode && this[\"stroke-width\"] && (b.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0);\n      };\n\n      F.prototype.strokeWidth = function () {\n        if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n        var a = this.getStyle(\"stroke-width\"),\n            e = 0;\n        if (a.indexOf(\"px\") === a.length - 2) e = P(a);else if (\"\" !== a) {\n          var b = B.createElementNS(G, \"rect\");\n          n(b, {\n            width: a,\n            \"stroke-width\": 0\n          });\n          this.element.parentNode.appendChild(b);\n          e = b.getBBox().width;\n          b.parentNode.removeChild(b);\n        }\n        return e;\n      };\n\n      F.prototype.symbolAttr = function (a) {\n        var e = this;\n        \"x y r start end width height innerR anchorX anchorY clockwise\".split(\" \").forEach(function (b) {\n          e[b] = E(a[b], e[b]);\n        });\n        e.attr({\n          d: e.renderer.symbols[e.symbolName](e.x, e.y, e.width, e.height, e)\n        });\n      };\n\n      F.prototype.textSetter = function (a) {\n        a !== this.textStr && (delete this.textPxLength, this.textStr = a, this.added && this.renderer.buildText(this));\n      };\n\n      F.prototype.titleSetter = function (a) {\n        var e = this.element.getElementsByTagName(\"title\")[0];\n        e || (e = B.createElementNS(this.SVG_NS, \"title\"), this.element.appendChild(e));\n        e.firstChild && e.removeChild(e.firstChild);\n        e.appendChild(B.createTextNode(String(E(a, \"\")).replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\")));\n      };\n\n      F.prototype.toFront = function () {\n        var a = this.element;\n        a.parentNode.appendChild(a);\n        return this;\n      };\n\n      F.prototype.translate = function (a, e) {\n        return this.attr({\n          translateX: a,\n          translateY: e\n        });\n      };\n\n      F.prototype.updateShadows = function (a, e, b) {\n        var h = this.shadows;\n        if (h) for (var z = h.length; z--;) b.call(h[z], \"height\" === a ? Math.max(e - (h[z].cutHeight || 0), 0) : \"d\" === a ? this.d : e, a, h[z]);\n      };\n\n      F.prototype.updateTransform = function () {\n        var a = this.translateX || 0,\n            e = this.translateY || 0,\n            b = this.scaleX,\n            h = this.scaleY,\n            z = this.inverted,\n            x = this.rotation,\n            f = this.matrix,\n            d = this.element;\n        z && (a += this.width, e += this.height);\n        a = [\"translate(\" + a + \",\" + e + \")\"];\n        I(f) && a.push(\"matrix(\" + f.join(\",\") + \")\");\n        z ? a.push(\"rotate(90) scale(-1,1)\") : x && a.push(\"rotate(\" + x + \" \" + E(this.rotationOriginX, d.getAttribute(\"x\"), 0) + \" \" + E(this.rotationOriginY, d.getAttribute(\"y\") || 0) + \")\");\n        (I(b) || I(h)) && a.push(\"scale(\" + E(b, 1) + \" \" + E(h, 1) + \")\");\n        a.length && d.setAttribute(\"transform\", a.join(\" \"));\n      };\n\n      F.prototype.visibilitySetter = function (a, e, b) {\n        \"inherit\" === a ? b.removeAttribute(e) : this[e] !== a && b.setAttribute(e, a);\n        this[e] = a;\n      };\n\n      F.prototype.xGetter = function (a) {\n        \"circle\" === this.element.nodeName && (\"x\" === a ? a = \"cx\" : \"y\" === a && (a = \"cy\"));\n        return this._defaultGetter(a);\n      };\n\n      F.prototype.zIndexSetter = function (a, e) {\n        var b = this.renderer,\n            h = this.parentGroup,\n            z = (h || b).element || b.box,\n            x = this.element,\n            f = !1;\n        b = z === b.box;\n        var d = this.added;\n        var k;\n        I(a) ? (x.setAttribute(\"data-z-index\", a), a = +a, this[e] === a && (d = !1)) : I(this[e]) && x.removeAttribute(\"data-z-index\");\n        this[e] = a;\n\n        if (d) {\n          (a = this.zIndex) && h && (h.handleZ = !0);\n          e = z.childNodes;\n\n          for (k = e.length - 1; 0 <= k && !f; k--) {\n            h = e[k];\n            d = h.getAttribute(\"data-z-index\");\n            var l = !I(d);\n            if (h !== x) if (0 > a && l && !b && !k) z.insertBefore(x, e[k]), f = !0;else if (P(d) <= a || l && (!I(a) || 0 <= a)) z.insertBefore(x, e[k + 1] || null), f = !0;\n          }\n\n          f || (z.insertBefore(x, e[b ? 3 : 0] || null), f = !0);\n        }\n\n        return f;\n      };\n\n      return F;\n    }();\n\n    q.prototype[\"stroke-widthSetter\"] = q.prototype.strokeSetter;\n    q.prototype.yGetter = q.prototype.xGetter;\n\n    q.prototype.matrixSetter = q.prototype.rotationOriginXSetter = q.prototype.rotationOriginYSetter = q.prototype.rotationSetter = q.prototype.scaleXSetter = q.prototype.scaleYSetter = q.prototype.translateXSetter = q.prototype.translateYSetter = q.prototype.verticalAlignSetter = function (a, f) {\n      this[f] = a;\n      this.doTransform = !0;\n    };\n\n    c.SVGElement = q;\n    return c.SVGElement;\n  });\n  O(q, \"parts/SVGLabel.js\", [q[\"parts/SVGElement.js\"], q[\"parts/Utilities.js\"]], function (g, c) {\n    var q = this && this.__extends || function () {\n      var _c = function c(g, L) {\n        _c = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (c, g) {\n          c.__proto__ = g;\n        } || function (c, g) {\n          for (var n in g) g.hasOwnProperty(n) && (c[n] = g[n]);\n        };\n\n        return _c(g, L);\n      };\n\n      return function (g, L) {\n        function v() {\n          this.constructor = g;\n        }\n\n        _c(g, L);\n\n        g.prototype = null === L ? Object.create(L) : (v.prototype = L.prototype, new v());\n      };\n    }(),\n        y = c.defined,\n        B = c.extend,\n        H = c.isNumber,\n        D = c.merge,\n        J = c.removeEvent;\n\n    return function (c) {\n      function t(g, v, K, n, r, C, I, p, m, d) {\n        var l = c.call(this) || this;\n        l.init(g, \"g\");\n        l.textStr = v;\n        l.x = K;\n        l.y = n;\n        l.anchorX = C;\n        l.anchorY = I;\n        l.baseline = m;\n        l.className = d;\n        \"button\" !== d && l.addClass(\"highcharts-label\");\n        d && l.addClass(\"highcharts-\" + d);\n        l.text = g.text(\"\", 0, 0, p).attr({\n          zIndex: 1\n        });\n\n        if (\"string\" === typeof r) {\n          var k = /^url\\((.*?)\\)$/.test(r);\n          if (l.renderer.symbols[r] || k) l.symbolKey = r;\n        }\n\n        l.bBox = t.emptyBBox;\n        l.padding = 3;\n        l.paddingLeft = 0;\n        l.baselineOffset = 0;\n        l.needsBox = g.styledMode || k;\n        l.deferredAttr = {};\n        l.alignFactor = 0;\n        return l;\n      }\n\n      q(t, c);\n\n      t.prototype.alignSetter = function (c) {\n        c = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[c];\n        c !== this.alignFactor && (this.alignFactor = c, this.bBox && H(this.xSetting) && this.attr({\n          x: this.xSetting\n        }));\n      };\n\n      t.prototype.anchorXSetter = function (c, g) {\n        this.anchorX = c;\n        this.boxAttr(g, Math.round(c) - this.getCrispAdjust() - this.xSetting);\n      };\n\n      t.prototype.anchorYSetter = function (c, g) {\n        this.anchorY = c;\n        this.boxAttr(g, c - this.ySetting);\n      };\n\n      t.prototype.boxAttr = function (c, g) {\n        this.box ? this.box.attr(c, g) : this.deferredAttr[c] = g;\n      };\n\n      t.prototype.css = function (c) {\n        if (c) {\n          var v = {};\n          c = D(c);\n          t.textProps.forEach(function (n) {\n            \"undefined\" !== typeof c[n] && (v[n] = c[n], delete c[n]);\n          });\n          this.text.css(v);\n          var L = \"fontSize\" in v || \"fontWeight\" in v;\n          if (\"width\" in v || L) this.updateBoxSize(), L && this.updateTextPadding();\n        }\n\n        return g.prototype.css.call(this, c);\n      };\n\n      t.prototype.destroy = function () {\n        J(this.element, \"mouseenter\");\n        J(this.element, \"mouseleave\");\n        this.text && this.text.destroy();\n        this.box && (this.box = this.box.destroy());\n        g.prototype.destroy.call(this);\n      };\n\n      t.prototype.fillSetter = function (c, g) {\n        c && (this.needsBox = !0);\n        this.fill = c;\n        this.boxAttr(g, c);\n      };\n\n      t.prototype.getBBox = function () {\n        var c = this.bBox,\n            g = this.padding;\n        return {\n          width: c.width + 2 * g,\n          height: c.height + 2 * g,\n          x: c.x - g,\n          y: c.y - g\n        };\n      };\n\n      t.prototype.getCrispAdjust = function () {\n        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this[\"stroke-width\"] ? parseInt(this[\"stroke-width\"], 10) : 0) % 2 / 2;\n      };\n\n      t.prototype.heightSetter = function (c) {\n        this.heightSetting = c;\n      };\n\n      t.prototype.on = function (c, v) {\n        var t = this,\n            n = t.text,\n            r = n && \"SPAN\" === n.element.tagName ? n : void 0;\n\n        if (r) {\n          var C = function C(_C) {\n            (\"mouseenter\" === c || \"mouseleave\" === c) && _C.relatedTarget instanceof Element && (t.element.contains(_C.relatedTarget) || r.element.contains(_C.relatedTarget)) || v.call(t.element, _C);\n          };\n\n          r.on(c, C);\n        }\n\n        g.prototype.on.call(t, c, C || v);\n        return t;\n      };\n\n      t.prototype.onAdd = function () {\n        var c = this.textStr;\n        this.text.add(this);\n        this.attr({\n          text: y(c) ? c : \"\",\n          x: this.x,\n          y: this.y\n        });\n        this.box && y(this.anchorX) && this.attr({\n          anchorX: this.anchorX,\n          anchorY: this.anchorY\n        });\n      };\n\n      t.prototype.paddingSetter = function (c) {\n        y(c) && c !== this.padding && (this.padding = c, this.updateTextPadding());\n      };\n\n      t.prototype.paddingLeftSetter = function (c) {\n        y(c) && c !== this.paddingLeft && (this.paddingLeft = c, this.updateTextPadding());\n      };\n\n      t.prototype.rSetter = function (c, g) {\n        this.boxAttr(g, c);\n      };\n\n      t.prototype.shadow = function (c) {\n        c && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(c));\n        return this;\n      };\n\n      t.prototype.strokeSetter = function (c, g) {\n        this.stroke = c;\n        this.boxAttr(g, c);\n      };\n\n      t.prototype[\"stroke-widthSetter\"] = function (c, g) {\n        c && (this.needsBox = !0);\n        this[\"stroke-width\"] = c;\n        this.boxAttr(g, c);\n      };\n\n      t.prototype[\"text-alignSetter\"] = function (c) {\n        this.textAlign = c;\n      };\n\n      t.prototype.textSetter = function (c) {\n        \"undefined\" !== typeof c && this.text.attr({\n          text: c\n        });\n        this.updateBoxSize();\n        this.updateTextPadding();\n      };\n\n      t.prototype.updateBoxSize = function () {\n        var c = this.text.element.style,\n            g = {},\n            G = this.padding,\n            n = this.paddingLeft,\n            r = H(this.widthSetting) && H(this.heightSetting) && !this.textAlign || !y(this.text.textStr) ? t.emptyBBox : this.text.getBBox();\n        this.width = (this.widthSetting || r.width || 0) + 2 * G + n;\n        this.height = (this.heightSetting || r.height || 0) + 2 * G;\n        this.baselineOffset = G + Math.min(this.renderer.fontMetrics(c && c.fontSize, this.text).b, r.height || Infinity);\n        this.needsBox && (this.box || (c = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), c.addClass((\"button\" === this.className ? \"\" : \"highcharts-label-box\") + (this.className ? \" highcharts-\" + this.className + \"-box\" : \"\")), c.add(this), c = this.getCrispAdjust(), g.x = c, g.y = (this.baseline ? -this.baselineOffset : 0) + c), g.width = Math.round(this.width), g.height = Math.round(this.height), this.box.attr(B(g, this.deferredAttr)), this.deferredAttr = {});\n        this.bBox = r;\n      };\n\n      t.prototype.updateTextPadding = function () {\n        var c = this.text,\n            g = this.baseline ? 0 : this.baselineOffset,\n            t = this.paddingLeft + this.padding;\n        y(this.widthSetting) && this.bBox && (\"center\" === this.textAlign || \"right\" === this.textAlign) && (t += {\n          center: .5,\n          right: 1\n        }[this.textAlign] * (this.widthSetting - this.bBox.width));\n        if (t !== c.x || g !== c.y) c.attr(\"x\", t), c.hasBoxWidthChanged && (this.bBox = c.getBBox(!0), this.updateBoxSize()), \"undefined\" !== typeof g && c.attr(\"y\", g);\n        c.x = t;\n        c.y = g;\n      };\n\n      t.prototype.widthSetter = function (c) {\n        this.widthSetting = H(c) ? c : void 0;\n      };\n\n      t.prototype.xSetter = function (c) {\n        this.x = c;\n        this.alignFactor && (c -= this.alignFactor * ((this.widthSetting || this.bBox.width) + 2 * this.padding), this[\"forceAnimate:x\"] = !0);\n        this.xSetting = Math.round(c);\n        this.attr(\"translateX\", this.xSetting);\n      };\n\n      t.prototype.ySetter = function (c) {\n        this.ySetting = this.y = Math.round(c);\n        this.attr(\"translateY\", this.ySetting);\n      };\n\n      t.emptyBBox = {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n      t.textProps = \"color cursor direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width\".split(\" \");\n      return t;\n    }(g);\n  });\n  O(q, \"parts/SVGRenderer.js\", [q[\"parts/Color.js\"], q[\"parts/Globals.js\"], q[\"parts/SVGElement.js\"], q[\"parts/SVGLabel.js\"], q[\"parts/Utilities.js\"]], function (g, c, q, y, B) {\n    var H = B.addEvent,\n        D = B.attr,\n        J = B.createElement,\n        t = B.css,\n        G = B.defined,\n        L = B.destroyObjectProperties,\n        v = B.extend,\n        K = B.isArray,\n        n = B.isNumber,\n        r = B.isObject,\n        C = B.isString,\n        I = B.merge,\n        p = B.objectEach,\n        m = B.pick,\n        d = B.pInt,\n        l = B.splat,\n        k = B.uniqueKey,\n        f = c.charts,\n        a = c.deg2rad,\n        A = c.doc,\n        u = c.isFirefox,\n        E = c.isMS,\n        P = c.isWebKit;\n    B = c.noop;\n\n    var w = c.svg,\n        M = c.SVG_NS,\n        F = c.symbolSizes,\n        Q = c.win,\n        e = function () {\n      function b(b, a, e, f, d, k, l) {\n        this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;\n        this.init(b, a, e, f, d, k, l);\n      }\n\n      b.prototype.init = function (b, a, e, f, d, k, l) {\n        var h = this.createElement(\"svg\").attr({\n          version: \"1.1\",\n          \"class\": \"highcharts-root\"\n        });\n        l || h.css(this.getStyle(f));\n        f = h.element;\n        b.appendChild(f);\n        D(b, \"dir\", \"ltr\");\n        -1 === b.innerHTML.indexOf(\"xmlns\") && D(f, \"xmlns\", this.SVG_NS);\n        this.isSVG = !0;\n        this.box = f;\n        this.boxWrapper = h;\n        this.alignedObjects = [];\n        this.url = (u || P) && A.getElementsByTagName(\"base\").length ? Q.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\") : \"\";\n        this.createElement(\"desc\").add().element.appendChild(A.createTextNode(\"Created with Highcharts 8.1.2\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = k;\n        this.forExport = d;\n        this.styledMode = l;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.setSize(a, e, !1);\n        var x;\n        u && b.getBoundingClientRect && (a = function a() {\n          t(b, {\n            left: 0,\n            top: 0\n          });\n          x = b.getBoundingClientRect();\n          t(b, {\n            left: Math.ceil(x.left) - x.left + \"px\",\n            top: Math.ceil(x.top) - x.top + \"px\"\n          });\n        }, a(), this.unSubPixelFix = H(Q, \"resize\", a));\n      };\n\n      b.prototype.definition = function (b) {\n        function h(b, e) {\n          var f;\n          l(b).forEach(function (b) {\n            var x = a.createElement(b.tagName),\n                z = {};\n            p(b, function (b, h) {\n              \"tagName\" !== h && \"children\" !== h && \"textContent\" !== h && (z[h] = b);\n            });\n            x.attr(z);\n            x.add(e || a.defs);\n            b.textContent && x.element.appendChild(A.createTextNode(b.textContent));\n            h(b.children || [], x);\n            f = x;\n          });\n          return f;\n        }\n\n        var a = this;\n        return h(b);\n      };\n\n      b.prototype.getStyle = function (b) {\n        return this.style = v({\n          fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',\n          fontSize: \"12px\"\n        }, b);\n      };\n\n      b.prototype.setStyle = function (b) {\n        this.boxWrapper.css(this.getStyle(b));\n      };\n\n      b.prototype.isHidden = function () {\n        return !this.boxWrapper.getBBox().width;\n      };\n\n      b.prototype.destroy = function () {\n        var b = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        L(this.gradients || {});\n        this.gradients = null;\n        b && (this.defs = b.destroy());\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      };\n\n      b.prototype.createElement = function (b) {\n        var h = new this.Element();\n        h.init(this, b);\n        return h;\n      };\n\n      b.prototype.getRadialAttr = function (b, a) {\n        return {\n          cx: b[0] - b[2] / 2 + a.cx * b[2],\n          cy: b[1] - b[2] / 2 + a.cy * b[2],\n          r: a.r * b[2]\n        };\n      };\n\n      b.prototype.truncate = function (b, a, e, f, d, k, l) {\n        var h = this,\n            x = b.rotation,\n            z,\n            u = f ? 1 : 0,\n            N = (e || f).length,\n            m = N,\n            p = [],\n            w = function w(b) {\n          a.firstChild && a.removeChild(a.firstChild);\n          b && a.appendChild(A.createTextNode(b));\n        },\n            c = function c(x, z) {\n          z = z || x;\n          if (\"undefined\" === typeof p[z]) if (a.getSubStringLength) try {\n            p[z] = d + a.getSubStringLength(0, f ? z + 1 : z);\n          } catch (ha) {\n            \"\";\n          } else h.getSpanWidth && (w(l(e || f, x)), p[z] = d + h.getSpanWidth(b, a));\n          return p[z];\n        },\n            C;\n\n        b.rotation = 0;\n        var r = c(a.textContent.length);\n\n        if (C = d + r > k) {\n          for (; u <= N;) m = Math.ceil((u + N) / 2), f && (z = l(f, m)), r = c(m, z && z.length - 1), u === N ? u = N + 1 : r > k ? N = m - 1 : u = m;\n\n          0 === N ? w(\"\") : e && N === e.length - 1 || w(z || l(e || f, m));\n        }\n\n        f && f.splice(0, m);\n        b.actualWidth = r;\n        b.rotation = x;\n        return C;\n      };\n\n      b.prototype.buildText = function (b) {\n        var h = b.element,\n            a = this,\n            e = a.forExport,\n            f = m(b.textStr, \"\").toString(),\n            k = -1 !== f.indexOf(\"<\"),\n            l = h.childNodes,\n            u,\n            c = D(h, \"x\"),\n            r = b.styles,\n            E = b.textWidth,\n            n = r && r.lineHeight,\n            S = r && r.textOutline,\n            g = r && \"ellipsis\" === r.textOverflow,\n            I = r && \"nowrap\" === r.whiteSpace,\n            F = r && r.fontSize,\n            P,\n            v = l.length;\n        r = E && !b.added && this.box;\n\n        var G = function G(b) {\n          var e;\n          a.styledMode || (e = /(px|em)$/.test(b && b.style.fontSize) ? b.style.fontSize : F || a.style.fontSize || 12);\n          return n ? d(n) : a.fontMetrics(e, b.getAttribute(\"style\") ? b : h).h;\n        },\n            Q = function Q(b, h) {\n          p(a.escapes, function (a, e) {\n            h && -1 !== h.indexOf(a) || (b = b.toString().replace(new RegExp(a, \"g\"), e));\n          });\n          return b;\n        },\n            q = function q(b, h) {\n          var a = b.indexOf(\"<\");\n          b = b.substring(a, b.indexOf(\">\") - a);\n          a = b.indexOf(h + \"=\");\n          if (-1 !== a && (a = a + h.length + 1, h = b.charAt(a), '\"' === h || \"'\" === h)) return b = b.substring(a + 1), b.substring(0, b.indexOf(h));\n        },\n            K = /<br.*?>/g;\n\n        var J = [f, g, I, n, S, F, E].join();\n\n        if (J !== b.textCache) {\n          for (b.textCache = J; v--;) h.removeChild(l[v]);\n\n          k || S || g || E || -1 !== f.indexOf(\" \") && (!I || K.test(f)) ? (r && r.appendChild(h), k ? (f = a.styledMode ? f.replace(/<(b|strong)>/g, '<span class=\"highcharts-strong\">').replace(/<(i|em)>/g, '<span class=\"highcharts-emphasized\">') : f.replace(/<(b|strong)>/g, '<span style=\"font-weight:bold\">').replace(/<(i|em)>/g, '<span style=\"font-style:italic\">'), f = f.replace(/<a/g, \"<span\").replace(/<\\/(b|strong|i|em|a)>/g, \"</span>\").split(K)) : f = [f], f = f.filter(function (b) {\n            return \"\" !== b;\n          }), f.forEach(function (f, x) {\n            var z = 0,\n                d = 0;\n            f = f.replace(/^\\s+|\\s+$/g, \"\").replace(/<span/g, \"|||<span\").replace(/<\\/span>/g, \"</span>|||\");\n            var k = f.split(\"|||\");\n            k.forEach(function (f) {\n              if (\"\" !== f || 1 === k.length) {\n                var l = {},\n                    N = A.createElementNS(a.SVG_NS, \"tspan\"),\n                    m,\n                    p;\n                (m = q(f, \"class\")) && D(N, \"class\", m);\n                if (m = q(f, \"style\")) m = m.replace(/(;| |^)color([ :])/, \"$1fill$2\"), D(N, \"style\", m);\n\n                if ((p = q(f, \"href\")) && !e && -1 === p.split(\":\")[0].toLowerCase().indexOf(\"javascript\")) {\n                  var C = A.createElementNS(a.SVG_NS, \"a\");\n                  D(C, \"href\", p);\n                  D(N, \"class\", \"highcharts-anchor\");\n                  C.appendChild(N);\n                  a.styledMode || t(N, {\n                    cursor: \"pointer\"\n                  });\n                }\n\n                f = Q(f.replace(/<[a-zA-Z\\/](.|\\n)*?>/g, \"\") || \" \");\n\n                if (\" \" !== f) {\n                  N.appendChild(A.createTextNode(f));\n                  z ? l.dx = 0 : x && null !== c && (l.x = c);\n                  D(N, l);\n                  h.appendChild(C || N);\n                  !z && P && (!w && e && t(N, {\n                    display: \"block\"\n                  }), D(N, \"dy\", G(N)));\n\n                  if (E) {\n                    var r = f.replace(/([^\\^])-/g, \"$1- \").split(\" \");\n                    l = !I && (1 < k.length || x || 1 < r.length);\n                    C = 0;\n                    p = G(N);\n                    if (g) u = a.truncate(b, N, f, void 0, 0, Math.max(0, E - parseInt(F || 12, 10)), function (b, h) {\n                      return b.substring(0, h) + \"\\u2026\";\n                    });else if (l) for (; r.length;) r.length && !I && 0 < C && (N = A.createElementNS(M, \"tspan\"), D(N, {\n                      dy: p,\n                      x: c\n                    }), m && D(N, \"style\", m), N.appendChild(A.createTextNode(r.join(\" \").replace(/- /g, \"-\"))), h.appendChild(N)), a.truncate(b, N, null, r, 0 === C ? d : 0, E, function (b, h) {\n                      return r.slice(0, h).join(\" \").replace(/- /g, \"-\");\n                    }), d = b.actualWidth, C++;\n                  }\n\n                  z++;\n                }\n              }\n            });\n            P = P || h.childNodes.length;\n          }), g && u && b.attr(\"title\", Q(b.textStr || \"\", [\"&lt;\", \"&gt;\"])), r && r.removeChild(h), C(S) && b.applyTextOutline && b.applyTextOutline(S)) : h.appendChild(A.createTextNode(Q(f)));\n        }\n      };\n\n      b.prototype.getContrast = function (b) {\n        b = g.parse(b).rgba;\n        b[0] *= 1;\n        b[1] *= 1.2;\n        b[2] *= .5;\n        return 459 < b[0] + b[1] + b[2] ? \"#000000\" : \"#FFFFFF\";\n      };\n\n      b.prototype.button = function (b, a, e, f, d, k, l, u, m, p) {\n        var h = this.label(b, a, e, m, void 0, void 0, p, void 0, \"button\"),\n            x = 0,\n            z = this.styledMode;\n        b = d && d.style || {};\n        d && d.style && delete d.style;\n        h.attr(I({\n          padding: 8,\n          r: 2\n        }, d));\n\n        if (!z) {\n          d = I({\n            fill: \"#f7f7f7\",\n            stroke: \"#cccccc\",\n            \"stroke-width\": 1,\n            style: {\n              color: \"#333333\",\n              cursor: \"pointer\",\n              fontWeight: \"normal\"\n            }\n          }, {\n            style: b\n          }, d);\n          var N = d.style;\n          delete d.style;\n          k = I(d, {\n            fill: \"#e6e6e6\"\n          }, k);\n          var A = k.style;\n          delete k.style;\n          l = I(d, {\n            fill: \"#e6ebf5\",\n            style: {\n              color: \"#000000\",\n              fontWeight: \"bold\"\n            }\n          }, l);\n          var w = l.style;\n          delete l.style;\n          u = I(d, {\n            style: {\n              color: \"#cccccc\"\n            }\n          }, u);\n          var c = u.style;\n          delete u.style;\n        }\n\n        H(h.element, E ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== x && h.setState(1);\n        });\n        H(h.element, E ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== x && h.setState(x);\n        });\n\n        h.setState = function (b) {\n          1 !== b && (h.state = x = b);\n          h.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][b || 0]);\n          z || h.attr([d, k, l, u][b || 0]).css([N, A, w, c][b || 0]);\n        };\n\n        z || h.attr(d).css(v({\n          cursor: \"default\"\n        }, N));\n        return h.on(\"click\", function (b) {\n          3 !== x && f.call(h, b);\n        });\n      };\n\n      b.prototype.crispLine = function (b, a, e) {\n        void 0 === e && (e = \"round\");\n        var h = b[0],\n            f = b[1];\n        h[1] === f[1] && (h[1] = f[1] = Math[e](h[1]) - a % 2 / 2);\n        h[2] === f[2] && (h[2] = f[2] = Math[e](h[2]) + a % 2 / 2);\n        return b;\n      };\n\n      b.prototype.path = function (b) {\n        var h = this.styledMode ? {} : {\n          fill: \"none\"\n        };\n        K(b) ? h.d = b : r(b) && v(h, b);\n        return this.createElement(\"path\").attr(h);\n      };\n\n      b.prototype.circle = function (b, a, e) {\n        b = r(b) ? b : \"undefined\" === typeof b ? {} : {\n          x: b,\n          y: a,\n          r: e\n        };\n        a = this.createElement(\"circle\");\n\n        a.xSetter = a.ySetter = function (b, h, a) {\n          a.setAttribute(\"c\" + h, b);\n        };\n\n        return a.attr(b);\n      };\n\n      b.prototype.arc = function (b, a, e, f, d, k) {\n        r(b) ? (f = b, a = f.y, e = f.r, b = f.x) : f = {\n          innerR: f,\n          start: d,\n          end: k\n        };\n        b = this.symbol(\"arc\", b, a, e, e, f);\n        b.r = e;\n        return b;\n      };\n\n      b.prototype.rect = function (b, a, e, f, d, k) {\n        d = r(b) ? b.r : d;\n        var h = this.createElement(\"rect\");\n        b = r(b) ? b : \"undefined\" === typeof b ? {} : {\n          x: b,\n          y: a,\n          width: Math.max(e, 0),\n          height: Math.max(f, 0)\n        };\n        this.styledMode || (\"undefined\" !== typeof k && (b.strokeWidth = k, b = h.crisp(b)), b.fill = \"none\");\n        d && (b.r = d);\n\n        h.rSetter = function (b, a, e) {\n          h.r = b;\n          D(e, {\n            rx: b,\n            ry: b\n          });\n        };\n\n        h.rGetter = function () {\n          return h.r;\n        };\n\n        return h.attr(b);\n      };\n\n      b.prototype.setSize = function (b, a, e) {\n        var h = this.alignedObjects,\n            f = h.length;\n        this.width = b;\n        this.height = a;\n\n        for (this.boxWrapper.animate({\n          width: b,\n          height: a\n        }, {\n          step: function step() {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: m(e, !0) ? void 0 : 0\n        }); f--;) h[f].align();\n      };\n\n      b.prototype.g = function (b) {\n        var h = this.createElement(\"g\");\n        return b ? h.attr({\n          \"class\": \"highcharts-\" + b\n        }) : h;\n      };\n\n      b.prototype.image = function (b, a, e, f, d, k) {\n        var h = {\n          preserveAspectRatio: \"none\"\n        },\n            x = function x(b, h) {\n          b.setAttributeNS ? b.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", h) : b.setAttribute(\"hc-svg-href\", h);\n        },\n            z = function z(h) {\n          x(l.element, b);\n          k.call(l, h);\n        };\n\n        1 < arguments.length && v(h, {\n          x: a,\n          y: e,\n          width: f,\n          height: d\n        });\n        var l = this.createElement(\"image\").attr(h);\n        k ? (x(l.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"), h = new Q.Image(), H(h, \"load\", z), h.src = b, h.complete && z({})) : x(l.element, b);\n        return l;\n      };\n\n      b.prototype.symbol = function (b, a, e, d, k, l) {\n        var h = this,\n            x = /^url\\((.*?)\\)$/,\n            z = x.test(b),\n            u = !z && (this.symbols[b] ? b : \"circle\"),\n            N = u && this.symbols[u],\n            p;\n\n        if (N) {\n          \"number\" === typeof a && (p = N.call(this.symbols, Math.round(a || 0), Math.round(e || 0), d || 0, k || 0, l));\n          var w = this.path(p);\n          h.styledMode || w.attr(\"fill\", \"none\");\n          v(w, {\n            symbolName: u,\n            x: a,\n            y: e,\n            width: d,\n            height: k\n          });\n          l && v(w, l);\n        } else if (z) {\n          var c = b.match(x)[1];\n          w = this.image(c);\n          w.imgwidth = m(F[c] && F[c].width, l && l.width);\n          w.imgheight = m(F[c] && F[c].height, l && l.height);\n\n          var C = function C() {\n            w.attr({\n              width: w.width,\n              height: w.height\n            });\n          };\n\n          [\"width\", \"height\"].forEach(function (b) {\n            w[b + \"Setter\"] = function (b, h) {\n              var a = {},\n                  e = this[\"img\" + h],\n                  f = \"width\" === h ? \"translateX\" : \"translateY\";\n              this[h] = b;\n              G(e) && (l && \"within\" === l.backgroundSize && this.width && this.height && (e = Math.round(e * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(h, e), this.alignByTranslate || (a[f] = ((this[h] || 0) - e) / 2, this.attr(a)));\n            };\n          });\n          G(a) && w.attr({\n            x: a,\n            y: e\n          });\n          w.isImg = !0;\n          G(w.imgwidth) && G(w.imgheight) ? C() : (w.attr({\n            width: 0,\n            height: 0\n          }), J(\"img\", {\n            onload: function onload() {\n              var b = f[h.chartIndex];\n              0 === this.width && (t(this, {\n                position: \"absolute\",\n                top: \"-999em\"\n              }), A.body.appendChild(this));\n              F[c] = {\n                width: this.width,\n                height: this.height\n              };\n              w.imgwidth = this.width;\n              w.imgheight = this.height;\n              w.element && C();\n              this.parentNode && this.parentNode.removeChild(this);\n              h.imgCount--;\n              if (!h.imgCount && b && !b.hasLoaded) b.onload();\n            },\n            src: c\n          }), this.imgCount++);\n        }\n\n        return w;\n      };\n\n      b.prototype.clipRect = function (b, a, e, f) {\n        var h = k() + \"-\",\n            x = this.createElement(\"clipPath\").attr({\n          id: h\n        }).add(this.defs);\n        b = this.rect(b, a, e, f, 0).add(x);\n        b.id = h;\n        b.clipPath = x;\n        b.count = 0;\n        return b;\n      };\n\n      b.prototype.text = function (b, a, e, f) {\n        var h = {};\n        if (f && (this.allowHTML || !this.forExport)) return this.html(b, a, e);\n        h.x = Math.round(a || 0);\n        e && (h.y = Math.round(e));\n        G(b) && (h.text = b);\n        b = this.createElement(\"text\").attr(h);\n        f || (b.xSetter = function (b, h, a) {\n          var e = a.getElementsByTagName(\"tspan\"),\n              f = a.getAttribute(h),\n              x;\n\n          for (x = 0; x < e.length; x++) {\n            var d = e[x];\n            d.getAttribute(h) === f && d.setAttribute(h, b);\n          }\n\n          a.setAttribute(h, b);\n        });\n        return b;\n      };\n\n      b.prototype.fontMetrics = function (b, a) {\n        b = !this.styledMode && /px/.test(b) || !Q.getComputedStyle ? b || a && a.style && a.style.fontSize || this.style && this.style.fontSize : a && q.prototype.getStyle.call(a, \"font-size\");\n        b = /px/.test(b) ? d(b) : 12;\n        a = 24 > b ? b + 3 : Math.round(1.2 * b);\n        return {\n          h: a,\n          b: Math.round(.8 * a),\n          f: b\n        };\n      };\n\n      b.prototype.rotCorr = function (b, e, f) {\n        var h = b;\n        e && f && (h = Math.max(h * Math.cos(e * a), 4));\n        return {\n          x: -b / 3 * Math.sin(e * a),\n          y: h\n        };\n      };\n\n      b.prototype.pathToSegments = function (b) {\n        for (var h = [], a = [], e = {\n          A: 8,\n          C: 7,\n          H: 2,\n          L: 3,\n          M: 3,\n          Q: 5,\n          S: 5,\n          T: 3,\n          V: 2\n        }, f = 0; f < b.length; f++) C(a[0]) && n(b[f]) && a.length === e[a[0].toUpperCase()] && b.splice(f, 0, a[0].replace(\"M\", \"L\").replace(\"m\", \"l\")), \"string\" === typeof b[f] && (a.length && h.push(a.slice(0)), a.length = 0), a.push(b[f]);\n\n        h.push(a.slice(0));\n        return h;\n      };\n\n      b.prototype.label = function (b, a, e, f, d, k, l, u, m) {\n        return new y(this, b, a, e, f, d, k, l, u, m);\n      };\n\n      return b;\n    }();\n\n    e.prototype.Element = q;\n    e.prototype.SVG_NS = M;\n    e.prototype.draw = B;\n    e.prototype.escapes = {\n      \"&\": \"&amp;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      \"'\": \"&#39;\",\n      '\"': \"&quot;\"\n    };\n    e.prototype.symbols = {\n      circle: function circle(b, h, a, e) {\n        return this.arc(b + a / 2, h + e / 2, a / 2, e / 2, {\n          start: .5 * Math.PI,\n          end: 2.5 * Math.PI,\n          open: !1\n        });\n      },\n      square: function square(b, h, a, e) {\n        return [[\"M\", b, h], [\"L\", b + a, h], [\"L\", b + a, h + e], [\"L\", b, h + e], [\"Z\"]];\n      },\n      triangle: function triangle(b, h, a, e) {\n        return [[\"M\", b + a / 2, h], [\"L\", b + a, h + e], [\"L\", b, h + e], [\"Z\"]];\n      },\n      \"triangle-down\": function triangleDown(b, h, a, e) {\n        return [[\"M\", b, h], [\"L\", b + a, h], [\"L\", b + a / 2, h + e], [\"Z\"]];\n      },\n      diamond: function diamond(b, h, a, e) {\n        return [[\"M\", b + a / 2, h], [\"L\", b + a, h + e / 2], [\"L\", b + a / 2, h + e], [\"L\", b, h + e / 2], [\"Z\"]];\n      },\n      arc: function arc(b, h, a, e, f) {\n        var d = [];\n\n        if (f) {\n          var x = f.start || 0,\n              k = f.end || 0,\n              z = f.r || a;\n          a = f.r || e || a;\n          var l = .001 > Math.abs(k - x - 2 * Math.PI);\n          k -= .001;\n          e = f.innerR;\n          l = m(f.open, l);\n          var u = Math.cos(x),\n              p = Math.sin(x),\n              N = Math.cos(k),\n              A = Math.sin(k);\n          x = m(f.longArc, .001 > k - x - Math.PI ? 0 : 1);\n          d.push([\"M\", b + z * u, h + a * p], [\"A\", z, a, 0, x, m(f.clockwise, 1), b + z * N, h + a * A]);\n          G(e) && d.push(l ? [\"M\", b + e * N, h + e * A] : [\"L\", b + e * N, h + e * A], [\"A\", e, e, 0, x, G(f.clockwise) ? 1 - f.clockwise : 0, b + e * u, h + e * p]);\n          l || d.push([\"Z\"]);\n        }\n\n        return d;\n      },\n      callout: function callout(b, h, a, e, f) {\n        var d = Math.min(f && f.r || 0, a, e),\n            k = d + 6,\n            x = f && f.anchorX || 0;\n        f = f && f.anchorY || 0;\n        var z = [[\"M\", b + d, h], [\"L\", b + a - d, h], [\"C\", b + a, h, b + a, h, b + a, h + d], [\"L\", b + a, h + e - d], [\"C\", b + a, h + e, b + a, h + e, b + a - d, h + e], [\"L\", b + d, h + e], [\"C\", b, h + e, b, h + e, b, h + e - d], [\"L\", b, h + d], [\"C\", b, h, b, h, b + d, h]];\n        x && x > a ? f > h + k && f < h + e - k ? z.splice(3, 1, [\"L\", b + a, f - 6], [\"L\", b + a + 6, f], [\"L\", b + a, f + 6], [\"L\", b + a, h + e - d]) : z.splice(3, 1, [\"L\", b + a, e / 2], [\"L\", x, f], [\"L\", b + a, e / 2], [\"L\", b + a, h + e - d]) : x && 0 > x ? f > h + k && f < h + e - k ? z.splice(7, 1, [\"L\", b, f + 6], [\"L\", b - 6, f], [\"L\", b, f - 6], [\"L\", b, h + d]) : z.splice(7, 1, [\"L\", b, e / 2], [\"L\", x, f], [\"L\", b, e / 2], [\"L\", b, h + d]) : f && f > e && x > b + k && x < b + a - k ? z.splice(5, 1, [\"L\", x + 6, h + e], [\"L\", x, h + e + 6], [\"L\", x - 6, h + e], [\"L\", b + d, h + e]) : f && 0 > f && x > b + k && x < b + a - k && z.splice(1, 1, [\"L\", x - 6, h], [\"L\", x, h - 6], [\"L\", x + 6, h], [\"L\", a - d, h]);\n        return z;\n      }\n    };\n    c.SVGRenderer = e;\n    c.Renderer = c.SVGRenderer;\n    return c.Renderer;\n  });\n  O(q, \"parts/Html.js\", [q[\"parts/Globals.js\"], q[\"parts/SVGElement.js\"], q[\"parts/SVGRenderer.js\"], q[\"parts/Utilities.js\"]], function (g, c, q, y) {\n    var B = y.attr,\n        H = y.createElement,\n        D = y.css,\n        J = y.defined,\n        t = y.extend,\n        G = y.pick,\n        L = y.pInt,\n        v = g.isFirefox,\n        K = g.isMS,\n        n = g.isWebKit,\n        r = g.win;\n    t(c.prototype, {\n      htmlCss: function htmlCss(c) {\n        var r = \"SPAN\" === this.element.tagName && c && \"width\" in c,\n            p = G(r && c.width, void 0);\n\n        if (r) {\n          delete c.width;\n          this.textWidth = p;\n          var m = !0;\n        }\n\n        c && \"ellipsis\" === c.textOverflow && (c.whiteSpace = \"nowrap\", c.overflow = \"hidden\");\n        this.styles = t(this.styles, c);\n        D(this.element, c);\n        m && this.htmlUpdateTransform();\n        return this;\n      },\n      htmlGetBBox: function htmlGetBBox() {\n        var c = this.element;\n        return {\n          x: c.offsetLeft,\n          y: c.offsetTop,\n          width: c.offsetWidth,\n          height: c.offsetHeight\n        };\n      },\n      htmlUpdateTransform: function htmlUpdateTransform() {\n        if (this.added) {\n          var c = this.renderer,\n              r = this.element,\n              p = this.translateX || 0,\n              m = this.translateY || 0,\n              d = this.x || 0,\n              l = this.y || 0,\n              k = this.textAlign || \"left\",\n              f = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[k],\n              a = this.styles,\n              A = a && a.whiteSpace;\n          D(r, {\n            marginLeft: p,\n            marginTop: m\n          });\n          !c.styledMode && this.shadows && this.shadows.forEach(function (a) {\n            D(a, {\n              marginLeft: p + 1,\n              marginTop: m + 1\n            });\n          });\n          this.inverted && [].forEach.call(r.childNodes, function (a) {\n            c.invertChild(a, r);\n          });\n\n          if (\"SPAN\" === r.tagName) {\n            a = this.rotation;\n            var u = this.textWidth && L(this.textWidth),\n                E = [a, k, r.innerHTML, this.textWidth, this.textAlign].join(),\n                n;\n            (n = u !== this.oldTextWidth) && !(n = u > this.oldTextWidth) && ((n = this.textPxLength) || (D(r, {\n              width: \"\",\n              whiteSpace: A || \"nowrap\"\n            }), n = r.offsetWidth), n = n > u);\n            n && (/[ \\-]/.test(r.textContent || r.innerText) || \"ellipsis\" === r.style.textOverflow) ? (D(r, {\n              width: u + \"px\",\n              display: \"block\",\n              whiteSpace: A || \"normal\"\n            }), this.oldTextWidth = u, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;\n            E !== this.cTT && (A = c.fontMetrics(r.style.fontSize, r).b, !J(a) || a === (this.oldRotation || 0) && k === this.oldAlign || this.setSpanRotation(a, f, A), this.getSpanCorrection(!J(a) && this.textPxLength || r.offsetWidth, A, f, a, k));\n            D(r, {\n              left: d + (this.xCorr || 0) + \"px\",\n              top: l + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = E;\n            this.oldRotation = a;\n            this.oldAlign = k;\n          }\n        } else this.alignOnAdd = !0;\n      },\n      setSpanRotation: function setSpanRotation(c, r, p) {\n        var m = {},\n            d = this.renderer.getTransformKey();\n        m[d] = m.transform = \"rotate(\" + c + \"deg)\";\n        m[d + (v ? \"Origin\" : \"-origin\")] = m.transformOrigin = 100 * r + \"% \" + p + \"px\";\n        D(this.element, m);\n      },\n      getSpanCorrection: function getSpanCorrection(c, r, p) {\n        this.xCorr = -c * p;\n        this.yCorr = -r;\n      }\n    });\n    t(q.prototype, {\n      getTransformKey: function getTransformKey() {\n        return K && !/Edge/.test(r.navigator.userAgent) ? \"-ms-transform\" : n ? \"-webkit-transform\" : v ? \"MozTransform\" : r.opera ? \"-o-transform\" : \"\";\n      },\n      html: function html(r, n, p) {\n        var m = this.createElement(\"span\"),\n            d = m.element,\n            l = m.renderer,\n            k = l.isSVG,\n            f = function f(a, _f) {\n          [\"opacity\", \"visibility\"].forEach(function (d) {\n            a[d + \"Setter\"] = function (k, l, u) {\n              var m = a.div ? a.div.style : _f;\n              c.prototype[d + \"Setter\"].call(this, k, l, u);\n              m && (m[l] = k);\n            };\n          });\n          a.addedSetters = !0;\n        };\n\n        m.textSetter = function (a) {\n          a !== d.innerHTML && (delete this.bBox, delete this.oldTextWidth);\n          this.textStr = a;\n          d.innerHTML = G(a, \"\");\n          m.doTransform = !0;\n        };\n\n        k && f(m, m.element.style);\n\n        m.xSetter = m.ySetter = m.alignSetter = m.rotationSetter = function (a, f) {\n          \"align\" === f && (f = \"textAlign\");\n          m[f] = a;\n          m.doTransform = !0;\n        };\n\n        m.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n\n        m.attr({\n          text: r,\n          x: Math.round(n),\n          y: Math.round(p)\n        }).css({\n          position: \"absolute\"\n        });\n        l.styledMode || m.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        });\n        d.style.whiteSpace = \"nowrap\";\n        m.css = m.htmlCss;\n        k && (m.add = function (a) {\n          var k = l.box.parentNode,\n              u = [];\n\n          if (this.parentGroup = a) {\n            var p = a.div;\n\n            if (!p) {\n              for (; a;) u.push(a), a = a.parentGroup;\n\n              u.reverse().forEach(function (a) {\n                function d(f, e) {\n                  a[e] = f;\n                  \"translateX\" === e ? A.left = f + \"px\" : A.top = f + \"px\";\n                  a.doTransform = !0;\n                }\n\n                var l = B(a.element, \"class\");\n                p = a.div = a.div || H(\"div\", l ? {\n                  className: l\n                } : void 0, {\n                  position: \"absolute\",\n                  left: (a.translateX || 0) + \"px\",\n                  top: (a.translateY || 0) + \"px\",\n                  display: a.display,\n                  opacity: a.opacity,\n                  pointerEvents: a.styles && a.styles.pointerEvents\n                }, p || k);\n                var A = p.style;\n                t(a, {\n                  classSetter: function (a) {\n                    return function (e) {\n                      this.element.setAttribute(\"class\", e);\n                      a.className = e;\n                    };\n                  }(p),\n                  on: function on() {\n                    u[0].div && m.on.apply({\n                      element: u[0].div\n                    }, arguments);\n                    return a;\n                  },\n                  translateXSetter: d,\n                  translateYSetter: d\n                });\n                a.addedSetters || f(a);\n              });\n            }\n          } else p = k;\n\n          p.appendChild(d);\n          m.added = !0;\n          m.alignOnAdd && m.htmlUpdateTransform();\n          return m;\n        });\n        return m;\n      }\n    });\n  });\n  O(q, \"parts/Tick.js\", [q[\"parts/Globals.js\"], q[\"parts/Utilities.js\"]], function (g, c) {\n    var q = c.clamp,\n        y = c.correctFloat,\n        B = c.defined,\n        H = c.destroyObjectProperties,\n        D = c.extend,\n        J = c.fireEvent,\n        t = c.isNumber,\n        G = c.merge,\n        L = c.objectEach,\n        v = c.pick,\n        K = g.deg2rad;\n\n    c = function () {\n      function c(c, C, n, p, m) {\n        this.isNewLabel = this.isNew = !0;\n        this.axis = c;\n        this.pos = C;\n        this.type = n || \"\";\n        this.parameters = m || {};\n        this.tickmarkOffset = this.parameters.tickmarkOffset;\n        this.options = this.parameters.options;\n        J(this, \"init\");\n        n || p || this.addLabel();\n      }\n\n      c.prototype.addLabel = function () {\n        var c = this,\n            C = c.axis,\n            n = C.options,\n            p = C.chart,\n            m = C.categories,\n            d = C.logarithmic,\n            l = C.names,\n            k = c.pos,\n            f = v(c.options && c.options.labels, n.labels),\n            a = C.tickPositions,\n            A = k === a[0],\n            u = k === a[a.length - 1];\n        l = this.parameters.category || (m ? v(m[k], l[k], k) : k);\n        var E = c.label;\n        m = (!f.step || 1 === f.step) && 1 === C.tickInterval;\n        a = a.info;\n        var g, w;\n\n        if (C.dateTime && a) {\n          var M = p.time.resolveDTLFormat(n.dateTimeLabelFormats[!n.grid && a.higherRanks[k] || a.unitName]);\n          var F = M.main;\n        }\n\n        c.isFirst = A;\n        c.isLast = u;\n        c.formatCtx = {\n          axis: C,\n          chart: p,\n          isFirst: A,\n          isLast: u,\n          dateTimeLabelFormat: F,\n          tickPositionInfo: a,\n          value: d ? y(d.lin2log(l)) : l,\n          pos: k\n        };\n        n = C.labelFormatter.call(c.formatCtx, this.formatCtx);\n        if (w = M && M.list) c.shortenLabel = function () {\n          for (g = 0; g < w.length; g++) if (E.attr({\n            text: C.labelFormatter.call(D(c.formatCtx, {\n              dateTimeLabelFormat: w[g]\n            }))\n          }), E.getBBox().width < C.getSlotWidth(c) - 2 * v(f.padding, 5)) return;\n\n          E.attr({\n            text: \"\"\n          });\n        };\n        m && C._addedPlotLB && C.isXAxis && c.moveLabel(n, f);\n        B(E) || c.movedLabel ? E && E.textStr !== n && !m && (!E.textWidth || f.style && f.style.width || E.styles.width || E.css({\n          width: null\n        }), E.attr({\n          text: n\n        }), E.textPxLength = E.getBBox().width) : (c.label = E = c.createLabel({\n          x: 0,\n          y: 0\n        }, n, f), c.rotation = 0);\n      };\n\n      c.prototype.createLabel = function (c, C, n) {\n        var p = this.axis,\n            m = p.chart;\n        if (c = B(C) && n.enabled ? m.renderer.text(C, c.x, c.y, n.useHTML).add(p.labelGroup) : null) m.styledMode || c.css(G(n.style)), c.textPxLength = c.getBBox().width;\n        return c;\n      };\n\n      c.prototype.destroy = function () {\n        H(this, this.axis);\n      };\n\n      c.prototype.getPosition = function (c, C, n, p) {\n        var m = this.axis,\n            d = m.chart,\n            l = p && d.oldChartHeight || d.chartHeight;\n        c = {\n          x: c ? y(m.translate(C + n, null, null, p) + m.transB) : m.left + m.offset + (m.opposite ? (p && d.oldChartWidth || d.chartWidth) - m.right - m.left : 0),\n          y: c ? l - m.bottom + m.offset - (m.opposite ? m.height : 0) : y(l - m.translate(C + n, null, null, p) - m.transB)\n        };\n        c.y = q(c.y, -1E5, 1E5);\n        J(this, \"afterGetPosition\", {\n          pos: c\n        });\n        return c;\n      };\n\n      c.prototype.getLabelPosition = function (c, C, n, p, m, d, l, k) {\n        var f = this.axis,\n            a = f.transA,\n            A = f.isLinked && f.linkedParent ? f.linkedParent.reversed : f.reversed,\n            u = f.staggerLines,\n            r = f.tickRotCorr || {\n          x: 0,\n          y: 0\n        },\n            g = m.y,\n            w = p || f.reserveSpaceDefault ? 0 : -f.labelOffset * (\"center\" === f.labelAlign ? .5 : 1),\n            M = {};\n        B(g) || (g = 0 === f.side ? n.rotation ? -8 : -n.getBBox().height : 2 === f.side ? r.y + 8 : Math.cos(n.rotation * K) * (r.y - n.getBBox(!1, 0).height / 2));\n        c = c + m.x + w + r.x - (d && p ? d * a * (A ? -1 : 1) : 0);\n        C = C + g - (d && !p ? d * a * (A ? 1 : -1) : 0);\n        u && (n = l / (k || 1) % u, f.opposite && (n = u - n - 1), C += f.labelOffset / u * n);\n        M.x = c;\n        M.y = Math.round(C);\n        J(this, \"afterGetLabelPosition\", {\n          pos: M,\n          tickmarkOffset: d,\n          index: l\n        });\n        return M;\n      };\n\n      c.prototype.getLabelSize = function () {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      };\n\n      c.prototype.getMarkPath = function (c, C, n, p, m, d) {\n        return d.crispLine([[\"M\", c, C], [\"L\", c + (m ? 0 : -n), C + (m ? n : 0)]], p);\n      };\n\n      c.prototype.handleOverflow = function (c) {\n        var r = this.axis,\n            n = r.options.labels,\n            p = c.x,\n            m = r.chart.chartWidth,\n            d = r.chart.spacing,\n            l = v(r.labelLeft, Math.min(r.pos, d[3]));\n        d = v(r.labelRight, Math.max(r.isRadial ? 0 : r.pos + r.len, m - d[1]));\n        var k = this.label,\n            f = this.rotation,\n            a = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[r.labelAlign || k.attr(\"align\")],\n            A = k.getBBox().width,\n            u = r.getSlotWidth(this),\n            E = u,\n            g = 1,\n            w,\n            M = {};\n        if (f || \"justify\" !== v(n.overflow, \"justify\")) 0 > f && p - a * A < l ? w = Math.round(p / Math.cos(f * K) - l) : 0 < f && p + a * A > d && (w = Math.round((m - p) / Math.cos(f * K)));else if (m = p + (1 - a) * A, p - a * A < l ? E = c.x + E * (1 - a) - l : m > d && (E = d - c.x + E * a, g = -1), E = Math.min(u, E), E < u && \"center\" === r.labelAlign && (c.x += g * (u - E - a * (u - Math.min(A, E)))), A > E || r.autoRotation && (k.styles || {}).width) w = E;\n        w && (this.shortenLabel ? this.shortenLabel() : (M.width = Math.floor(w) + \"px\", (n.style || {}).textOverflow || (M.textOverflow = \"ellipsis\"), k.css(M)));\n      };\n\n      c.prototype.moveLabel = function (c, C) {\n        var r = this,\n            p = r.label,\n            m = !1,\n            d = r.axis,\n            l = d.reversed,\n            k = d.chart.inverted;\n        p && p.textStr === c ? (r.movedLabel = p, m = !0, delete r.label) : L(d.ticks, function (a) {\n          m || a.isNew || a === r || !a.label || a.label.textStr !== c || (r.movedLabel = a.label, m = !0, a.labelPos = r.movedLabel.xy, delete a.label);\n        });\n\n        if (!m && (r.labelPos || p)) {\n          var f = r.labelPos || p.xy;\n          p = k ? f.x : l ? 0 : d.width + d.left;\n          d = k ? l ? d.width + d.left : 0 : f.y;\n          r.movedLabel = r.createLabel({\n            x: p,\n            y: d\n          }, c, C);\n          r.movedLabel && r.movedLabel.attr({\n            opacity: 0\n          });\n        }\n      };\n\n      c.prototype.render = function (c, C, n) {\n        var p = this.axis,\n            m = p.horiz,\n            d = this.pos,\n            l = v(this.tickmarkOffset, p.tickmarkOffset);\n        d = this.getPosition(m, d, l, C);\n        l = d.x;\n        var k = d.y;\n        p = m && l === p.pos + p.len || !m && k === p.pos ? -1 : 1;\n        n = v(n, 1);\n        this.isActive = !0;\n        this.renderGridLine(C, n, p);\n        this.renderMark(d, n, p);\n        this.renderLabel(d, C, n, c);\n        this.isNew = !1;\n        J(this, \"afterRender\");\n      };\n\n      c.prototype.renderGridLine = function (c, C, n) {\n        var p = this.axis,\n            m = p.options,\n            d = this.gridLine,\n            l = {},\n            k = this.pos,\n            f = this.type,\n            a = v(this.tickmarkOffset, p.tickmarkOffset),\n            A = p.chart.renderer,\n            u = f ? f + \"Grid\" : \"grid\",\n            r = m[u + \"LineWidth\"],\n            g = m[u + \"LineColor\"];\n        m = m[u + \"LineDashStyle\"];\n        d || (p.chart.styledMode || (l.stroke = g, l[\"stroke-width\"] = r, m && (l.dashstyle = m)), f || (l.zIndex = 1), c && (C = 0), this.gridLine = d = A.path().attr(l).addClass(\"highcharts-\" + (f ? f + \"-\" : \"\") + \"grid-line\").add(p.gridGroup));\n        if (d && (n = p.getPlotLinePath({\n          value: k + a,\n          lineWidth: d.strokeWidth() * n,\n          force: \"pass\",\n          old: c\n        }))) d[c || this.isNew ? \"attr\" : \"animate\"]({\n          d: n,\n          opacity: C\n        });\n      };\n\n      c.prototype.renderMark = function (c, n, g) {\n        var p = this.axis,\n            m = p.options,\n            d = p.chart.renderer,\n            l = this.type,\n            k = l ? l + \"Tick\" : \"tick\",\n            f = p.tickSize(k),\n            a = this.mark,\n            A = !a,\n            u = c.x;\n        c = c.y;\n        var r = v(m[k + \"Width\"], !l && p.isXAxis ? 1 : 0);\n        m = m[k + \"Color\"];\n        f && (p.opposite && (f[0] = -f[0]), A && (this.mark = a = d.path().addClass(\"highcharts-\" + (l ? l + \"-\" : \"\") + \"tick\").add(p.axisGroup), p.chart.styledMode || a.attr({\n          stroke: m,\n          \"stroke-width\": r\n        })), a[A ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(u, c, f[0], a.strokeWidth() * g, p.horiz, d),\n          opacity: n\n        }));\n      };\n\n      c.prototype.renderLabel = function (c, n, g, p) {\n        var m = this.axis,\n            d = m.horiz,\n            l = m.options,\n            k = this.label,\n            f = l.labels,\n            a = f.step;\n        m = v(this.tickmarkOffset, m.tickmarkOffset);\n        var A = !0,\n            u = c.x;\n        c = c.y;\n        k && t(u) && (k.xy = c = this.getLabelPosition(u, c, k, d, f, m, p, a), this.isFirst && !this.isLast && !v(l.showFirstLabel, 1) || this.isLast && !this.isFirst && !v(l.showLastLabel, 1) ? A = !1 : !d || f.step || f.rotation || n || 0 === g || this.handleOverflow(c), a && p % a && (A = !1), A && t(c.y) ? (c.opacity = g, k[this.isNewLabel ? \"attr\" : \"animate\"](c), this.isNewLabel = !1) : (k.attr(\"y\", -9999), this.isNewLabel = !0));\n      };\n\n      c.prototype.replaceMovedLabel = function () {\n        var c = this.label,\n            n = this.axis,\n            g = n.reversed,\n            p = this.axis.chart.inverted;\n\n        if (c && !this.isNew) {\n          var m = p ? c.xy.x : g ? n.left : n.width + n.left;\n          g = p ? g ? n.width + n.top : n.top : c.xy.y;\n          c.animate({\n            x: m,\n            y: g,\n            opacity: 0\n          }, void 0, c.destroy);\n          delete this.label;\n        }\n\n        n.isDirty = !0;\n        this.label = this.movedLabel;\n        delete this.movedLabel;\n      };\n\n      return c;\n    }();\n\n    g.Tick = c;\n    return g.Tick;\n  });\n  O(q, \"parts/Time.js\", [q[\"parts/Globals.js\"], q[\"parts/Utilities.js\"]], function (g, c) {\n    var q = c.defined,\n        y = c.error,\n        B = c.extend,\n        H = c.isObject,\n        D = c.merge,\n        J = c.objectEach,\n        t = c.pad,\n        G = c.pick,\n        L = c.splat,\n        v = c.timeUnits,\n        K = g.win;\n\n    c = function () {\n      function c(c) {\n        this.options = {};\n        this.variableTimezone = this.useUTC = !1;\n        this.Date = K.Date;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.update(c);\n      }\n\n      c.prototype.get = function (c, n) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          var r = n.getTime(),\n              p = r - this.getTimezoneOffset(n);\n          n.setTime(p);\n          c = n[\"getUTC\" + c]();\n          n.setTime(r);\n          return c;\n        }\n\n        return this.useUTC ? n[\"getUTC\" + c]() : n[\"get\" + c]();\n      };\n\n      c.prototype.set = function (c, n, g) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          if (\"Milliseconds\" === c || \"Seconds\" === c || \"Minutes\" === c) return n[\"setUTC\" + c](g);\n          var p = this.getTimezoneOffset(n);\n          p = n.getTime() - p;\n          n.setTime(p);\n          n[\"setUTC\" + c](g);\n          c = this.getTimezoneOffset(n);\n          p = n.getTime() + c;\n          return n.setTime(p);\n        }\n\n        return this.useUTC ? n[\"setUTC\" + c](g) : n[\"set\" + c](g);\n      };\n\n      c.prototype.update = function (c) {\n        var n = G(c && c.useUTC, !0);\n        this.options = c = D(!0, this.options || {}, c);\n        this.Date = c.Date || K.Date || Date;\n        this.timezoneOffset = (this.useUTC = n) && c.timezoneOffset;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.variableTimezone = !(n && !c.getTimezoneOffset && !c.timezone);\n      };\n\n      c.prototype.makeTime = function (c, n, t, p, m, d) {\n        if (this.useUTC) {\n          var l = this.Date.UTC.apply(0, arguments);\n          var k = this.getTimezoneOffset(l);\n          l += k;\n          var f = this.getTimezoneOffset(l);\n          k !== f ? l += f - k : k - 36E5 !== this.getTimezoneOffset(l - 36E5) || g.isSafari || (l -= 36E5);\n        } else l = new this.Date(c, n, G(t, 1), G(p, 0), G(m, 0), G(d, 0)).getTime();\n\n        return l;\n      };\n\n      c.prototype.timezoneOffsetFunction = function () {\n        var c = this,\n            n = this.options,\n            g = K.moment;\n        if (!this.useUTC) return function (c) {\n          return 6E4 * new Date(c.toString()).getTimezoneOffset();\n        };\n\n        if (n.timezone) {\n          if (g) return function (c) {\n            return 6E4 * -g.tz(c, n.timezone).utcOffset();\n          };\n          y(25);\n        }\n\n        return this.useUTC && n.getTimezoneOffset ? function (c) {\n          return 6E4 * n.getTimezoneOffset(c.valueOf());\n        } : function () {\n          return 6E4 * (c.timezoneOffset || 0);\n        };\n      };\n\n      c.prototype.dateFormat = function (c, n, v) {\n        var p;\n        if (!q(n) || isNaN(n)) return (null === (p = g.defaultOptions.lang) || void 0 === p ? void 0 : p.invalidDate) || \"\";\n        c = G(c, \"%Y-%m-%d %H:%M:%S\");\n        var m = this;\n        p = new this.Date(n);\n        var d = this.get(\"Hours\", p),\n            l = this.get(\"Day\", p),\n            k = this.get(\"Date\", p),\n            f = this.get(\"Month\", p),\n            a = this.get(\"FullYear\", p),\n            A = g.defaultOptions.lang,\n            u = null === A || void 0 === A ? void 0 : A.weekdays,\n            E = null === A || void 0 === A ? void 0 : A.shortWeekdays;\n        p = B({\n          a: E ? E[l] : u[l].substr(0, 3),\n          A: u[l],\n          d: t(k),\n          e: t(k, 2, \" \"),\n          w: l,\n          b: A.shortMonths[f],\n          B: A.months[f],\n          m: t(f + 1),\n          o: f + 1,\n          y: a.toString().substr(2, 2),\n          Y: a,\n          H: t(d),\n          k: d,\n          I: t(d % 12 || 12),\n          l: d % 12 || 12,\n          M: t(this.get(\"Minutes\", p)),\n          p: 12 > d ? \"AM\" : \"PM\",\n          P: 12 > d ? \"am\" : \"pm\",\n          S: t(p.getSeconds()),\n          L: t(Math.floor(n % 1E3), 3)\n        }, g.dateFormats);\n        J(p, function (a, f) {\n          for (; -1 !== c.indexOf(\"%\" + f);) c = c.replace(\"%\" + f, \"function\" === typeof a ? a.call(m, n) : a);\n        });\n        return v ? c.substr(0, 1).toUpperCase() + c.substr(1) : c;\n      };\n\n      c.prototype.resolveDTLFormat = function (c) {\n        return H(c, !0) ? c : (c = L(c), {\n          main: c[0],\n          from: c[1],\n          to: c[2]\n        });\n      };\n\n      c.prototype.getTimeTicks = function (c, n, g, p) {\n        var m = this,\n            d = [],\n            l = {};\n        var k = new m.Date(n);\n        var f = c.unitRange,\n            a = c.count || 1,\n            A;\n        p = G(p, 1);\n\n        if (q(n)) {\n          m.set(\"Milliseconds\", k, f >= v.second ? 0 : a * Math.floor(m.get(\"Milliseconds\", k) / a));\n          f >= v.second && m.set(\"Seconds\", k, f >= v.minute ? 0 : a * Math.floor(m.get(\"Seconds\", k) / a));\n          f >= v.minute && m.set(\"Minutes\", k, f >= v.hour ? 0 : a * Math.floor(m.get(\"Minutes\", k) / a));\n          f >= v.hour && m.set(\"Hours\", k, f >= v.day ? 0 : a * Math.floor(m.get(\"Hours\", k) / a));\n          f >= v.day && m.set(\"Date\", k, f >= v.month ? 1 : Math.max(1, a * Math.floor(m.get(\"Date\", k) / a)));\n\n          if (f >= v.month) {\n            m.set(\"Month\", k, f >= v.year ? 0 : a * Math.floor(m.get(\"Month\", k) / a));\n            var u = m.get(\"FullYear\", k);\n          }\n\n          f >= v.year && m.set(\"FullYear\", k, u - u % a);\n          f === v.week && (u = m.get(\"Day\", k), m.set(\"Date\", k, m.get(\"Date\", k) - u + p + (u < p ? -7 : 0)));\n          u = m.get(\"FullYear\", k);\n          p = m.get(\"Month\", k);\n          var E = m.get(\"Date\", k),\n              r = m.get(\"Hours\", k);\n          n = k.getTime();\n          m.variableTimezone && (A = g - n > 4 * v.month || m.getTimezoneOffset(n) !== m.getTimezoneOffset(g));\n          n = k.getTime();\n\n          for (k = 1; n < g;) d.push(n), n = f === v.year ? m.makeTime(u + k * a, 0) : f === v.month ? m.makeTime(u, p + k * a) : !A || f !== v.day && f !== v.week ? A && f === v.hour && 1 < a ? m.makeTime(u, p, E, r + k * a) : n + f * a : m.makeTime(u, p, E + k * a * (f === v.day ? 1 : 7)), k++;\n\n          d.push(n);\n          f <= v.hour && 1E4 > d.length && d.forEach(function (a) {\n            0 === a % 18E5 && \"000000000\" === m.dateFormat(\"%H%M%S%L\", a) && (l[a] = \"day\");\n          });\n        }\n\n        d.info = B(c, {\n          higherRanks: l,\n          totalRange: f * a\n        });\n        return d;\n      };\n\n      return c;\n    }();\n\n    g.Time = c;\n    return g.Time;\n  });\n  O(q, \"parts/Options.js\", [q[\"parts/Globals.js\"], q[\"parts/Time.js\"], q[\"parts/Color.js\"], q[\"parts/Utilities.js\"]], function (g, c, q, y) {\n    q = q.parse;\n    y = y.merge;\n    g.defaultOptions = {\n      colors: \"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \"),\n      symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n      lang: {\n        loading: \"Loading...\",\n        months: \"January February March April May June July August September October November December\".split(\" \"),\n        shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n        decimalPoint: \".\",\n        numericSymbols: \"kMGTPE\".split(\"\"),\n        resetZoom: \"Reset zoom\",\n        resetZoomTitle: \"Reset zoom level 1:1\",\n        thousandsSep: \" \"\n      },\n      global: {},\n      time: {\n        Date: void 0,\n        getTimezoneOffset: void 0,\n        timezone: void 0,\n        timezoneOffset: 0,\n        useUTC: !0\n      },\n      chart: {\n        styledMode: !1,\n        borderRadius: 0,\n        colorCount: 10,\n        defaultSeriesType: \"line\",\n        ignoreHiddenSeries: !0,\n        spacing: [10, 10, 15, 10],\n        resetZoomButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        },\n        width: null,\n        height: null,\n        borderColor: \"#335cad\",\n        backgroundColor: \"#ffffff\",\n        plotBorderColor: \"#cccccc\"\n      },\n      title: {\n        text: \"Chart title\",\n        align: \"center\",\n        margin: 15,\n        widthAdjust: -44\n      },\n      subtitle: {\n        text: \"\",\n        align: \"center\",\n        widthAdjust: -44\n      },\n      caption: {\n        margin: 15,\n        text: \"\",\n        align: \"left\",\n        verticalAlign: \"bottom\"\n      },\n      plotOptions: {},\n      labels: {\n        style: {\n          position: \"absolute\",\n          color: \"#333333\"\n        }\n      },\n      legend: {\n        enabled: !0,\n        align: \"center\",\n        alignColumns: !0,\n        layout: \"horizontal\",\n        labelFormatter: function labelFormatter() {\n          return this.name;\n        },\n        borderColor: \"#999999\",\n        borderRadius: 0,\n        navigation: {\n          activeColor: \"#003399\",\n          inactiveColor: \"#cccccc\"\n        },\n        itemStyle: {\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontSize: \"12px\",\n          fontWeight: \"bold\",\n          textOverflow: \"ellipsis\"\n        },\n        itemHoverStyle: {\n          color: \"#000000\"\n        },\n        itemHiddenStyle: {\n          color: \"#cccccc\"\n        },\n        shadow: !1,\n        itemCheckboxStyle: {\n          position: \"absolute\",\n          width: \"13px\",\n          height: \"13px\"\n        },\n        squareSymbol: !0,\n        symbolPadding: 5,\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        title: {\n          style: {\n            fontWeight: \"bold\"\n          }\n        }\n      },\n      loading: {\n        labelStyle: {\n          fontWeight: \"bold\",\n          position: \"relative\",\n          top: \"45%\"\n        },\n        style: {\n          position: \"absolute\",\n          backgroundColor: \"#ffffff\",\n          opacity: .5,\n          textAlign: \"center\"\n        }\n      },\n      tooltip: {\n        enabled: !0,\n        animation: g.svg,\n        borderRadius: 3,\n        dateTimeLabelFormats: {\n          millisecond: \"%A, %b %e, %H:%M:%S.%L\",\n          second: \"%A, %b %e, %H:%M:%S\",\n          minute: \"%A, %b %e, %H:%M\",\n          hour: \"%A, %b %e, %H:%M\",\n          day: \"%A, %b %e, %Y\",\n          week: \"Week from %A, %b %e, %Y\",\n          month: \"%B %Y\",\n          year: \"%Y\"\n        },\n        footerFormat: \"\",\n        padding: 8,\n        snap: g.isTouchDevice ? 25 : 10,\n        headerFormat: '<span style=\"font-size: 10px\">{point.key}</span><br/>',\n        pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.y}</b><br/>',\n        backgroundColor: q(\"#f7f7f7\").setOpacity(.85).get(),\n        borderWidth: 1,\n        shadow: !0,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"12px\",\n          whiteSpace: \"nowrap\"\n        }\n      },\n      credits: {\n        enabled: !0,\n        href: \"https://www.highcharts.com?credits\",\n        position: {\n          align: \"right\",\n          x: -10,\n          verticalAlign: \"bottom\",\n          y: -5\n        },\n        style: {\n          cursor: \"pointer\",\n          color: \"#999999\",\n          fontSize: \"9px\"\n        },\n        text: \"Highcharts.com\"\n      }\n    };\n    \"\";\n    g.time = new c(y(g.defaultOptions.global, g.defaultOptions.time));\n\n    g.dateFormat = function (c, q, y) {\n      return g.time.dateFormat(c, q, y);\n    };\n\n    return {\n      dateFormat: g.dateFormat,\n      defaultOptions: g.defaultOptions,\n      time: g.time\n    };\n  });\n  O(q, \"parts/Axis.js\", [q[\"parts/Color.js\"], q[\"parts/Globals.js\"], q[\"parts/Tick.js\"], q[\"parts/Utilities.js\"], q[\"parts/Options.js\"]], function (g, c, q, y, B) {\n    var H = y.addEvent,\n        D = y.animObject,\n        J = y.arrayMax,\n        t = y.arrayMin,\n        G = y.clamp,\n        L = y.correctFloat,\n        v = y.defined,\n        K = y.destroyObjectProperties,\n        n = y.error,\n        r = y.extend,\n        C = y.fireEvent,\n        I = y.format,\n        p = y.getMagnitude,\n        m = y.isArray,\n        d = y.isFunction,\n        l = y.isNumber,\n        k = y.isString,\n        f = y.merge,\n        a = y.normalizeTickInterval,\n        A = y.objectEach,\n        u = y.pick,\n        E = y.relativeLength,\n        P = y.removeEvent,\n        w = y.splat,\n        M = y.syncTimeout,\n        F = B.defaultOptions,\n        Q = c.deg2rad;\n\n    y = function () {\n      function e(b, a) {\n        this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.oldMin = this.oldMax = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.coll = this.closestPointRange = this.chart = this.categories = this.bottom = this.alternateBands = void 0;\n        this.init(b, a);\n      }\n\n      e.prototype.init = function (b, a) {\n        var h = a.isX,\n            e = this;\n        e.chart = b;\n        e.horiz = b.inverted && !e.isZAxis ? !h : h;\n        e.isXAxis = h;\n        e.coll = e.coll || (h ? \"xAxis\" : \"yAxis\");\n        C(this, \"init\", {\n          userOptions: a\n        });\n        e.opposite = a.opposite;\n        e.side = a.side || (e.horiz ? e.opposite ? 0 : 2 : e.opposite ? 1 : 3);\n        e.setOptions(a);\n        var f = this.options,\n            k = f.type;\n        e.labelFormatter = f.labels.formatter || e.defaultLabelFormatter;\n        e.userOptions = a;\n        e.minPixelPadding = 0;\n        e.reversed = f.reversed;\n        e.visible = !1 !== f.visible;\n        e.zoomEnabled = !1 !== f.zoomEnabled;\n        e.hasNames = \"category\" === k || !0 === f.categories;\n        e.categories = f.categories || e.hasNames;\n        e.names || (e.names = [], e.names.keys = {});\n        e.plotLinesAndBandsGroups = {};\n        e.positiveValuesOnly = !(!e.logarithmic || f.allowNegativeLog);\n        e.isLinked = v(f.linkedTo);\n        e.ticks = {};\n        e.labelEdge = [];\n        e.minorTicks = {};\n        e.plotLinesAndBands = [];\n        e.alternateBands = {};\n        e.len = 0;\n        e.minRange = e.userMinRange = f.minRange || f.maxZoom;\n        e.range = f.range;\n        e.offset = f.offset || 0;\n        e.max = null;\n        e.min = null;\n        e.crosshair = u(f.crosshair, w(b.options.tooltip.crosshairs)[h ? 0 : 1], !1);\n        a = e.options.events;\n        -1 === b.axes.indexOf(e) && (h ? b.axes.splice(b.xAxis.length, 0, e) : b.axes.push(e), b[e.coll].push(e));\n        e.series = e.series || [];\n        b.inverted && !e.isZAxis && h && \"undefined\" === typeof e.reversed && (e.reversed = !0);\n        e.labelRotation = e.options.labels.rotation;\n        A(a, function (b, a) {\n          d(b) && H(e, a, b);\n        });\n        C(this, \"afterInit\");\n      };\n\n      e.prototype.setOptions = function (b) {\n        this.options = f(e.defaultOptions, \"yAxis\" === this.coll && e.defaultYAxisOptions, [e.defaultTopAxisOptions, e.defaultRightAxisOptions, e.defaultBottomAxisOptions, e.defaultLeftAxisOptions][this.side], f(F[this.coll], b));\n        C(this, \"afterSetOptions\", {\n          userOptions: b\n        });\n      };\n\n      e.prototype.defaultLabelFormatter = function () {\n        var b = this.axis,\n            a = l(this.value) ? this.value : NaN,\n            e = b.chart.time,\n            f = b.categories,\n            d = this.dateTimeLabelFormat,\n            k = F.lang,\n            c = k.numericSymbols;\n        k = k.numericSymbolMagnitude || 1E3;\n        var u = c && c.length,\n            m = b.options.labels.format;\n        b = b.logarithmic ? Math.abs(a) : b.tickInterval;\n        var p = this.chart,\n            A = p.numberFormatter;\n        if (m) var w = I(m, this, p);else if (f) w = \"\" + this.value;else if (d) w = e.dateFormat(d, a);else if (u && 1E3 <= b) for (; u-- && \"undefined\" === typeof w;) e = Math.pow(k, u + 1), b >= e && 0 === 10 * a % e && null !== c[u] && 0 !== a && (w = A(a / e, -1) + c[u]);\n        \"undefined\" === typeof w && (w = 1E4 <= Math.abs(a) ? A(a, -1) : A(a, -1, void 0, \"\"));\n        return w;\n      };\n\n      e.prototype.getSeriesExtremes = function () {\n        var b = this,\n            a = b.chart,\n            e;\n        C(this, \"getSeriesExtremes\", null, function () {\n          b.hasVisibleSeries = !1;\n          b.dataMin = b.dataMax = b.threshold = null;\n          b.softThreshold = !b.isXAxis;\n          b.stacking && b.stacking.buildStacks();\n          b.series.forEach(function (h) {\n            if (h.visible || !a.options.chart.ignoreHiddenSeries) {\n              var f = h.options,\n                  d = f.threshold;\n              b.hasVisibleSeries = !0;\n              b.positiveValuesOnly && 0 >= d && (d = null);\n\n              if (b.isXAxis) {\n                if (f = h.xData, f.length) {\n                  e = h.getXExtremes(f);\n                  var k = e.min;\n                  var x = e.max;\n                  l(k) || k instanceof Date || (f = f.filter(l), e = h.getXExtremes(f), k = e.min, x = e.max);\n                  f.length && (b.dataMin = Math.min(u(b.dataMin, k), k), b.dataMax = Math.max(u(b.dataMax, x), x));\n                }\n              } else if (h = h.applyExtremes(), l(h.dataMin) && (k = h.dataMin, b.dataMin = Math.min(u(b.dataMin, k), k)), l(h.dataMax) && (x = h.dataMax, b.dataMax = Math.max(u(b.dataMax, x), x)), v(d) && (b.threshold = d), !f.softThreshold || b.positiveValuesOnly) b.softThreshold = !1;\n            }\n          });\n        });\n        C(this, \"afterGetSeriesExtremes\");\n      };\n\n      e.prototype.translate = function (b, a, e, f, d, k) {\n        var h = this.linkedParent || this,\n            x = 1,\n            z = 0,\n            c = f ? h.oldTransA : h.transA;\n        f = f ? h.oldMin : h.min;\n        var u = h.minPixelPadding;\n        d = (h.isOrdinal || h.brokenAxis && h.brokenAxis.hasBreaks || h.logarithmic && d) && h.lin2val;\n        c || (c = h.transA);\n        e && (x *= -1, z = h.len);\n        h.reversed && (x *= -1, z -= x * (h.sector || h.len));\n        a ? (b = (b * x + z - u) / c + f, d && (b = h.lin2val(b))) : (d && (b = h.val2lin(b)), b = l(f) ? x * (b - f) * c + z + x * u + (l(k) ? c * k : 0) : void 0);\n        return b;\n      };\n\n      e.prototype.toPixels = function (b, a) {\n        return this.translate(b, !1, !this.horiz, null, !0) + (a ? 0 : this.pos);\n      };\n\n      e.prototype.toValue = function (b, a) {\n        return this.translate(b - (a ? 0 : this.pos), !0, !this.horiz, null, !0);\n      };\n\n      e.prototype.getPlotLinePath = function (b) {\n        function a(b, a, h) {\n          if (\"pass\" !== w && b < a || b > h) w ? b = G(b, a, h) : t = !0;\n          return b;\n        }\n\n        var e = this,\n            f = e.chart,\n            d = e.left,\n            k = e.top,\n            c = b.old,\n            m = b.value,\n            p = b.translatedValue,\n            A = b.lineWidth,\n            w = b.force,\n            n,\n            g,\n            E,\n            r,\n            M = c && f.oldChartHeight || f.chartHeight,\n            F = c && f.oldChartWidth || f.chartWidth,\n            t,\n            v = e.transB;\n        b = {\n          value: m,\n          lineWidth: A,\n          old: c,\n          force: w,\n          acrossPanes: b.acrossPanes,\n          translatedValue: p\n        };\n        C(this, \"getPlotLinePath\", b, function (b) {\n          p = u(p, e.translate(m, null, null, c));\n          p = G(p, -1E5, 1E5);\n          n = E = Math.round(p + v);\n          g = r = Math.round(M - p - v);\n          l(p) ? e.horiz ? (g = k, r = M - e.bottom, n = E = a(n, d, d + e.width)) : (n = d, E = F - e.right, g = r = a(g, k, k + e.height)) : (t = !0, w = !1);\n          b.path = t && !w ? null : f.renderer.crispLine([[\"M\", n, g], [\"L\", E, r]], A || 1);\n        });\n        return b.path;\n      };\n\n      e.prototype.getLinearTickPositions = function (b, a, e) {\n        var h = L(Math.floor(a / b) * b);\n        e = L(Math.ceil(e / b) * b);\n        var f = [],\n            d;\n        L(h + b) === h && (d = 20);\n        if (this.single) return [a];\n\n        for (a = h; a <= e;) {\n          f.push(a);\n          a = L(a + b, d);\n          if (a === k) break;\n          var k = a;\n        }\n\n        return f;\n      };\n\n      e.prototype.getMinorTickInterval = function () {\n        var b = this.options;\n        return !0 === b.minorTicks ? u(b.minorTickInterval, \"auto\") : !1 === b.minorTicks ? null : b.minorTickInterval;\n      };\n\n      e.prototype.getMinorTickPositions = function () {\n        var b = this.options,\n            a = this.tickPositions,\n            e = this.minorTickInterval,\n            f = [],\n            d = this.pointRangePadding || 0,\n            k = this.min - d;\n        d = this.max + d;\n        var c = d - k;\n\n        if (c && c / e < this.len / 3) {\n          var l = this.logarithmic;\n          if (l) this.paddedTicks.forEach(function (b, a, h) {\n            a && f.push.apply(f, l.getLogTickPositions(e, h[a - 1], h[a], !0));\n          });else if (this.dateTime && \"auto\" === this.getMinorTickInterval()) f = f.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(e), k, d, b.startOfWeek));else for (b = k + (a[0] - k) % e; b <= d && b !== f[0]; b += e) f.push(b);\n        }\n\n        0 !== f.length && this.trimTicks(f);\n        return f;\n      };\n\n      e.prototype.adjustForMinRange = function () {\n        var b = this.options,\n            a = this.min,\n            e = this.max,\n            f = this.logarithmic,\n            d,\n            k,\n            c,\n            l,\n            m;\n        this.isXAxis && \"undefined\" === typeof this.minRange && !f && (v(b.min) || v(b.max) ? this.minRange = null : (this.series.forEach(function (b) {\n          l = b.xData;\n\n          for (k = m = b.xIncrement ? 1 : l.length - 1; 0 < k; k--) if (c = l[k] - l[k - 1], \"undefined\" === typeof d || c < d) d = c;\n        }), this.minRange = Math.min(5 * d, this.dataMax - this.dataMin)));\n\n        if (e - a < this.minRange) {\n          var p = this.dataMax - this.dataMin >= this.minRange;\n          var A = this.minRange;\n          var w = (A - e + a) / 2;\n          w = [a - w, u(b.min, a - w)];\n          p && (w[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);\n          a = J(w);\n          e = [a + A, u(b.max, a + A)];\n          p && (e[2] = f ? f.log2lin(this.dataMax) : this.dataMax);\n          e = t(e);\n          e - a < A && (w[0] = e - A, w[1] = u(b.min, e - A), a = J(w));\n        }\n\n        this.min = a;\n        this.max = e;\n      };\n\n      e.prototype.getClosest = function () {\n        var b;\n        this.categories ? b = 1 : this.series.forEach(function (a) {\n          var h = a.closestPointRange,\n              e = a.visible || !a.chart.options.chart.ignoreHiddenSeries;\n          !a.noSharedTooltip && v(h) && e && (b = v(b) ? Math.min(b, h) : h);\n        });\n        return b;\n      };\n\n      e.prototype.nameToX = function (b) {\n        var a = m(this.categories),\n            e = a ? this.categories : this.names,\n            f = b.options.x;\n        b.series.requireSorting = !1;\n        v(f) || (f = !1 === this.options.uniqueNames ? b.series.autoIncrement() : a ? e.indexOf(b.name) : u(e.keys[b.name], -1));\n\n        if (-1 === f) {\n          if (!a) var d = e.length;\n        } else d = f;\n\n        \"undefined\" !== typeof d && (this.names[d] = b.name, this.names.keys[b.name] = d);\n        return d;\n      };\n\n      e.prototype.updateNames = function () {\n        var b = this,\n            a = this.names;\n        0 < a.length && (Object.keys(a.keys).forEach(function (b) {\n          delete a.keys[b];\n        }), a.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (a) {\n          a.xIncrement = null;\n          if (!a.points || a.isDirtyData) b.max = Math.max(b.max, a.xData.length - 1), a.processData(), a.generatePoints();\n          a.data.forEach(function (h, e) {\n            if (h && h.options && \"undefined\" !== typeof h.name) {\n              var f = b.nameToX(h);\n              \"undefined\" !== typeof f && f !== h.x && (h.x = f, a.xData[e] = f);\n            }\n          });\n        }));\n      };\n\n      e.prototype.setAxisTranslation = function (b) {\n        var a = this,\n            e = a.max - a.min,\n            f = a.axisPointRange || 0,\n            d = 0,\n            c = 0,\n            l = a.linkedParent,\n            m = !!a.categories,\n            p = a.transA,\n            A = a.isXAxis;\n\n        if (A || m || f) {\n          var w = a.getClosest();\n          l ? (d = l.minPointOffset, c = l.pointRangePadding) : a.series.forEach(function (b) {\n            var h = m ? 1 : A ? u(b.options.pointRange, w, 0) : a.axisPointRange || 0,\n                e = b.options.pointPlacement;\n            f = Math.max(f, h);\n            if (!a.single || m) b = b.is(\"xrange\") ? !A : A, d = Math.max(d, b && k(e) ? 0 : h / 2), c = Math.max(c, b && \"on\" === e ? 0 : h);\n          });\n          l = a.ordinal && a.ordinal.slope && w ? a.ordinal.slope / w : 1;\n          a.minPointOffset = d *= l;\n          a.pointRangePadding = c *= l;\n          a.pointRange = Math.min(f, a.single && m ? 1 : e);\n          A && (a.closestPointRange = w);\n        }\n\n        b && (a.oldTransA = p);\n        a.translationSlope = a.transA = p = a.staticScale || a.len / (e + c || 1);\n        a.transB = a.horiz ? a.left : a.bottom;\n        a.minPixelPadding = p * d;\n        C(this, \"afterSetAxisTranslation\");\n      };\n\n      e.prototype.minFromRange = function () {\n        return this.max - this.range;\n      };\n\n      e.prototype.setTickInterval = function (b) {\n        var h = this,\n            e = h.chart,\n            f = h.logarithmic,\n            d = h.options,\n            k = h.isXAxis,\n            c = h.isLinked,\n            m = d.maxPadding,\n            A = d.minPadding,\n            w = d.tickInterval,\n            g = d.tickPixelInterval,\n            E = h.categories,\n            r = l(h.threshold) ? h.threshold : null,\n            S = h.softThreshold;\n        h.dateTime || E || c || this.getTickAmount();\n        var M = u(h.userMin, d.min);\n        var F = u(h.userMax, d.max);\n\n        if (c) {\n          h.linkedParent = e[h.coll][d.linkedTo];\n          var t = h.linkedParent.getExtremes();\n          h.min = u(t.min, t.dataMin);\n          h.max = u(t.max, t.dataMax);\n          d.type !== h.linkedParent.options.type && n(11, 1, e);\n        } else {\n          if (!S && v(r)) if (h.dataMin >= r) t = r, A = 0;else if (h.dataMax <= r) {\n            var P = r;\n            m = 0;\n          }\n          h.min = u(M, t, h.dataMin);\n          h.max = u(F, P, h.dataMax);\n        }\n\n        f && (h.positiveValuesOnly && !b && 0 >= Math.min(h.min, u(h.dataMin, h.min)) && n(10, 1, e), h.min = L(f.log2lin(h.min), 16), h.max = L(f.log2lin(h.max), 16));\n        h.range && v(h.max) && (h.userMin = h.min = M = Math.max(h.dataMin, h.minFromRange()), h.userMax = F = h.max, h.range = null);\n        C(h, \"foundExtremes\");\n        h.beforePadding && h.beforePadding();\n        h.adjustForMinRange();\n        !(E || h.axisPointRange || h.stacking && h.stacking.usePercentage || c) && v(h.min) && v(h.max) && (e = h.max - h.min) && (!v(M) && A && (h.min -= e * A), !v(F) && m && (h.max += e * m));\n        l(h.userMin) || (l(d.softMin) && d.softMin < h.min && (h.min = M = d.softMin), l(d.floor) && (h.min = Math.max(h.min, d.floor)));\n        l(h.userMax) || (l(d.softMax) && d.softMax > h.max && (h.max = F = d.softMax), l(d.ceiling) && (h.max = Math.min(h.max, d.ceiling)));\n        S && v(h.dataMin) && (r = r || 0, !v(M) && h.min < r && h.dataMin >= r ? h.min = h.options.minRange ? Math.min(r, h.max - h.minRange) : r : !v(F) && h.max > r && h.dataMax <= r && (h.max = h.options.minRange ? Math.max(r, h.min + h.minRange) : r));\n        h.tickInterval = h.min === h.max || \"undefined\" === typeof h.min || \"undefined\" === typeof h.max ? 1 : c && !w && g === h.linkedParent.options.tickPixelInterval ? w = h.linkedParent.tickInterval : u(w, this.tickAmount ? (h.max - h.min) / Math.max(this.tickAmount - 1, 1) : void 0, E ? 1 : (h.max - h.min) * g / Math.max(h.len, g));\n        k && !b && h.series.forEach(function (b) {\n          b.processData(h.min !== h.oldMin || h.max !== h.oldMax);\n        });\n        h.setAxisTranslation(!0);\n        C(this, \"initialAxisTranslation\");\n        h.pointRange && !w && (h.tickInterval = Math.max(h.pointRange, h.tickInterval));\n        b = u(d.minTickInterval, h.dateTime && !h.series.some(function (b) {\n          return b.noSharedTooltip;\n        }) ? h.closestPointRange : 0);\n        !w && h.tickInterval < b && (h.tickInterval = b);\n        h.dateTime || h.logarithmic || w || (h.tickInterval = a(h.tickInterval, void 0, p(h.tickInterval), u(d.allowDecimals, .5 > h.tickInterval || void 0 !== this.tickAmount), !!this.tickAmount));\n        this.tickAmount || (h.tickInterval = h.unsquish());\n        this.setTickPositions();\n      };\n\n      e.prototype.setTickPositions = function () {\n        var b = this.options,\n            a = b.tickPositions;\n        var e = this.getMinorTickInterval();\n        var f = b.tickPositioner,\n            d = this.hasVerticalPanning(),\n            k = \"colorAxis\" === this.coll,\n            c = (k || !d) && b.startOnTick;\n        d = (k || !d) && b.endOnTick;\n        this.tickmarkOffset = this.categories && \"between\" === b.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === e && this.tickInterval ? this.tickInterval / 5 : e;\n        this.single = this.min === this.max && v(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== b.allowDecimals);\n        this.tickPositions = e = a && a.slice();\n        !e && (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) ? e = this.dateTime ? this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, b.units), this.min, this.max, b.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0) : this.logarithmic ? this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max) : (e = [this.min, this.max], n(19, !1, this.chart)), e.length > this.len && (e = [e[0], e.pop()], e[0] === e[1] && (e.length = 1)), this.tickPositions = e, f && (f = f.apply(this, [this.min, this.max]))) && (this.tickPositions = e = f);\n        this.paddedTicks = e.slice(0);\n        this.trimTicks(e, c, d);\n        this.isLinked || (this.single && 2 > e.length && !this.categories && !this.series.some(function (b) {\n          return b.is(\"heatmap\") && \"between\" === b.options.pointPlacement;\n        }) && (this.min -= .5, this.max += .5), a || f || this.adjustTickAmount());\n        C(this, \"afterSetTickPositions\");\n      };\n\n      e.prototype.trimTicks = function (b, a, e) {\n        var h = b[0],\n            f = b[b.length - 1],\n            d = !this.isOrdinal && this.minPointOffset || 0;\n        C(this, \"trimTicks\");\n\n        if (!this.isLinked) {\n          if (a && -Infinity !== h) this.min = h;else for (; this.min - d > b[0];) b.shift();\n          if (e) this.max = f;else for (; this.max + d < b[b.length - 1];) b.pop();\n          0 === b.length && v(h) && !this.options.tickPositions && b.push((f + h) / 2);\n        }\n      };\n\n      e.prototype.alignToOthers = function () {\n        var b = {},\n            a,\n            e = this.options;\n        !1 === this.chart.options.chart.alignTicks || !1 === e.alignTicks || !1 === e.startOnTick || !1 === e.endOnTick || this.logarithmic || this.chart[this.coll].forEach(function (h) {\n          var e = h.options;\n          e = [h.horiz ? e.left : e.top, e.width, e.height, e.pane].join();\n          h.series.length && (b[e] ? a = !0 : b[e] = 1);\n        });\n        return a;\n      };\n\n      e.prototype.getTickAmount = function () {\n        var b = this.options,\n            a = b.tickAmount,\n            e = b.tickPixelInterval;\n        !v(b.tickInterval) && !a && this.len < e && !this.isRadial && !this.logarithmic && b.startOnTick && b.endOnTick && (a = 2);\n        !a && this.alignToOthers() && (a = Math.ceil(this.len / e) + 1);\n        4 > a && (this.finalTickAmt = a, a = 5);\n        this.tickAmount = a;\n      };\n\n      e.prototype.adjustTickAmount = function () {\n        var b = this.options,\n            a = this.tickInterval,\n            e = this.tickPositions,\n            f = this.tickAmount,\n            d = this.finalTickAmt,\n            k = e && e.length,\n            c = u(this.threshold, this.softThreshold ? 0 : null),\n            l;\n\n        if (this.hasData()) {\n          if (k < f) {\n            for (l = this.min; e.length < f;) e.length % 2 || l === c ? e.push(L(e[e.length - 1] + a)) : e.unshift(L(e[0] - a));\n\n            this.transA *= (k - 1) / (f - 1);\n            this.min = b.startOnTick ? e[0] : Math.min(this.min, e[0]);\n            this.max = b.endOnTick ? e[e.length - 1] : Math.max(this.max, e[e.length - 1]);\n          } else k > f && (this.tickInterval *= 2, this.setTickPositions());\n\n          if (v(d)) {\n            for (a = b = e.length; a--;) (3 === d && 1 === a % 2 || 2 >= d && 0 < a && a < b - 1) && e.splice(a, 1);\n\n            this.finalTickAmt = void 0;\n          }\n        }\n      };\n\n      e.prototype.setScale = function () {\n        var b,\n            a = !1,\n            e = !1;\n        this.series.forEach(function (b) {\n          var h;\n          a = a || b.isDirtyData || b.isDirty;\n          e = e || (null === (h = b.xAxis) || void 0 === h ? void 0 : h.isDirty) || !1;\n        });\n        this.oldMin = this.min;\n        this.oldMax = this.max;\n        this.oldAxisLength = this.len;\n        this.setAxisSize();\n        (b = this.len !== this.oldAxisLength) || a || e || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax)) : this.stacking && this.stacking.cleanStacks();\n        a && this.panningState && (this.panningState.isDirty = !0);\n        C(this, \"afterSetScale\");\n      };\n\n      e.prototype.setExtremes = function (b, a, e, f, d) {\n        var h = this,\n            k = h.chart;\n        e = u(e, !0);\n        h.series.forEach(function (b) {\n          delete b.kdTree;\n        });\n        d = r(d, {\n          min: b,\n          max: a\n        });\n        C(h, \"setExtremes\", d, function () {\n          h.userMin = b;\n          h.userMax = a;\n          h.eventArgs = d;\n          e && k.redraw(f);\n        });\n      };\n\n      e.prototype.zoom = function (b, a) {\n        var e = this,\n            h = this.dataMin,\n            f = this.dataMax,\n            d = this.options,\n            k = Math.min(h, u(d.min, h)),\n            c = Math.max(f, u(d.max, f));\n        b = {\n          newMin: b,\n          newMax: a\n        };\n        C(this, \"zoom\", b, function (b) {\n          var a = b.newMin,\n              d = b.newMax;\n          if (a !== e.min || d !== e.max) e.allowZoomOutside || (v(h) && (a < k && (a = k), a > c && (a = c)), v(f) && (d < k && (d = k), d > c && (d = c))), e.displayBtn = \"undefined\" !== typeof a || \"undefined\" !== typeof d, e.setExtremes(a, d, !1, void 0, {\n            trigger: \"zoom\"\n          });\n          b.zoomed = !0;\n        });\n        return b.zoomed;\n      };\n\n      e.prototype.setAxisSize = function () {\n        var b = this.chart,\n            a = this.options,\n            e = a.offsets || [0, 0, 0, 0],\n            f = this.horiz,\n            d = this.width = Math.round(E(u(a.width, b.plotWidth - e[3] + e[1]), b.plotWidth)),\n            k = this.height = Math.round(E(u(a.height, b.plotHeight - e[0] + e[2]), b.plotHeight)),\n            c = this.top = Math.round(E(u(a.top, b.plotTop + e[0]), b.plotHeight, b.plotTop));\n        a = this.left = Math.round(E(u(a.left, b.plotLeft + e[3]), b.plotWidth, b.plotLeft));\n        this.bottom = b.chartHeight - k - c;\n        this.right = b.chartWidth - d - a;\n        this.len = Math.max(f ? d : k, 0);\n        this.pos = f ? a : c;\n      };\n\n      e.prototype.getExtremes = function () {\n        var b = this.logarithmic;\n        return {\n          min: b ? L(b.lin2log(this.min)) : this.min,\n          max: b ? L(b.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      };\n\n      e.prototype.getThreshold = function (b) {\n        var a = this.logarithmic,\n            e = a ? a.lin2log(this.min) : this.min;\n        a = a ? a.lin2log(this.max) : this.max;\n        null === b || -Infinity === b ? b = e : Infinity === b ? b = a : e > b ? b = e : a < b && (b = a);\n        return this.translate(b, 0, 1, 0, 1);\n      };\n\n      e.prototype.autoLabelAlign = function (b) {\n        var a = (u(b, 0) - 90 * this.side + 720) % 360;\n        b = {\n          align: \"center\"\n        };\n        C(this, \"autoLabelAlign\", b, function (b) {\n          15 < a && 165 > a ? b.align = \"right\" : 195 < a && 345 > a && (b.align = \"left\");\n        });\n        return b.align;\n      };\n\n      e.prototype.tickSize = function (b) {\n        var a = this.options,\n            e = a[\"tick\" === b ? \"tickLength\" : \"minorTickLength\"],\n            f = u(a[\"tick\" === b ? \"tickWidth\" : \"minorTickWidth\"], \"tick\" === b && this.isXAxis && !this.categories ? 1 : 0);\n\n        if (f && e) {\n          \"inside\" === a[b + \"Position\"] && (e = -e);\n          var d = [e, f];\n        }\n\n        b = {\n          tickSize: d\n        };\n        C(this, \"afterTickSize\", b);\n        return b.tickSize;\n      };\n\n      e.prototype.labelMetrics = function () {\n        var b = this.tickPositions && this.tickPositions[0] || 0;\n        return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[b] && this.ticks[b].label);\n      };\n\n      e.prototype.unsquish = function () {\n        var b = this.options.labels,\n            a = this.horiz,\n            e = this.tickInterval,\n            f = e,\n            d = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / e),\n            k,\n            c = b.rotation,\n            l = this.labelMetrics(),\n            m,\n            p = Number.MAX_VALUE,\n            A,\n            w = this.max - this.min,\n            n = function n(b) {\n          var a = b / (d || 1);\n          a = 1 < a ? Math.ceil(a) : 1;\n          a * e > w && Infinity !== b && Infinity !== d && w && (a = Math.ceil(w / e));\n          return L(a * e);\n        };\n\n        a ? (A = !b.staggerLines && !b.step && (v(c) ? [c] : d < u(b.autoRotationLimit, 80) && b.autoRotation)) && A.forEach(function (b) {\n          if (b === c || b && -90 <= b && 90 >= b) {\n            m = n(Math.abs(l.h / Math.sin(Q * b)));\n            var a = m + Math.abs(b / 360);\n            a < p && (p = a, k = b, f = m);\n          }\n        }) : b.step || (f = n(l.h));\n        this.autoRotation = A;\n        this.labelRotation = u(k, c);\n        return f;\n      };\n\n      e.prototype.getSlotWidth = function (b) {\n        var a,\n            e = this.chart,\n            f = this.horiz,\n            d = this.options.labels,\n            k = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            c = e.margin[3];\n        if (b && l(b.slotWidth)) return b.slotWidth;\n        if (f && d && 2 > (d.step || 0)) return d.rotation ? 0 : (this.staggerLines || 1) * this.len / k;\n\n        if (!f) {\n          b = null === (a = null === d || void 0 === d ? void 0 : d.style) || void 0 === a ? void 0 : a.width;\n          if (void 0 !== b) return parseInt(b, 10);\n          if (c) return c - e.spacing[3];\n        }\n\n        return .33 * e.chartWidth;\n      };\n\n      e.prototype.renderUnsquish = function () {\n        var b = this.chart,\n            a = b.renderer,\n            e = this.tickPositions,\n            f = this.ticks,\n            d = this.options.labels,\n            c = d && d.style || {},\n            l = this.horiz,\n            u = this.getSlotWidth(),\n            m = Math.max(1, Math.round(u - 2 * (d.padding || 5))),\n            p = {},\n            A = this.labelMetrics(),\n            w = d.style && d.style.textOverflow,\n            n = 0;\n        k(d.rotation) || (p.rotation = d.rotation || 0);\n        e.forEach(function (b) {\n          b = f[b];\n          b.movedLabel && b.replaceMovedLabel();\n          b && b.label && b.label.textPxLength > n && (n = b.label.textPxLength);\n        });\n        this.maxLabelLength = n;\n        if (this.autoRotation) n > m && n > A.h ? p.rotation = this.labelRotation : this.labelRotation = 0;else if (u) {\n          var g = m;\n\n          if (!w) {\n            var E = \"clip\";\n\n            for (m = e.length; !l && m--;) {\n              var r = e[m];\n              if (r = f[r].label) r.styles && \"ellipsis\" === r.styles.textOverflow ? r.css({\n                textOverflow: \"clip\"\n              }) : r.textPxLength > u && r.css({\n                width: u + \"px\"\n              }), r.getBBox().height > this.len / e.length - (A.h - A.f) && (r.specificTextOverflow = \"ellipsis\");\n            }\n          }\n        }\n        p.rotation && (g = n > .5 * b.chartHeight ? .33 * b.chartHeight : n, w || (E = \"ellipsis\"));\n        if (this.labelAlign = d.align || this.autoLabelAlign(this.labelRotation)) p.align = this.labelAlign;\n        e.forEach(function (b) {\n          var a = (b = f[b]) && b.label,\n              e = c.width,\n              h = {};\n          a && (a.attr(p), b.shortenLabel ? b.shortenLabel() : g && !e && \"nowrap\" !== c.whiteSpace && (g < a.textPxLength || \"SPAN\" === a.element.tagName) ? (h.width = g + \"px\", w || (h.textOverflow = a.specificTextOverflow || E), a.css(h)) : a.styles && a.styles.width && !h.width && !e && a.css({\n            width: null\n          }), delete a.specificTextOverflow, b.rotation = p.rotation);\n        }, this);\n        this.tickRotCorr = a.rotCorr(A.b, this.labelRotation || 0, 0 !== this.side);\n      };\n\n      e.prototype.hasData = function () {\n        return this.series.some(function (b) {\n          return b.hasData();\n        }) || this.options.showEmpty && v(this.min) && v(this.max);\n      };\n\n      e.prototype.addTitle = function (b) {\n        var a = this.chart.renderer,\n            e = this.horiz,\n            d = this.opposite,\n            k = this.options.title,\n            c,\n            l = this.chart.styledMode;\n        this.axisTitle || ((c = k.textAlign) || (c = (e ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: d ? \"right\" : \"left\",\n          middle: \"center\",\n          high: d ? \"left\" : \"right\"\n        })[k.align]), this.axisTitle = a.text(k.text, 0, 0, k.useHTML).attr({\n          zIndex: 7,\n          rotation: k.rotation || 0,\n          align: c\n        }).addClass(\"highcharts-axis-title\"), l || this.axisTitle.css(f(k.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);\n        l || k.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len + \"px\"\n        });\n        this.axisTitle[b ? \"show\" : \"hide\"](b);\n      };\n\n      e.prototype.generateTick = function (b) {\n        var a = this.ticks;\n        a[b] ? a[b].addLabel() : a[b] = new q(this, b);\n      };\n\n      e.prototype.getOffset = function () {\n        var b = this,\n            a = b.chart,\n            e = a.renderer,\n            f = b.options,\n            d = b.tickPositions,\n            k = b.ticks,\n            c = b.horiz,\n            l = b.side,\n            m = a.inverted && !b.isZAxis ? [1, 0, 3, 2][l] : l,\n            p,\n            w = 0,\n            n = 0,\n            g = f.title,\n            E = f.labels,\n            r = 0,\n            M = a.axisOffset;\n        a = a.clipOffset;\n        var F = [-1, 1, 1, -1][l],\n            t = f.className,\n            P = b.axisParent;\n        var I = b.hasData();\n        b.showAxis = p = I || u(f.showEmpty, !0);\n        b.staggerLines = b.horiz && E.staggerLines;\n        b.axisGroup || (b.gridGroup = e.g(\"grid\").attr({\n          zIndex: f.gridZIndex || 1\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \"-grid \" + (t || \"\")).add(P), b.axisGroup = e.g(\"axis\").attr({\n          zIndex: f.zIndex || 2\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \" \" + (t || \"\")).add(P), b.labelGroup = e.g(\"axis-labels\").attr({\n          zIndex: E.zIndex || 7\n        }).addClass(\"highcharts-\" + b.coll.toLowerCase() + \"-labels \" + (t || \"\")).add(P));\n        I || b.isLinked ? (d.forEach(function (a, e) {\n          b.generateTick(a, e);\n        }), b.renderUnsquish(), b.reserveSpaceDefault = 0 === l || 2 === l || {\n          1: \"left\",\n          3: \"right\"\n        }[l] === b.labelAlign, u(E.reserveSpace, \"center\" === b.labelAlign ? !0 : null, b.reserveSpaceDefault) && d.forEach(function (b) {\n          r = Math.max(k[b].getLabelSize(), r);\n        }), b.staggerLines && (r *= b.staggerLines), b.labelOffset = r * (b.opposite ? -1 : 1)) : A(k, function (b, a) {\n          b.destroy();\n          delete k[a];\n        });\n\n        if (g && g.text && !1 !== g.enabled && (b.addTitle(p), p && !1 !== g.reserveSpace)) {\n          b.titleOffset = w = b.axisTitle.getBBox()[c ? \"height\" : \"width\"];\n          var q = g.offset;\n          n = v(q) ? 0 : u(g.margin, c ? 5 : 10);\n        }\n\n        b.renderLine();\n        b.offset = F * u(f.offset, M[l] ? M[l] + (f.margin || 0) : 0);\n        b.tickRotCorr = b.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        e = 0 === l ? -b.labelMetrics().h : 2 === l ? b.tickRotCorr.y : 0;\n        n = Math.abs(r) + n;\n        r && (n = n - e + F * (c ? u(E.y, b.tickRotCorr.y + 8 * F) : E.x));\n        b.axisTitleMargin = u(q, n);\n        b.getMaxLabelDimensions && (b.maxLabelDimensions = b.getMaxLabelDimensions(k, d));\n        c = this.tickSize(\"tick\");\n        M[l] = Math.max(M[l], b.axisTitleMargin + w + F * b.offset, n, d && d.length && c ? c[0] + F * b.offset : 0);\n        f = f.offset ? 0 : 2 * Math.floor(b.axisLine.strokeWidth() / 2);\n        a[m] = Math.max(a[m], f);\n        C(this, \"afterGetOffset\");\n      };\n\n      e.prototype.getLinePath = function (b) {\n        var a = this.chart,\n            e = this.opposite,\n            f = this.offset,\n            d = this.horiz,\n            k = this.left + (e ? this.width : 0) + f;\n        f = a.chartHeight - this.bottom - (e ? this.height : 0) + f;\n        e && (b *= -1);\n        return a.renderer.crispLine([[\"M\", d ? this.left : k, d ? f : this.top], [\"L\", d ? a.chartWidth - this.right : k, d ? f : a.chartHeight - this.bottom]], b);\n      };\n\n      e.prototype.renderLine = function () {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      };\n\n      e.prototype.getTitlePosition = function () {\n        var b = this.horiz,\n            a = this.left,\n            e = this.top,\n            f = this.len,\n            d = this.options.title,\n            k = b ? a : e,\n            c = this.opposite,\n            l = this.offset,\n            u = d.x || 0,\n            m = d.y || 0,\n            p = this.axisTitle,\n            A = this.chart.renderer.fontMetrics(d.style && d.style.fontSize, p);\n        p = Math.max(p.getBBox(null, 0).height - A.h - 1, 0);\n        f = {\n          low: k + (b ? 0 : f),\n          middle: k + f / 2,\n          high: k + (b ? f : 0)\n        }[d.align];\n        a = (b ? e + this.height : a) + (b ? 1 : -1) * (c ? -1 : 1) * this.axisTitleMargin + [-p, p, A.f, -p][this.side];\n        b = {\n          x: b ? f + u : a + (c ? this.width : 0) + l + u,\n          y: b ? a + m - (c ? this.height : 0) + l : f + m\n        };\n        C(this, \"afterGetTitlePosition\", {\n          titlePosition: b\n        });\n        return b;\n      };\n\n      e.prototype.renderMinorTick = function (b) {\n        var a = this.chart.hasRendered && l(this.oldMin),\n            e = this.minorTicks;\n        e[b] || (e[b] = new q(this, b, \"minor\"));\n        a && e[b].isNew && e[b].render(null, !0);\n        e[b].render(null, !1, 1);\n      };\n\n      e.prototype.renderTick = function (b, a) {\n        var e = this.isLinked,\n            h = this.ticks,\n            f = this.chart.hasRendered && l(this.oldMin);\n        if (!e || b >= this.min && b <= this.max) h[b] || (h[b] = new q(this, b)), f && h[b].isNew && h[b].render(a, !0, -1), h[b].render(a);\n      };\n\n      e.prototype.render = function () {\n        var b = this,\n            a = b.chart,\n            e = b.logarithmic,\n            f = b.options,\n            d = b.isLinked,\n            k = b.tickPositions,\n            u = b.axisTitle,\n            m = b.ticks,\n            p = b.minorTicks,\n            w = b.alternateBands,\n            n = f.stackLabels,\n            g = f.alternateGridColor,\n            E = b.tickmarkOffset,\n            r = b.axisLine,\n            F = b.showAxis,\n            t = D(a.renderer.globalAnimation),\n            v,\n            P;\n        b.labelEdge.length = 0;\n        b.overlap = !1;\n        [m, p, w].forEach(function (b) {\n          A(b, function (b) {\n            b.isActive = !1;\n          });\n        });\n        if (b.hasData() || d) b.minorTickInterval && !b.categories && b.getMinorTickPositions().forEach(function (a) {\n          b.renderMinorTick(a);\n        }), k.length && (k.forEach(function (a, e) {\n          b.renderTick(a, e);\n        }), E && (0 === b.min || b.single) && (m[-1] || (m[-1] = new q(b, -1, null, !0)), m[-1].render(-1))), g && k.forEach(function (h, f) {\n          P = \"undefined\" !== typeof k[f + 1] ? k[f + 1] + E : b.max - E;\n          0 === f % 2 && h < b.max && P <= b.max + (a.polar ? -E : E) && (w[h] || (w[h] = new c.PlotLineOrBand(b)), v = h + E, w[h].options = {\n            from: e ? e.lin2log(v) : v,\n            to: e ? e.lin2log(P) : P,\n            color: g,\n            className: \"highcharts-alternate-grid\"\n          }, w[h].render(), w[h].isActive = !0);\n        }), b._addedPlotLB || ((f.plotLines || []).concat(f.plotBands || []).forEach(function (a) {\n          b.addPlotBandOrLine(a);\n        }), b._addedPlotLB = !0);\n        [m, p, w].forEach(function (b) {\n          var e,\n              h = [],\n              f = t.duration;\n          A(b, function (b, a) {\n            b.isActive || (b.render(a, !1, 0), b.isActive = !1, h.push(a));\n          });\n          M(function () {\n            for (e = h.length; e--;) b[h[e]] && !b[h[e]].isActive && (b[h[e]].destroy(), delete b[h[e]]);\n          }, b !== w && a.hasRendered && f ? f : 0);\n        });\n        r && (r[r.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(r.strokeWidth())\n        }), r.isPlaced = !0, r[F ? \"show\" : \"hide\"](F));\n        u && F && (f = b.getTitlePosition(), l(f.y) ? (u[u.isNew ? \"attr\" : \"animate\"](f), u.isNew = !1) : (u.attr(\"y\", -9999), u.isNew = !0));\n        n && n.enabled && b.stacking && b.stacking.renderStackTotals();\n        b.isDirty = !1;\n        C(this, \"afterRender\");\n      };\n\n      e.prototype.redraw = function () {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (b) {\n          b.render();\n        }));\n        this.series.forEach(function (b) {\n          b.isDirty = !0;\n        });\n      };\n\n      e.prototype.getKeepProps = function () {\n        return this.keepProps || e.keepProps;\n      };\n\n      e.prototype.destroy = function (b) {\n        var a = this,\n            e = a.plotLinesAndBands,\n            f;\n        C(this, \"destroy\", {\n          keepEvents: b\n        });\n        b || P(a);\n        [a.ticks, a.minorTicks, a.alternateBands].forEach(function (b) {\n          K(b);\n        });\n        if (e) for (b = e.length; b--;) e[b].destroy();\n        \"axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \").forEach(function (b) {\n          a[b] && (a[b] = a[b].destroy());\n        });\n\n        for (f in a.plotLinesAndBandsGroups) a.plotLinesAndBandsGroups[f] = a.plotLinesAndBandsGroups[f].destroy();\n\n        A(a, function (b, e) {\n          -1 === a.getKeepProps().indexOf(e) && delete a[e];\n        });\n      };\n\n      e.prototype.drawCrosshair = function (b, a) {\n        var e = this.crosshair,\n            h = u(e.snap, !0),\n            f,\n            d = this.cross,\n            k = this.chart;\n        C(this, \"drawCrosshair\", {\n          e: b,\n          point: a\n        });\n        b || (b = this.cross && this.cross.e);\n\n        if (this.crosshair && !1 !== (v(a) || !h)) {\n          h ? v(a) && (f = u(\"colorAxis\" !== this.coll ? a.crosshairPos : null, this.isXAxis ? a.plotX : this.len - a.plotY)) : f = b && (this.horiz ? b.chartX - this.pos : this.len - b.chartY + this.pos);\n\n          if (v(f)) {\n            var c = {\n              value: a && (this.isXAxis ? a.x : u(a.stackY, a.y)),\n              translatedValue: f\n            };\n            k.polar && r(c, {\n              isCrosshair: !0,\n              chartX: b && b.chartX,\n              chartY: b && b.chartY,\n              point: a\n            });\n            c = this.getPlotLinePath(c) || null;\n          }\n\n          if (!v(c)) {\n            this.hideCrosshair();\n            return;\n          }\n\n          h = this.categories && !this.isRadial;\n          d || (this.cross = d = k.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (h ? \"category \" : \"thin \") + e.className).attr({\n            zIndex: u(e.zIndex, 2)\n          }).add(), k.styledMode || (d.attr({\n            stroke: e.color || (h ? g.parse(\"#ccd6eb\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": u(e.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), e.dashStyle && d.attr({\n            dashstyle: e.dashStyle\n          })));\n          d.show().attr({\n            d: c\n          });\n          h && !e.width && d.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = b;\n        } else this.hideCrosshair();\n\n        C(this, \"afterDrawCrosshair\", {\n          e: b,\n          point: a\n        });\n      };\n\n      e.prototype.hideCrosshair = function () {\n        this.cross && this.cross.hide();\n        C(this, \"afterHideCrosshair\");\n      };\n\n      e.prototype.hasVerticalPanning = function () {\n        var b, a;\n        return /y/.test((null === (a = null === (b = this.chart.options.chart) || void 0 === b ? void 0 : b.panning) || void 0 === a ? void 0 : a.type) || \"\");\n      };\n\n      e.defaultOptions = {\n        dateTimeLabelFormats: {\n          millisecond: {\n            main: \"%H:%M:%S.%L\",\n            range: !1\n          },\n          second: {\n            main: \"%H:%M:%S\",\n            range: !1\n          },\n          minute: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          hour: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          day: {\n            main: \"%e. %b\"\n          },\n          week: {\n            main: \"%e. %b\"\n          },\n          month: {\n            main: \"%b '%y\"\n          },\n          year: {\n            main: \"%Y\"\n          }\n        },\n        endOnTick: !1,\n        labels: {\n          enabled: !0,\n          indentation: 10,\n          x: 0,\n          style: {\n            color: \"#666666\",\n            cursor: \"default\",\n            fontSize: \"11px\"\n          }\n        },\n        maxPadding: .01,\n        minorTickLength: 2,\n        minorTickPosition: \"outside\",\n        minPadding: .01,\n        showEmpty: !0,\n        startOfWeek: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickPixelInterval: 100,\n        tickmarkPlacement: \"between\",\n        tickPosition: \"outside\",\n        title: {\n          align: \"middle\",\n          style: {\n            color: \"#666666\"\n          }\n        },\n        type: \"linear\",\n        minorGridLineColor: \"#f2f2f2\",\n        minorGridLineWidth: 1,\n        minorTickColor: \"#999999\",\n        lineColor: \"#ccd6eb\",\n        lineWidth: 1,\n        gridLineColor: \"#e6e6e6\",\n        tickColor: \"#ccd6eb\"\n      };\n      e.defaultYAxisOptions = {\n        endOnTick: !0,\n        maxPadding: .05,\n        minPadding: .05,\n        tickPixelInterval: 72,\n        showLastLabel: !0,\n        labels: {\n          x: -8\n        },\n        startOnTick: !0,\n        title: {\n          rotation: 270,\n          text: \"Values\"\n        },\n        stackLabels: {\n          allowOverlap: !1,\n          enabled: !1,\n          crop: !0,\n          overflow: \"justify\",\n          formatter: function formatter() {\n            var b = this.axis.chart.numberFormatter;\n            return b(this.total, -1);\n          },\n          style: {\n            color: \"#000000\",\n            fontSize: \"11px\",\n            fontWeight: \"bold\",\n            textOutline: \"1px contrast\"\n          }\n        },\n        gridLineWidth: 1,\n        lineWidth: 0\n      };\n      e.defaultLeftAxisOptions = {\n        labels: {\n          x: -15\n        },\n        title: {\n          rotation: 270\n        }\n      };\n      e.defaultRightAxisOptions = {\n        labels: {\n          x: 15\n        },\n        title: {\n          rotation: 90\n        }\n      };\n      e.defaultBottomAxisOptions = {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      };\n      e.defaultTopAxisOptions = {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      };\n      e.keepProps = \"extKey hcEvents names series userMax userMin\".split(\" \");\n      return e;\n    }();\n\n    c.Axis = y;\n    return c.Axis;\n  });\n  O(q, \"parts/DateTimeAxis.js\", [q[\"parts/Axis.js\"], q[\"parts/Utilities.js\"]], function (g, c) {\n    var q = c.addEvent,\n        y = c.getMagnitude,\n        B = c.normalizeTickInterval,\n        H = c.timeUnits,\n        D = function () {\n      function c(c) {\n        this.axis = c;\n      }\n\n      c.prototype.normalizeTimeTickInterval = function (c, g) {\n        var t = g || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n        g = t[t.length - 1];\n        var v = H[g[0]],\n            q = g[1],\n            n;\n\n        for (n = 0; n < t.length && !(g = t[n], v = H[g[0]], q = g[1], t[n + 1] && c <= (v * q[q.length - 1] + H[t[n + 1][0]]) / 2); n++);\n\n        v === H.year && c < 5 * v && (q = [1, 2, 5]);\n        c = B(c / v, q, \"year\" === g[0] ? Math.max(y(c / v), 1) : 1);\n        return {\n          unitRange: v,\n          count: c,\n          unitName: g[0]\n        };\n      };\n\n      return c;\n    }();\n\n    c = function () {\n      function c() {}\n\n      c.compose = function (c) {\n        c.keepProps.push(\"dateTime\");\n\n        c.prototype.getTimeTicks = function () {\n          return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n        };\n\n        q(c, \"init\", function (c) {\n          \"datetime\" !== c.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new D(this));\n        });\n      };\n\n      c.AdditionsClass = D;\n      return c;\n    }();\n\n    c.compose(g);\n    return c;\n  });\n  O(q, \"parts/LogarithmicAxis.js\", [q[\"parts/Axis.js\"], q[\"parts/Utilities.js\"]], function (g, c) {\n    var q = c.addEvent,\n        y = c.getMagnitude,\n        B = c.normalizeTickInterval,\n        H = c.pick,\n        D = function () {\n      function c(c) {\n        this.axis = c;\n      }\n\n      c.prototype.getLogTickPositions = function (c, g, q, v) {\n        var t = this.axis,\n            n = t.len,\n            r = t.options,\n            C = [];\n        v || (this.minorAutoInterval = void 0);\n        if (.5 <= c) c = Math.round(c), C = t.getLinearTickPositions(c, g, q);else if (.08 <= c) {\n          r = Math.floor(g);\n          var I, p;\n\n          for (n = .3 < c ? [1, 2, 4] : .15 < c ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; r < q + 1 && !p; r++) {\n            var m = n.length;\n\n            for (I = 0; I < m && !p; I++) {\n              var d = this.log2lin(this.lin2log(r) * n[I]);\n              d > g && (!v || l <= q) && \"undefined\" !== typeof l && C.push(l);\n              l > q && (p = !0);\n              var l = d;\n            }\n          }\n        } else g = this.lin2log(g), q = this.lin2log(q), c = v ? t.getMinorTickInterval() : r.tickInterval, c = H(\"auto\" === c ? null : c, this.minorAutoInterval, r.tickPixelInterval / (v ? 5 : 1) * (q - g) / ((v ? n / t.tickPositions.length : n) || 1)), c = B(c, void 0, y(c)), C = t.getLinearTickPositions(c, g, q).map(this.log2lin), v || (this.minorAutoInterval = c / 5);\n        v || (t.tickInterval = c);\n        return C;\n      };\n\n      c.prototype.lin2log = function (c) {\n        return Math.pow(10, c);\n      };\n\n      c.prototype.log2lin = function (c) {\n        return Math.log(c) / Math.LN10;\n      };\n\n      return c;\n    }();\n\n    c = function () {\n      function c() {}\n\n      c.compose = function (c) {\n        c.keepProps.push(\"logarithmic\");\n        var g = c.prototype,\n            t = D.prototype;\n        g.log2lin = t.log2lin;\n        g.lin2log = t.lin2log;\n        q(c, \"init\", function (c) {\n          var g = this.logarithmic;\n          \"logarithmic\" !== c.userOptions.type ? this.logarithmic = void 0 : (g || (g = this.logarithmic = new D(this)), this.log2lin !== g.log2lin && (g.log2lin = this.log2lin.bind(this)), this.lin2log !== g.lin2log && (g.lin2log = this.lin2log.bind(this)));\n        });\n        q(c, \"afterInit\", function () {\n          var c = this.logarithmic;\n          c && (this.lin2val = function (g) {\n            return c.lin2log(g);\n          }, this.val2lin = function (g) {\n            return c.log2lin(g);\n          });\n        });\n      };\n\n      return c;\n    }();\n\n    c.compose(g);\n    return c;\n  });\n  O(q, \"parts/PlotLineOrBand.js\", [q[\"parts/Axis.js\"], q[\"parts/Globals.js\"], q[\"parts/Utilities.js\"]], function (g, c, q) {\n    var y = q.arrayMax,\n        B = q.arrayMin,\n        H = q.defined,\n        D = q.destroyObjectProperties,\n        J = q.erase,\n        t = q.extend,\n        G = q.merge,\n        L = q.objectEach,\n        v = q.pick,\n        K = function () {\n      function n(c, n) {\n        this.axis = c;\n        n && (this.options = n, this.id = n.id);\n      }\n\n      n.prototype.render = function () {\n        c.fireEvent(this, \"render\");\n        var n = this,\n            g = n.axis,\n            t = g.horiz,\n            p = g.logarithmic,\n            m = n.options,\n            d = m.label,\n            l = n.label,\n            k = m.to,\n            f = m.from,\n            a = m.value,\n            A = H(f) && H(k),\n            u = H(a),\n            E = n.svgElem,\n            P = !E,\n            w = [],\n            M = m.color,\n            F = v(m.zIndex, 0),\n            q = m.events;\n        w = {\n          \"class\": \"highcharts-plot-\" + (A ? \"band \" : \"line \") + (m.className || \"\")\n        };\n        var e = {},\n            b = g.chart.renderer,\n            h = A ? \"bands\" : \"lines\";\n        p && (f = p.log2lin(f), k = p.log2lin(k), a = p.log2lin(a));\n        g.chart.styledMode || (u ? (w.stroke = M || \"#999999\", w[\"stroke-width\"] = v(m.width, 1), m.dashStyle && (w.dashstyle = m.dashStyle)) : A && (w.fill = M || \"#e6ebf5\", m.borderWidth && (w.stroke = m.borderColor, w[\"stroke-width\"] = m.borderWidth)));\n        e.zIndex = F;\n        h += \"-\" + F;\n        (p = g.plotLinesAndBandsGroups[h]) || (g.plotLinesAndBandsGroups[h] = p = b.g(\"plot-\" + h).attr(e).add());\n        P && (n.svgElem = E = b.path().attr(w).add(p));\n        if (u) w = g.getPlotLinePath({\n          value: a,\n          lineWidth: E.strokeWidth(),\n          acrossPanes: m.acrossPanes\n        });else if (A) w = g.getPlotBandPath(f, k, m);else return;\n        !n.eventsAdded && q && (L(q, function (b, a) {\n          E.on(a, function (b) {\n            q[a].apply(n, [b]);\n          });\n        }), n.eventsAdded = !0);\n        (P || !E.d) && w && w.length ? E.attr({\n          d: w\n        }) : E && (w ? (E.show(!0), E.animate({\n          d: w\n        })) : E.d && (E.hide(), l && (n.label = l = l.destroy())));\n        d && (H(d.text) || H(d.formatter)) && w && w.length && 0 < g.width && 0 < g.height && !w.isFlat ? (d = G({\n          align: t && A && \"center\",\n          x: t ? !A && 4 : 10,\n          verticalAlign: !t && A && \"middle\",\n          y: t ? A ? 16 : 10 : A ? 6 : -4,\n          rotation: t && !A && 90\n        }, d), this.renderLabel(d, w, A, F)) : l && l.hide();\n        return n;\n      };\n\n      n.prototype.renderLabel = function (c, n, g, p) {\n        var m = this.label,\n            d = this.axis.chart.renderer;\n        m || (m = {\n          align: c.textAlign || c.align,\n          rotation: c.rotation,\n          \"class\": \"highcharts-plot-\" + (g ? \"band\" : \"line\") + \"-label \" + (c.className || \"\")\n        }, m.zIndex = p, p = this.getLabelText(c), this.label = m = d.text(p, 0, 0, c.useHTML).attr(m).add(), this.axis.chart.styledMode || m.css(c.style));\n        d = n.xBounds || [n[0][1], n[1][1], g ? n[2][1] : n[0][1]];\n        n = n.yBounds || [n[0][2], n[1][2], g ? n[2][2] : n[0][2]];\n        g = B(d);\n        p = B(n);\n        m.align(c, !1, {\n          x: g,\n          y: p,\n          width: y(d) - g,\n          height: y(n) - p\n        });\n        m.show(!0);\n      };\n\n      n.prototype.getLabelText = function (c) {\n        return H(c.formatter) ? c.formatter.call(this) : c.text;\n      };\n\n      n.prototype.destroy = function () {\n        J(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        D(this);\n      };\n\n      return n;\n    }();\n\n    t(g.prototype, {\n      getPlotBandPath: function getPlotBandPath(c, g) {\n        var n = this.getPlotLinePath({\n          value: g,\n          force: !0,\n          acrossPanes: this.options.acrossPanes\n        }),\n            r = this.getPlotLinePath({\n          value: c,\n          force: !0,\n          acrossPanes: this.options.acrossPanes\n        }),\n            p = [],\n            m = this.horiz,\n            d = 1;\n        c = c < this.min && g < this.min || c > this.max && g > this.max;\n\n        if (r && n) {\n          if (c) {\n            var l = r.toString() === n.toString();\n            d = 0;\n          }\n\n          for (c = 0; c < r.length; c += 2) {\n            g = r[c];\n            var k = r[c + 1],\n                f = n[c],\n                a = n[c + 1];\n            \"M\" !== g[0] && \"L\" !== g[0] || \"M\" !== k[0] && \"L\" !== k[0] || \"M\" !== f[0] && \"L\" !== f[0] || \"M\" !== a[0] && \"L\" !== a[0] || (m && f[1] === g[1] ? (f[1] += d, a[1] += d) : m || f[2] !== g[2] || (f[2] += d, a[2] += d), p.push([\"M\", g[1], g[2]], [\"L\", k[1], k[2]], [\"L\", a[1], a[2]], [\"L\", f[1], f[2]], [\"Z\"]));\n            p.isFlat = l;\n          }\n        }\n\n        return p;\n      },\n      addPlotBand: function addPlotBand(c) {\n        return this.addPlotBandOrLine(c, \"plotBands\");\n      },\n      addPlotLine: function addPlotLine(c) {\n        return this.addPlotBandOrLine(c, \"plotLines\");\n      },\n      addPlotBandOrLine: function addPlotBandOrLine(c, g) {\n        var n = new K(this, c).render(),\n            r = this.userOptions;\n\n        if (n) {\n          if (g) {\n            var p = r[g] || [];\n            p.push(c);\n            r[g] = p;\n          }\n\n          this.plotLinesAndBands.push(n);\n          this._addedPlotLB = !0;\n        }\n\n        return n;\n      },\n      removePlotBandOrLine: function removePlotBandOrLine(c) {\n        for (var n = this.plotLinesAndBands, g = this.options, t = this.userOptions, p = n.length; p--;) n[p].id === c && n[p].destroy();\n\n        [g.plotLines || [], t.plotLines || [], g.plotBands || [], t.plotBands || []].forEach(function (m) {\n          for (p = m.length; p--;) (m[p] || {}).id === c && J(m, m[p]);\n        });\n      },\n      removePlotBand: function removePlotBand(c) {\n        this.removePlotBandOrLine(c);\n      },\n      removePlotLine: function removePlotLine(c) {\n        this.removePlotBandOrLine(c);\n      }\n    });\n    c.PlotLineOrBand = K;\n    return c.PlotLineOrBand;\n  });\n  O(q, \"parts/Tooltip.js\", [q[\"parts/Globals.js\"], q[\"parts/Utilities.js\"]], function (g, c) {\n    var q = g.doc,\n        y = c.clamp,\n        B = c.css,\n        H = c.defined,\n        D = c.discardElement,\n        J = c.extend,\n        t = c.fireEvent,\n        G = c.format,\n        L = c.isNumber,\n        v = c.isString,\n        K = c.merge,\n        n = c.pick,\n        r = c.splat,\n        C = c.syncTimeout,\n        I = c.timeUnits;\n    \"\";\n\n    var p = function () {\n      function m(d, c) {\n        this.container = void 0;\n        this.crosshairs = [];\n        this.distance = 0;\n        this.isHidden = !0;\n        this.isSticky = !1;\n        this.now = {};\n        this.options = {};\n        this.outside = !1;\n        this.chart = d;\n        this.init(d, c);\n      }\n\n      m.prototype.applyFilter = function () {\n        var d = this.chart;\n        d.renderer.definition({\n          tagName: \"filter\",\n          id: \"drop-shadow-\" + d.index,\n          opacity: .5,\n          children: [{\n            tagName: \"feGaussianBlur\",\n            \"in\": \"SourceAlpha\",\n            stdDeviation: 1\n          }, {\n            tagName: \"feOffset\",\n            dx: 1,\n            dy: 1\n          }, {\n            tagName: \"feComponentTransfer\",\n            children: [{\n              tagName: \"feFuncA\",\n              type: \"linear\",\n              slope: .3\n            }]\n          }, {\n            tagName: \"feMerge\",\n            children: [{\n              tagName: \"feMergeNode\"\n            }, {\n              tagName: \"feMergeNode\",\n              \"in\": \"SourceGraphic\"\n            }]\n          }]\n        });\n        d.renderer.definition({\n          tagName: \"style\",\n          textContent: \".highcharts-tooltip-\" + d.index + \"{filter:url(#drop-shadow-\" + d.index + \")}\"\n        });\n      };\n\n      m.prototype.bodyFormatter = function (d) {\n        return d.map(function (d) {\n          var k = d.series.tooltipOptions;\n          return (k[(d.point.formatPrefix || \"point\") + \"Formatter\"] || d.point.tooltipFormatter).call(d.point, k[(d.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n        });\n      };\n\n      m.prototype.cleanSplit = function (d) {\n        this.chart.series.forEach(function (c) {\n          var k = c && c.tt;\n          k && (!k.isActive || d ? c.tt = k.destroy() : k.isActive = !1);\n        });\n      };\n\n      m.prototype.defaultFormatter = function (d) {\n        var c = this.points || r(this);\n        var k = [d.tooltipFooterHeaderFormatter(c[0])];\n        k = k.concat(d.bodyFormatter(c));\n        k.push(d.tooltipFooterHeaderFormatter(c[0], !0));\n        return k;\n      };\n\n      m.prototype.destroy = function () {\n        this.label && (this.label = this.label.destroy());\n        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());\n        this.renderer && (this.renderer = this.renderer.destroy(), D(this.container));\n        c.clearTimeout(this.hideTimer);\n        c.clearTimeout(this.tooltipTimeout);\n      };\n\n      m.prototype.getAnchor = function (d, c) {\n        var k = this.chart,\n            f = k.pointer,\n            a = k.inverted,\n            l = k.plotTop,\n            u = k.plotLeft,\n            m = 0,\n            p = 0,\n            w,\n            n;\n        d = r(d);\n        this.followPointer && c ? (\"undefined\" === typeof c.chartX && (c = f.normalize(c)), d = [c.chartX - u, c.chartY - l]) : d[0].tooltipPos ? d = d[0].tooltipPos : (d.forEach(function (f) {\n          w = f.series.yAxis;\n          n = f.series.xAxis;\n          m += f.plotX + (!a && n ? n.left - u : 0);\n          p += (f.plotLow ? (f.plotLow + f.plotHigh) / 2 : f.plotY) + (!a && w ? w.top - l : 0);\n        }), m /= d.length, p /= d.length, d = [a ? k.plotWidth - p : m, this.shared && !a && 1 < d.length && c ? c.chartY - l : a ? k.plotHeight - m : p]);\n        return d.map(Math.round);\n      };\n\n      m.prototype.getDateFormat = function (d, c, k, f) {\n        var a = this.chart.time,\n            l = a.dateFormat(\"%m-%d %H:%M:%S.%L\", c),\n            u = {\n          millisecond: 15,\n          second: 12,\n          minute: 9,\n          hour: 6,\n          day: 3\n        },\n            m = \"millisecond\";\n\n        for (p in I) {\n          if (d === I.week && +a.dateFormat(\"%w\", c) === k && \"00:00:00.000\" === l.substr(6)) {\n            var p = \"week\";\n            break;\n          }\n\n          if (I[p] > d) {\n            p = m;\n            break;\n          }\n\n          if (u[p] && l.substr(u[p]) !== \"01-01 00:00:00.000\".substr(u[p])) break;\n          \"week\" !== p && (m = p);\n        }\n\n        if (p) var w = a.resolveDTLFormat(f[p]).main;\n        return w;\n      };\n\n      m.prototype.getLabel = function () {\n        var d,\n            c,\n            k = this,\n            f = this.chart.renderer,\n            a = this.chart.styledMode,\n            m = this.options,\n            u = \"tooltip\" + (H(m.className) ? \" \" + m.className : \"\"),\n            p = (null === (d = m.style) || void 0 === d ? void 0 : d.pointerEvents) || (!this.followPointer && m.stickOnContact ? \"auto\" : \"none\"),\n            n;\n\n        d = function d() {\n          k.inContact = !0;\n        };\n\n        var w = function w() {\n          var a = k.chart.hoverSeries;\n          k.inContact = !1;\n          if (a && a.onMouseOut) a.onMouseOut();\n        };\n\n        if (!this.label) {\n          this.outside && (this.container = n = g.doc.createElement(\"div\"), n.className = \"highcharts-tooltip-container\", B(n, {\n            position: \"absolute\",\n            top: \"1px\",\n            pointerEvents: p,\n            zIndex: 3\n          }), g.doc.body.appendChild(n), this.renderer = f = new g.Renderer(n, 0, 0, null === (c = this.chart.options.chart) || void 0 === c ? void 0 : c.style, void 0, void 0, f.styledMode));\n          this.split ? this.label = f.g(u) : (this.label = f.label(\"\", 0, 0, m.shape || \"callout\", null, null, m.useHTML, null, u).attr({\n            padding: m.padding,\n            r: m.borderRadius\n          }), a || this.label.attr({\n            fill: m.backgroundColor,\n            \"stroke-width\": m.borderWidth\n          }).css(m.style).css({\n            pointerEvents: p\n          }).shadow(m.shadow));\n          a && (this.applyFilter(), this.label.addClass(\"highcharts-tooltip-\" + this.chart.index));\n\n          if (k.outside && !k.split) {\n            var r = this.label,\n                F = r.xSetter,\n                t = r.ySetter;\n\n            r.xSetter = function (a) {\n              F.call(r, k.distance);\n              n.style.left = a + \"px\";\n            };\n\n            r.ySetter = function (a) {\n              t.call(r, k.distance);\n              n.style.top = a + \"px\";\n            };\n          }\n\n          this.label.on(\"mouseenter\", d).on(\"mouseleave\", w).attr({\n            zIndex: 8\n          }).add();\n        }\n\n        return this.label;\n      };\n\n      m.prototype.getPosition = function (d, c, k) {\n        var f = this.chart,\n            a = this.distance,\n            l = {},\n            m = f.inverted && k.h || 0,\n            p,\n            g = this.outside,\n            w = g ? q.documentElement.clientWidth - 2 * a : f.chartWidth,\n            r = g ? Math.max(q.body.scrollHeight, q.documentElement.scrollHeight, q.body.offsetHeight, q.documentElement.offsetHeight, q.documentElement.clientHeight) : f.chartHeight,\n            F = f.pointer.getChartPosition(),\n            t = f.containerScaling,\n            e = function e(b) {\n          return t ? b * t.scaleX : b;\n        },\n            b = function b(_b) {\n          return t ? _b * t.scaleY : _b;\n        },\n            h = function h(_h) {\n          var l = \"x\" === _h;\n          return [_h, l ? w : r, l ? d : c].concat(g ? [l ? e(d) : b(c), l ? F.left - a + e(k.plotX + f.plotLeft) : F.top - a + b(k.plotY + f.plotTop), 0, l ? w : r] : [l ? d : c, l ? k.plotX + f.plotLeft : k.plotY + f.plotTop, l ? f.plotLeft : f.plotTop, l ? f.plotLeft + f.plotWidth : f.plotTop + f.plotHeight]);\n        },\n            z = h(\"y\"),\n            x = h(\"x\"),\n            C = !this.followPointer && n(k.ttBelow, !f.inverted === !!k.negative),\n            v = function v(h, f, d, c, k, u, p) {\n          var x = \"y\" === h ? b(a) : e(a),\n              w = (d - c) / 2,\n              n = c < k - a,\n              A = k + a + c < f,\n              g = k - x - d + w;\n          k = k + x - w;\n          if (C && A) l[h] = k;else if (!C && n) l[h] = g;else if (n) l[h] = Math.min(p - c, 0 > g - m ? g : g - m);else if (A) l[h] = Math.max(u, k + m + d > f ? k : k + m);else return !1;\n        },\n            I = function I(b, e, h, f, d) {\n          var c;\n          d < a || d > e - a ? c = !1 : l[b] = d < h / 2 ? 1 : d > e - f / 2 ? e - f - 2 : d - h / 2;\n          return c;\n        },\n            V = function V(b) {\n          var a = z;\n          z = x;\n          x = a;\n          p = b;\n        },\n            G = function G() {\n          !1 !== v.apply(0, z) ? !1 !== I.apply(0, x) || p || (V(!0), G()) : p ? l.x = l.y = 0 : (V(!0), G());\n        };\n\n        (f.inverted || 1 < this.len) && V();\n        G();\n        return l;\n      };\n\n      m.prototype.getXDateFormat = function (d, c, k) {\n        c = c.dateTimeLabelFormats;\n        var f = k && k.closestPointRange;\n        return (f ? this.getDateFormat(f, d.x, k.options.startOfWeek, c) : c.day) || c.year;\n      };\n\n      m.prototype.hide = function (d) {\n        var l = this;\n        c.clearTimeout(this.hideTimer);\n        d = n(d, this.options.hideDelay, 500);\n        this.isHidden || (this.hideTimer = C(function () {\n          l.getLabel().fadeOut(d ? void 0 : d);\n          l.isHidden = !0;\n        }, d));\n      };\n\n      m.prototype.init = function (d, c) {\n        this.chart = d;\n        this.options = c;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = c.split && !d.inverted && !d.polar;\n        this.shared = c.shared || this.split;\n        this.outside = n(c.outside, !(!d.scrollablePixelsX && !d.scrollablePixelsY));\n      };\n\n      m.prototype.isStickyOnContact = function () {\n        return !(this.followPointer || !this.options.stickOnContact || !this.inContact);\n      };\n\n      m.prototype.move = function (d, l, k, f) {\n        var a = this,\n            m = a.now,\n            u = !1 !== a.options.animation && !a.isHidden && (1 < Math.abs(d - m.x) || 1 < Math.abs(l - m.y)),\n            p = a.followPointer || 1 < a.len;\n        J(m, {\n          x: u ? (2 * m.x + d) / 3 : d,\n          y: u ? (m.y + l) / 2 : l,\n          anchorX: p ? void 0 : u ? (2 * m.anchorX + k) / 3 : k,\n          anchorY: p ? void 0 : u ? (m.anchorY + f) / 2 : f\n        });\n        a.getLabel().attr(m);\n        a.drawTracker();\n        u && (c.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          a && a.move(d, l, k, f);\n        }, 32));\n      };\n\n      m.prototype.refresh = function (d, l) {\n        var k = this.chart,\n            f = this.options,\n            a = d,\n            m = {},\n            u = [],\n            p = f.formatter || this.defaultFormatter;\n        m = this.shared;\n        var g = k.styledMode;\n\n        if (f.enabled) {\n          c.clearTimeout(this.hideTimer);\n          this.followPointer = r(a)[0].series.tooltipOptions.followPointer;\n          var w = this.getAnchor(a, l);\n          l = w[0];\n          var M = w[1];\n          !m || a.series && a.series.noSharedTooltip ? m = a.getLabelConfig() : (k.pointer.applyInactiveState(a), a.forEach(function (a) {\n            a.setState(\"hover\");\n            u.push(a.getLabelConfig());\n          }), m = {\n            x: a[0].category,\n            y: a[0].y\n          }, m.points = u, a = a[0]);\n          this.len = u.length;\n          k = p.call(m, this);\n          p = a.series;\n          this.distance = n(p.tooltipOptions.distance, 16);\n          !1 === k ? this.hide() : (this.split ? this.renderSplit(k, r(d)) : (d = this.getLabel(), f.style.width && !g || d.css({\n            width: this.chart.spacingBox.width + \"px\"\n          }), d.attr({\n            text: k && k.join ? k.join(\"\") : k\n          }), d.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\" + n(a.colorIndex, p.colorIndex)), g || d.attr({\n            stroke: f.borderColor || a.color || p.color || \"#666666\"\n          }), this.updatePosition({\n            plotX: l,\n            plotY: M,\n            negative: a.negative,\n            ttBelow: a.ttBelow,\n            h: w[2] || 0\n          })), this.isHidden && this.label && this.label.attr({\n            opacity: 1\n          }).show(), this.isHidden = !1);\n          t(this, \"refresh\");\n        }\n      };\n\n      m.prototype.renderSplit = function (d, c) {\n        function k(b, a, e, h, f) {\n          void 0 === f && (f = !0);\n          e ? (a = V ? 0 : D, b = y(b - h / 2, q.left, q.right - h)) : (a -= G, b = f ? b - h - z : b + z, b = y(b, f ? b : q.left, q.right));\n          return {\n            x: b,\n            y: a\n          };\n        }\n\n        var f = this,\n            a = f.chart,\n            l = f.chart,\n            m = l.plotHeight,\n            p = l.plotLeft,\n            r = l.plotTop,\n            w = l.pointer,\n            M = l.renderer,\n            F = l.scrollablePixelsY,\n            t = void 0 === F ? 0 : F;\n        F = l.scrollingContainer;\n        F = void 0 === F ? {\n          scrollLeft: 0,\n          scrollTop: 0\n        } : F;\n        var e = F.scrollLeft,\n            b = F.scrollTop,\n            h = l.styledMode,\n            z = f.distance,\n            x = f.options,\n            C = f.options.positioner,\n            q = {\n          left: e,\n          right: e + l.chartWidth,\n          top: b,\n          bottom: b + l.chartHeight\n        },\n            I = f.getLabel(),\n            V = !(!a.xAxis[0] || !a.xAxis[0].opposite),\n            G = r + b,\n            K = 0,\n            D = m - t;\n        v(d) && (d = [!1, d]);\n        d = d.slice(0, c.length + 1).reduce(function (a, e, d) {\n          if (!1 !== e && \"\" !== e) {\n            d = c[d - 1] || {\n              isHeader: !0,\n              plotX: c[0].plotX,\n              plotY: m,\n              series: {}\n            };\n            var l = d.isHeader,\n                u = l ? f : d.series,\n                w = u.tt,\n                g = d.isHeader;\n            var A = d.series;\n            var E = \"highcharts-color-\" + n(d.colorIndex, A.colorIndex, \"none\");\n            w || (w = {\n              padding: x.padding,\n              r: x.borderRadius\n            }, h || (w.fill = x.backgroundColor, w[\"stroke-width\"] = x.borderWidth), w = M.label(\"\", 0, 0, x[g ? \"headerShape\" : \"shape\"] || \"callout\", void 0, void 0, x.useHTML).addClass((g ? \"highcharts-tooltip-header \" : \"\") + \"highcharts-tooltip-box \" + E).attr(w).add(I));\n            w.isActive = !0;\n            w.attr({\n              text: e\n            });\n            h || w.css(x.style).shadow(x.shadow).attr({\n              stroke: x.borderColor || d.color || A.color || \"#333333\"\n            });\n            e = u.tt = w;\n            g = e.getBBox();\n            u = g.width + e.strokeWidth();\n            l && (K = g.height, D += K, V && (G -= K));\n            A = d.plotX;\n            A = void 0 === A ? 0 : A;\n            E = d.plotY;\n            E = void 0 === E ? 0 : E;\n            var F = d.series;\n\n            if (d.isHeader) {\n              A = p + A;\n              var S = r + m / 2;\n            } else w = F.xAxis, F = F.yAxis, A = w.pos + y(A, -z, w.len + z), F.pos + E >= b + r && F.pos + E <= b + r + m - t && (S = F.pos + E);\n\n            A = y(A, q.left - z, q.right + z);\n            \"number\" === typeof S ? (g = g.height + 1, E = C ? C.call(f, u, g, d) : k(A, S, l, u), a.push({\n              align: C ? 0 : void 0,\n              anchorX: A,\n              anchorY: S,\n              boxWidth: u,\n              point: d,\n              rank: n(E.rank, l ? 1 : 0),\n              size: g,\n              target: E.y,\n              tt: e,\n              x: E.x\n            })) : e.isActive = !1;\n          }\n\n          return a;\n        }, []);\n        !C && d.some(function (b) {\n          return b.x < q.left;\n        }) && (d = d.map(function (b) {\n          var a = k(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);\n          return J(b, {\n            target: a.y,\n            x: a.x\n          });\n        }));\n        f.cleanSplit();\n        g.distribute(d, D);\n        d.forEach(function (b) {\n          var a = b.pos;\n          b.tt.attr({\n            visibility: \"undefined\" === typeof a ? \"hidden\" : \"inherit\",\n            x: b.x,\n            y: a + G,\n            anchorX: b.anchorX,\n            anchorY: b.anchorY\n          });\n        });\n        d = f.container;\n        a = f.renderer;\n        f.outside && d && a && (l = I.getBBox(), a.setSize(l.width + l.x, l.height + l.y, !1), w = w.getChartPosition(), d.style.left = w.left + \"px\", d.style.top = w.top + \"px\");\n      };\n\n      m.prototype.drawTracker = function () {\n        if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {\n          var d = this.chart,\n              c = this.label,\n              k = d.hoverPoint;\n\n          if (c && k) {\n            var f = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            };\n            k = this.getAnchor(k);\n            var a = c.getBBox();\n            k[0] += d.plotLeft - c.translateX;\n            k[1] += d.plotTop - c.translateY;\n            f.x = Math.min(0, k[0]);\n            f.y = Math.min(0, k[1]);\n            f.width = 0 > k[0] ? Math.max(Math.abs(k[0]), a.width - k[0]) : Math.max(Math.abs(k[0]), a.width);\n            f.height = 0 > k[1] ? Math.max(Math.abs(k[1]), a.height - Math.abs(k[1])) : Math.max(Math.abs(k[1]), a.height);\n            this.tracker ? this.tracker.attr(f) : (this.tracker = c.renderer.rect(f).addClass(\"highcharts-tracker\").add(c), d.styledMode || this.tracker.attr({\n              fill: \"rgba(0,0,0,0)\"\n            }));\n          }\n        }\n      };\n\n      m.prototype.styledModeFormat = function (d) {\n        return d.replace('style=\"font-size: 10px\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex}\"');\n      };\n\n      m.prototype.tooltipFooterHeaderFormatter = function (d, c) {\n        var k = c ? \"footer\" : \"header\",\n            f = d.series,\n            a = f.tooltipOptions,\n            l = a.xDateFormat,\n            m = f.xAxis,\n            p = m && \"datetime\" === m.options.type && L(d.key),\n            n = a[k + \"Format\"];\n        c = {\n          isFooter: c,\n          labelConfig: d\n        };\n        t(this, \"headerFormatter\", c, function (c) {\n          p && !l && (l = this.getXDateFormat(d, a, m));\n          p && l && (d.point && d.point.tooltipDateKeys || [\"key\"]).forEach(function (a) {\n            n = n.replace(\"{point.\" + a + \"}\", \"{point.\" + a + \":\" + l + \"}\");\n          });\n          f.chart.styledMode && (n = this.styledModeFormat(n));\n          c.text = G(n, {\n            point: d,\n            series: f\n          }, this.chart);\n        });\n        return c.text;\n      };\n\n      m.prototype.update = function (d) {\n        this.destroy();\n        K(!0, this.chart.options.tooltip.userOptions, d);\n        this.init(this.chart, K(!0, this.options, d));\n      };\n\n      m.prototype.updatePosition = function (d) {\n        var c = this.chart,\n            k = c.pointer,\n            f = this.getLabel(),\n            a = d.plotX + c.plotLeft,\n            m = d.plotY + c.plotTop;\n        k = k.getChartPosition();\n        d = (this.options.positioner || this.getPosition).call(this, f.width, f.height, d);\n\n        if (this.outside) {\n          var p = (this.options.borderWidth || 0) + 2 * this.distance;\n          this.renderer.setSize(f.width + p, f.height + p, !1);\n          if (c = c.containerScaling) B(this.container, {\n            transform: \"scale(\" + c.scaleX + \", \" + c.scaleY + \")\"\n          }), a *= c.scaleX, m *= c.scaleY;\n          a += k.left - d.x;\n          m += k.top - d.y;\n        }\n\n        this.move(Math.round(d.x), Math.round(d.y || 0), a, m);\n      };\n\n      return m;\n    }();\n\n    g.Tooltip = p;\n    return g.Tooltip;\n  });\n  O(q, \"parts/Pointer.js\", [q[\"parts/Color.js\"], q[\"parts/Globals.js\"], q[\"parts/Tooltip.js\"], q[\"parts/Utilities.js\"]], function (g, c, q, y) {\n    var B = g.parse,\n        H = c.charts,\n        D = c.noop,\n        J = y.addEvent,\n        t = y.attr,\n        G = y.css,\n        L = y.defined,\n        v = y.extend,\n        K = y.find,\n        n = y.fireEvent,\n        r = y.isNumber,\n        C = y.isObject,\n        I = y.objectEach,\n        p = y.offset,\n        m = y.pick,\n        d = y.splat;\n    \"\";\n\n    g = function () {\n      function l(d, f) {\n        this.lastValidTouch = {};\n        this.pinchDown = [];\n        this.runChartClick = !1;\n        this.chart = d;\n        this.hasDragged = !1;\n        this.options = f;\n\n        this.unbindContainerMouseLeave = function () {};\n\n        this.init(d, f);\n      }\n\n      l.prototype.applyInactiveState = function (d) {\n        var f = [],\n            a;\n        (d || []).forEach(function (d) {\n          a = d.series;\n          f.push(a);\n          a.linkedParent && f.push(a.linkedParent);\n          a.linkedSeries && (f = f.concat(a.linkedSeries));\n          a.navigatorSeries && f.push(a.navigatorSeries);\n        });\n        this.chart.series.forEach(function (a) {\n          -1 === f.indexOf(a) ? a.setState(\"inactive\", !0) : a.options.inactiveOtherPoints && a.setAllPointsToState(\"inactive\");\n        });\n      };\n\n      l.prototype.destroy = function () {\n        var d = this;\n        \"undefined\" !== typeof d.unDocMouseMove && d.unDocMouseMove();\n        this.unbindContainerMouseLeave();\n        c.chartCount || (c.unbindDocumentMouseUp && (c.unbindDocumentMouseUp = c.unbindDocumentMouseUp()), c.unbindDocumentTouchEnd && (c.unbindDocumentTouchEnd = c.unbindDocumentTouchEnd()));\n        clearInterval(d.tooltipTimeout);\n        I(d, function (f, a) {\n          d[a] = void 0;\n        });\n      };\n\n      l.prototype.drag = function (d) {\n        var f = this.chart,\n            a = f.options.chart,\n            c = d.chartX,\n            k = d.chartY,\n            l = this.zoomHor,\n            m = this.zoomVert,\n            p = f.plotLeft,\n            n = f.plotTop,\n            g = f.plotWidth,\n            r = f.plotHeight,\n            e = this.selectionMarker,\n            b = this.mouseDownX || 0,\n            h = this.mouseDownY || 0,\n            z = C(a.panning) ? a.panning && a.panning.enabled : a.panning,\n            x = a.panKey && d[a.panKey + \"Key\"];\n        if (!e || !e.touch) if (c < p ? c = p : c > p + g && (c = p + g), k < n ? k = n : k > n + r && (k = n + r), this.hasDragged = Math.sqrt(Math.pow(b - c, 2) + Math.pow(h - k, 2)), 10 < this.hasDragged) {\n          var t = f.isInsidePlot(b - p, h - n);\n          f.hasCartesianSeries && (this.zoomX || this.zoomY) && t && !x && !e && (this.selectionMarker = e = f.renderer.rect(p, n, l ? 1 : g, m ? 1 : r, 0).attr({\n            \"class\": \"highcharts-selection-marker\",\n            zIndex: 7\n          }).add(), f.styledMode || e.attr({\n            fill: a.selectionMarkerFill || B(\"#335cad\").setOpacity(.25).get()\n          }));\n          e && l && (c -= b, e.attr({\n            width: Math.abs(c),\n            x: (0 < c ? 0 : c) + b\n          }));\n          e && m && (c = k - h, e.attr({\n            height: Math.abs(c),\n            y: (0 < c ? 0 : c) + h\n          }));\n          t && !e && z && f.pan(d, a.panning);\n        }\n      };\n\n      l.prototype.dragStart = function (d) {\n        var f = this.chart;\n        f.mouseIsDown = d.type;\n        f.cancelClick = !1;\n        f.mouseDownX = this.mouseDownX = d.chartX;\n        f.mouseDownY = this.mouseDownY = d.chartY;\n      };\n\n      l.prototype.drop = function (d) {\n        var f = this,\n            a = this.chart,\n            c = this.hasPinched;\n\n        if (this.selectionMarker) {\n          var k = {\n            originalEvent: d,\n            xAxis: [],\n            yAxis: []\n          },\n              l = this.selectionMarker,\n              m = l.attr ? l.attr(\"x\") : l.x,\n              p = l.attr ? l.attr(\"y\") : l.y,\n              g = l.attr ? l.attr(\"width\") : l.width,\n              F = l.attr ? l.attr(\"height\") : l.height,\n              t;\n          if (this.hasDragged || c) a.axes.forEach(function (a) {\n            if (a.zoomEnabled && L(a.min) && (c || f[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[a.coll]]) && r(m) && r(p)) {\n              var b = a.horiz,\n                  e = \"touchend\" === d.type ? a.minPixelPadding : 0,\n                  l = a.toValue((b ? m : p) + e);\n              b = a.toValue((b ? m + g : p + F) - e);\n              k[a.coll].push({\n                axis: a,\n                min: Math.min(l, b),\n                max: Math.max(l, b)\n              });\n              t = !0;\n            }\n          }), t && n(a, \"selection\", k, function (e) {\n            a.zoom(v(e, c ? {\n              animation: !1\n            } : null));\n          });\n          r(a.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          c && this.scaleGroups();\n        }\n\n        a && r(a.index) && (G(a.container, {\n          cursor: a._cursor\n        }), a.cancelClick = 10 < this.hasDragged, a.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      };\n\n      l.prototype.findNearestKDPoint = function (d, f, a) {\n        var c = this.chart,\n            k = c.hoverPoint;\n        c = c.tooltip;\n        if (k && c && c.isStickyOnContact()) return k;\n        var l;\n        d.forEach(function (d) {\n          var c = !(d.noSharedTooltip && f) && 0 > d.options.findNearestPointBy.indexOf(\"y\");\n          d = d.searchPoint(a, c);\n\n          if ((c = C(d, !0)) && !(c = !C(l, !0))) {\n            c = l.distX - d.distX;\n            var k = l.dist - d.dist,\n                m = (d.series.group && d.series.group.zIndex) - (l.series.group && l.series.group.zIndex);\n            c = 0 < (0 !== c && f ? c : 0 !== k ? k : 0 !== m ? m : l.series.index > d.series.index ? -1 : 1);\n          }\n\n          c && (l = d);\n        });\n        return l;\n      };\n\n      l.prototype.getChartCoordinatesFromPoint = function (d, f) {\n        var a = d.series,\n            c = a.xAxis;\n        a = a.yAxis;\n        var k = m(d.clientX, d.plotX),\n            l = d.shapeArgs;\n        if (c && a) return f ? {\n          chartX: c.len + c.pos - k,\n          chartY: a.len + a.pos - d.plotY\n        } : {\n          chartX: k + c.pos,\n          chartY: d.plotY + a.pos\n        };\n        if (l && l.x && l.y) return {\n          chartX: l.x,\n          chartY: l.y\n        };\n      };\n\n      l.prototype.getChartPosition = function () {\n        return this.chartPosition || (this.chartPosition = p(this.chart.container));\n      };\n\n      l.prototype.getCoordinates = function (d) {\n        var f = {\n          xAxis: [],\n          yAxis: []\n        };\n        this.chart.axes.forEach(function (a) {\n          f[a.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: a,\n            value: a.toValue(d[a.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return f;\n      };\n\n      l.prototype.getHoverData = function (d, f, a, c, l, p) {\n        var k,\n            u = [];\n        c = !(!c || !d);\n        var g = f && !f.stickyTracking,\n            A = {\n          chartX: p ? p.chartX : void 0,\n          chartY: p ? p.chartY : void 0,\n          shared: l\n        };\n        n(this, \"beforeGetHoverData\", A);\n        g = g ? [f] : a.filter(function (a) {\n          return A.filter ? A.filter(a) : a.visible && !(!l && a.directTouch) && m(a.options.enableMouseTracking, !0) && a.stickyTracking;\n        });\n        f = (k = c || !p ? d : this.findNearestKDPoint(g, l, p)) && k.series;\n        k && (l && !f.noSharedTooltip ? (g = a.filter(function (a) {\n          return A.filter ? A.filter(a) : a.visible && !(!l && a.directTouch) && m(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;\n        }), g.forEach(function (a) {\n          var e = K(a.points, function (b) {\n            return b.x === k.x && !b.isNull;\n          });\n          C(e) && (a.chart.isBoosting && (e = a.getPoint(e)), u.push(e));\n        })) : u.push(k));\n        A = {\n          hoverPoint: k\n        };\n        n(this, \"afterGetHoverData\", A);\n        return {\n          hoverPoint: A.hoverPoint,\n          hoverSeries: f,\n          hoverPoints: u\n        };\n      };\n\n      l.prototype.getPointFromEvent = function (d) {\n        d = d.target;\n\n        for (var f; d && !f;) f = d.point, d = d.parentNode;\n\n        return f;\n      };\n\n      l.prototype.onTrackerMouseOut = function (d) {\n        d = d.relatedTarget || d.toElement;\n        var f = this.chart.hoverSeries;\n        this.isDirectTouch = !1;\n        if (!(!f || !d || f.stickyTracking || this.inClass(d, \"highcharts-tooltip\") || this.inClass(d, \"highcharts-series-\" + f.index) && this.inClass(d, \"highcharts-tracker\"))) f.onMouseOut();\n      };\n\n      l.prototype.inClass = function (d, f) {\n        for (var a; d;) {\n          if (a = t(d, \"class\")) {\n            if (-1 !== a.indexOf(f)) return !0;\n            if (-1 !== a.indexOf(\"highcharts-container\")) return !1;\n          }\n\n          d = d.parentNode;\n        }\n      };\n\n      l.prototype.init = function (d, f) {\n        this.options = f;\n        this.chart = d;\n        this.runChartClick = f.chart.events && !!f.chart.events.click;\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        q && (d.tooltip = new q(d, f.tooltip), this.followTouchMove = m(f.tooltip.followTouchMove, !0));\n        this.setDOMEvents();\n      };\n\n      l.prototype.normalize = function (d, f) {\n        var a = d.touches,\n            c = a ? a.length ? a.item(0) : m(a.changedTouches, d.changedTouches)[0] : d;\n        f || (f = this.getChartPosition());\n        a = c.pageX - f.left;\n        f = c.pageY - f.top;\n        if (c = this.chart.containerScaling) a /= c.scaleX, f /= c.scaleY;\n        return v(d, {\n          chartX: Math.round(a),\n          chartY: Math.round(f)\n        });\n      };\n\n      l.prototype.onContainerClick = function (d) {\n        var f = this.chart,\n            a = f.hoverPoint;\n        d = this.normalize(d);\n        var c = f.plotLeft,\n            k = f.plotTop;\n        f.cancelClick || (a && this.inClass(d.target, \"highcharts-tracker\") ? (n(a.series, \"click\", v(d, {\n          point: a\n        })), f.hoverPoint && a.firePointEvent(\"click\", d)) : (v(d, this.getCoordinates(d)), f.isInsidePlot(d.chartX - c, d.chartY - k) && n(f, \"click\", d)));\n      };\n\n      l.prototype.onContainerMouseDown = function (d) {\n        d = this.normalize(d);\n        if (c.isFirefox && 0 !== d.button) this.onContainerMouseMove(d);\n        if (\"undefined\" === typeof d.button || 1 === ((d.buttons || d.button) & 1)) this.zoomOption(d), this.dragStart(d);\n      };\n\n      l.prototype.onContainerMouseLeave = function (d) {\n        var f = H[m(c.hoverChartIndex, -1)],\n            a = this.chart.tooltip;\n        d = this.normalize(d);\n        f && (d.relatedTarget || d.toElement) && (f.pointer.reset(), f.pointer.chartPosition = void 0);\n        a && !a.isHidden && this.reset();\n      };\n\n      l.prototype.onContainerMouseMove = function (d) {\n        var f = this.chart;\n        d = this.normalize(d);\n        this.setHoverChartIndex();\n        d.preventDefault || (d.returnValue = !1);\n        \"mousedown\" === f.mouseIsDown && this.drag(d);\n        f.openMenu || !this.inClass(d.target, \"highcharts-tracker\") && !f.isInsidePlot(d.chartX - f.plotLeft, d.chartY - f.plotTop) || this.runPointActions(d);\n      };\n\n      l.prototype.onDocumentTouchEnd = function (d) {\n        H[c.hoverChartIndex] && H[c.hoverChartIndex].pointer.drop(d);\n      };\n\n      l.prototype.onContainerTouchMove = function (d) {\n        this.touch(d);\n      };\n\n      l.prototype.onContainerTouchStart = function (d) {\n        this.zoomOption(d);\n        this.touch(d, !0);\n      };\n\n      l.prototype.onDocumentMouseMove = function (d) {\n        var f = this.chart,\n            a = this.chartPosition;\n        d = this.normalize(d, a);\n        var c = f.tooltip;\n        !a || c && c.isStickyOnContact() || f.isInsidePlot(d.chartX - f.plotLeft, d.chartY - f.plotTop) || this.inClass(d.target, \"highcharts-tracker\") || this.reset();\n      };\n\n      l.prototype.onDocumentMouseUp = function (d) {\n        var f = H[m(c.hoverChartIndex, -1)];\n        f && f.pointer.drop(d);\n      };\n\n      l.prototype.pinch = function (d) {\n        var f = this,\n            a = f.chart,\n            c = f.pinchDown,\n            k = d.touches || [],\n            l = k.length,\n            p = f.lastValidTouch,\n            n = f.hasZoom,\n            g = f.selectionMarker,\n            r = {},\n            t = 1 === l && (f.inClass(d.target, \"highcharts-tracker\") && a.runTrackerClick || f.runChartClick),\n            e = {};\n        1 < l && (f.initiated = !0);\n        n && f.initiated && !t && d.preventDefault();\n        [].map.call(k, function (b) {\n          return f.normalize(b);\n        });\n        \"touchstart\" === d.type ? ([].forEach.call(k, function (b, a) {\n          c[a] = {\n            chartX: b.chartX,\n            chartY: b.chartY\n          };\n        }), p.x = [c[0].chartX, c[1] && c[1].chartX], p.y = [c[0].chartY, c[1] && c[1].chartY], a.axes.forEach(function (b) {\n          if (b.zoomEnabled) {\n            var e = a.bounds[b.horiz ? \"h\" : \"v\"],\n                f = b.minPixelPadding,\n                d = b.toPixels(Math.min(m(b.options.min, b.dataMin), b.dataMin)),\n                c = b.toPixels(Math.max(m(b.options.max, b.dataMax), b.dataMax)),\n                k = Math.max(d, c);\n            e.min = Math.min(b.pos, Math.min(d, c) - f);\n            e.max = Math.max(b.pos + b.len, k + f);\n          }\n        }), f.res = !0) : f.followTouchMove && 1 === l ? this.runPointActions(f.normalize(d)) : c.length && (g || (f.selectionMarker = g = v({\n          destroy: D,\n          touch: !0\n        }, a.plotBox)), f.pinchTranslate(c, k, r, g, e, p), f.hasPinched = n, f.scaleGroups(r, e), f.res && (f.res = !1, this.reset(!1, 0)));\n      };\n\n      l.prototype.pinchTranslate = function (d, f, a, c, l, m) {\n        this.zoomHor && this.pinchTranslateDirection(!0, d, f, a, c, l, m);\n        this.zoomVert && this.pinchTranslateDirection(!1, d, f, a, c, l, m);\n      };\n\n      l.prototype.pinchTranslateDirection = function (d, f, a, c, l, m, p, n) {\n        var k = this.chart,\n            u = d ? \"x\" : \"y\",\n            g = d ? \"X\" : \"Y\",\n            e = \"chart\" + g,\n            b = d ? \"width\" : \"height\",\n            h = k[\"plot\" + (d ? \"Left\" : \"Top\")],\n            w,\n            x,\n            A = n || 1,\n            r = k.inverted,\n            E = k.bounds[d ? \"h\" : \"v\"],\n            t = 1 === f.length,\n            C = f[0][e],\n            v = a[0][e],\n            q = !t && f[1][e],\n            I = !t && a[1][e];\n\n        a = function a() {\n          \"number\" === typeof I && 20 < Math.abs(C - q) && (A = n || Math.abs(v - I) / Math.abs(C - q));\n          x = (h - v) / A + C;\n          w = k[\"plot\" + (d ? \"Width\" : \"Height\")] / A;\n        };\n\n        a();\n        f = x;\n\n        if (f < E.min) {\n          f = E.min;\n          var P = !0;\n        } else f + w > E.max && (f = E.max - w, P = !0);\n\n        P ? (v -= .8 * (v - p[u][0]), \"number\" === typeof I && (I -= .8 * (I - p[u][1])), a()) : p[u] = [v, I];\n        r || (m[u] = x - h, m[b] = w);\n        m = r ? 1 / A : A;\n        l[b] = w;\n        l[u] = f;\n        c[r ? d ? \"scaleY\" : \"scaleX\" : \"scale\" + g] = A;\n        c[\"translate\" + g] = m * h + (v - m * C);\n      };\n\n      l.prototype.reset = function (c, f) {\n        var a = this.chart,\n            k = a.hoverSeries,\n            l = a.hoverPoint,\n            m = a.hoverPoints,\n            p = a.tooltip,\n            n = p && p.shared ? m : l;\n        c && n && d(n).forEach(function (a) {\n          a.series.isCartesian && \"undefined\" === typeof a.plotX && (c = !1);\n        });\n        if (c) p && n && d(n).length && (p.refresh(n), p.shared && m ? m.forEach(function (a) {\n          a.setState(a.state, !0);\n          a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));\n        }) : l && (l.setState(l.state, !0), a.axes.forEach(function (a) {\n          a.crosshair && l.series[a.coll] === a && a.drawCrosshair(null, l);\n        })));else {\n          if (l) l.onMouseOut();\n          m && m.forEach(function (a) {\n            a.setState();\n          });\n          if (k) k.onMouseOut();\n          p && p.hide(f);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          a.axes.forEach(function (a) {\n            a.hideCrosshair();\n          });\n          this.hoverX = a.hoverPoints = a.hoverPoint = null;\n        }\n      };\n\n      l.prototype.runPointActions = function (d, f) {\n        var a = this.chart,\n            k = a.tooltip && a.tooltip.options.enabled ? a.tooltip : void 0,\n            l = k ? k.shared : !1,\n            p = f || a.hoverPoint,\n            n = p && p.series || a.hoverSeries;\n        n = this.getHoverData(p, n, a.series, (!d || \"touchmove\" !== d.type) && (!!f || n && n.directTouch && this.isDirectTouch), l, d);\n        p = n.hoverPoint;\n        var g = n.hoverPoints;\n        f = (n = n.hoverSeries) && n.tooltipOptions.followPointer;\n        l = l && n && !n.noSharedTooltip;\n\n        if (p && (p !== a.hoverPoint || k && k.isHidden)) {\n          (a.hoverPoints || []).forEach(function (a) {\n            -1 === g.indexOf(a) && a.setState();\n          });\n          if (a.hoverSeries !== n) n.onMouseOver();\n          this.applyInactiveState(g);\n          (g || []).forEach(function (a) {\n            a.setState(\"hover\");\n          });\n          a.hoverPoint && a.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!p.series) return;\n          a.hoverPoints = g;\n          a.hoverPoint = p;\n          p.firePointEvent(\"mouseOver\");\n          k && k.refresh(l ? g : p, d);\n        } else f && k && !k.isHidden && (p = k.getAnchor([{}], d), k.updatePosition({\n          plotX: p[0],\n          plotY: p[1]\n        }));\n\n        this.unDocMouseMove || (this.unDocMouseMove = J(a.container.ownerDocument, \"mousemove\", function (a) {\n          var f = H[c.hoverChartIndex];\n          if (f) f.pointer.onDocumentMouseMove(a);\n        }));\n        a.axes.forEach(function (f) {\n          var c = m((f.crosshair || {}).snap, !0),\n              k;\n          c && ((k = a.hoverPoint) && k.series[f.coll] === f || (k = K(g, function (a) {\n            return a.series[f.coll] === f;\n          })));\n          k || !c ? f.drawCrosshair(d, k) : f.hideCrosshair();\n        });\n      };\n\n      l.prototype.scaleGroups = function (d, f) {\n        var a = this.chart,\n            c;\n        a.series.forEach(function (k) {\n          c = d || k.getPlotBox();\n          k.xAxis && k.xAxis.zoomEnabled && k.group && (k.group.attr(c), k.markerGroup && (k.markerGroup.attr(c), k.markerGroup.clip(f ? a.clipRect : null)), k.dataLabelsGroup && k.dataLabelsGroup.attr(c));\n        });\n        a.clipRect.attr(f || a.clipBox);\n      };\n\n      l.prototype.setDOMEvents = function () {\n        var d = this.chart.container,\n            f = d.ownerDocument;\n        d.onmousedown = this.onContainerMouseDown.bind(this);\n        d.onmousemove = this.onContainerMouseMove.bind(this);\n        d.onclick = this.onContainerClick.bind(this);\n        this.unbindContainerMouseLeave = J(d, \"mouseleave\", this.onContainerMouseLeave.bind(this));\n        c.unbindDocumentMouseUp || (c.unbindDocumentMouseUp = J(f, \"mouseup\", this.onDocumentMouseUp.bind(this)));\n        c.hasTouch && (J(d, \"touchstart\", this.onContainerTouchStart.bind(this)), J(d, \"touchmove\", this.onContainerTouchMove.bind(this)), c.unbindDocumentTouchEnd || (c.unbindDocumentTouchEnd = J(f, \"touchend\", this.onDocumentTouchEnd.bind(this))));\n      };\n\n      l.prototype.setHoverChartIndex = function () {\n        var d = this.chart,\n            f = c.charts[m(c.hoverChartIndex, -1)];\n        if (f && f !== d) f.pointer.onContainerMouseLeave({\n          relatedTarget: !0\n        });\n        f && f.mouseIsDown || (c.hoverChartIndex = d.index);\n      };\n\n      l.prototype.touch = function (d, f) {\n        var a = this.chart,\n            c;\n        this.setHoverChartIndex();\n        if (1 === d.touches.length) {\n          if (d = this.normalize(d), (c = a.isInsidePlot(d.chartX - a.plotLeft, d.chartY - a.plotTop)) && !a.openMenu) {\n            f && this.runPointActions(d);\n\n            if (\"touchmove\" === d.type) {\n              f = this.pinchDown;\n              var k = f[0] ? 4 <= Math.sqrt(Math.pow(f[0].chartX - d.chartX, 2) + Math.pow(f[0].chartY - d.chartY, 2)) : !1;\n            }\n\n            m(k, !0) && this.pinch(d);\n          } else f && this.reset();\n        } else 2 === d.touches.length && this.pinch(d);\n      };\n\n      l.prototype.zoomOption = function (d) {\n        var f = this.chart,\n            a = f.options.chart,\n            c = a.zoomType || \"\";\n        f = f.inverted;\n        /touch/.test(d.type) && (c = m(a.pinchType, c));\n        this.zoomX = d = /x/.test(c);\n        this.zoomY = c = /y/.test(c);\n        this.zoomHor = d && !f || c && f;\n        this.zoomVert = c && !f || d && f;\n        this.hasZoom = d || c;\n      };\n\n      return l;\n    }();\n\n    return c.Pointer = g;\n  });\n  O(q, \"parts/MSPointer.js\", [q[\"parts/Globals.js\"], q[\"parts/Pointer.js\"], q[\"parts/Utilities.js\"]], function (g, c, q) {\n    function y() {\n      var c = [];\n\n      c.item = function (c) {\n        return this[c];\n      };\n\n      v(n, function (n) {\n        c.push({\n          pageX: n.pageX,\n          pageY: n.pageY,\n          target: n.target\n        });\n      });\n      return c;\n    }\n\n    function B(c, n, p, m) {\n      \"touch\" !== c.pointerType && c.pointerType !== c.MSPOINTER_TYPE_TOUCH || !D[g.hoverChartIndex] || (m(c), m = D[g.hoverChartIndex].pointer, m[n]({\n        type: p,\n        target: c.currentTarget,\n        preventDefault: t,\n        touches: y()\n      }));\n    }\n\n    var H = this && this.__extends || function () {\n      var _c2 = function c(n, p) {\n        _c2 = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (c, d) {\n          c.__proto__ = d;\n        } || function (c, d) {\n          for (var l in d) d.hasOwnProperty(l) && (c[l] = d[l]);\n        };\n\n        return _c2(n, p);\n      };\n\n      return function (n, p) {\n        function m() {\n          this.constructor = n;\n        }\n\n        _c2(n, p);\n\n        n.prototype = null === p ? Object.create(p) : (m.prototype = p.prototype, new m());\n      };\n    }(),\n        D = g.charts,\n        J = g.doc,\n        t = g.noop,\n        G = q.addEvent,\n        L = q.css,\n        v = q.objectEach,\n        K = q.removeEvent,\n        n = {},\n        r = !!g.win.PointerEvent;\n\n    return function (c) {\n      function g() {\n        return null !== c && c.apply(this, arguments) || this;\n      }\n\n      H(g, c);\n\n      g.prototype.batchMSEvents = function (c) {\n        c(this.chart.container, r ? \"pointerdown\" : \"MSPointerDown\", this.onContainerPointerDown);\n        c(this.chart.container, r ? \"pointermove\" : \"MSPointerMove\", this.onContainerPointerMove);\n        c(J, r ? \"pointerup\" : \"MSPointerUp\", this.onDocumentPointerUp);\n      };\n\n      g.prototype.destroy = function () {\n        this.batchMSEvents(K);\n        c.prototype.destroy.call(this);\n      };\n\n      g.prototype.init = function (p, m) {\n        c.prototype.init.call(this, p, m);\n        this.hasZoom && L(p.container, {\n          \"-ms-touch-action\": \"none\",\n          \"touch-action\": \"none\"\n        });\n      };\n\n      g.prototype.onContainerPointerDown = function (c) {\n        B(c, \"onContainerTouchStart\", \"touchstart\", function (c) {\n          n[c.pointerId] = {\n            pageX: c.pageX,\n            pageY: c.pageY,\n            target: c.currentTarget\n          };\n        });\n      };\n\n      g.prototype.onContainerPointerMove = function (c) {\n        B(c, \"onContainerTouchMove\", \"touchmove\", function (c) {\n          n[c.pointerId] = {\n            pageX: c.pageX,\n            pageY: c.pageY\n          };\n          n[c.pointerId].target || (n[c.pointerId].target = c.currentTarget);\n        });\n      };\n\n      g.prototype.onDocumentPointerUp = function (c) {\n        B(c, \"onDocumentTouchEnd\", \"touchend\", function (c) {\n          delete n[c.pointerId];\n        });\n      };\n\n      g.prototype.setDOMEvents = function () {\n        c.prototype.setDOMEvents.call(this);\n        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(G);\n      };\n\n      return g;\n    }(c);\n  });\n  O(q, \"parts/Legend.js\", [q[\"parts/Globals.js\"], q[\"parts/Utilities.js\"]], function (g, c) {\n    var q = c.addEvent,\n        y = c.animObject,\n        B = c.css,\n        H = c.defined,\n        D = c.discardElement,\n        J = c.find,\n        t = c.fireEvent,\n        G = c.format,\n        L = c.isNumber,\n        v = c.merge,\n        K = c.pick,\n        n = c.relativeLength,\n        r = c.setAnimation,\n        C = c.stableSort,\n        I = c.syncTimeout;\n    c = c.wrap;\n\n    var p = g.isFirefox,\n        m = g.marginNames,\n        d = g.win,\n        l = function () {\n      function d(d, a) {\n        this.allItems = [];\n        this.contentGroup = this.box = void 0;\n        this.display = !1;\n        this.group = void 0;\n        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;\n        this.options = {};\n        this.padding = 0;\n        this.pages = [];\n        this.proximate = !1;\n        this.scrollGroup = void 0;\n        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;\n        this.chart = d;\n        this.init(d, a);\n      }\n\n      d.prototype.init = function (d, a) {\n        this.chart = d;\n        this.setOptions(a);\n        a.enabled && (this.render(), q(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), this.proximate ? this.unchartrender = q(this.chart, \"render\", function () {\n          this.legend.proximatePositions();\n          this.legend.positionItems();\n        }) : this.unchartrender && this.unchartrender());\n      };\n\n      d.prototype.setOptions = function (d) {\n        var a = K(d.padding, 8);\n        this.options = d;\n        this.chart.styledMode || (this.itemStyle = d.itemStyle, this.itemHiddenStyle = v(this.itemStyle, d.itemHiddenStyle));\n        this.itemMarginTop = d.itemMarginTop || 0;\n        this.itemMarginBottom = d.itemMarginBottom || 0;\n        this.padding = a;\n        this.initialItemY = a - 5;\n        this.symbolWidth = K(d.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === d.layout && !this.chart.inverted;\n        this.baseline = void 0;\n      };\n\n      d.prototype.update = function (d, a) {\n        var f = this.chart;\n        this.setOptions(v(!0, this.options, d));\n        this.destroy();\n        f.isDirtyLegend = f.isDirtyBox = !0;\n        K(a, !0) && f.redraw();\n        t(this, \"afterUpdate\");\n      };\n\n      d.prototype.colorizeItem = function (d, a) {\n        d.legendGroup[a ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n\n        if (!this.chart.styledMode) {\n          var f = this.options,\n              c = d.legendItem,\n              l = d.legendLine,\n              k = d.legendSymbol,\n              m = this.itemHiddenStyle.color;\n          f = a ? f.itemStyle.color : m;\n          var p = a ? d.color || m : m,\n              n = d.options && d.options.marker,\n              g = {\n            fill: p\n          };\n          c && c.css({\n            fill: f,\n            color: f\n          });\n          l && l.attr({\n            stroke: p\n          });\n          k && (n && k.isMarker && (g = d.pointAttribs(), a || (g.stroke = g.fill = m)), k.attr(g));\n        }\n\n        t(this, \"afterColorizeItem\", {\n          item: d,\n          visible: a\n        });\n      };\n\n      d.prototype.positionItems = function () {\n        this.allItems.forEach(this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      };\n\n      d.prototype.positionItem = function (d) {\n        var a = this,\n            f = this.options,\n            c = f.symbolPadding,\n            k = !f.rtl,\n            l = d._legendItemPos;\n        f = l[0];\n        l = l[1];\n        var m = d.checkbox,\n            p = d.legendGroup;\n        p && p.element && (c = {\n          translateX: k ? f : this.legendWidth - f - 2 * c - 4,\n          translateY: l\n        }, k = function k() {\n          t(a, \"afterPositionItem\", {\n            item: d\n          });\n        }, H(p.translateY) ? p.animate(c, {\n          complete: k\n        }) : (p.attr(c), k()));\n        m && (m.x = f, m.y = l);\n      };\n\n      d.prototype.destroyItem = function (d) {\n        var a = d.checkbox;\n        [\"legendItem\", \"legendLine\", \"legendSymbol\", \"legendGroup\"].forEach(function (a) {\n          d[a] && (d[a] = d[a].destroy());\n        });\n        a && D(d.checkbox);\n      };\n\n      d.prototype.destroy = function () {\n        function d(a) {\n          this[a] && (this[a] = this[a].destroy());\n        }\n\n        this.getAllItems().forEach(function (a) {\n          [\"legendItem\", \"legendGroup\"].forEach(d, a);\n        });\n        \"clipRect up down pager nav box title group\".split(\" \").forEach(d, this);\n        this.display = null;\n      };\n\n      d.prototype.positionCheckboxes = function () {\n        var d = this.group && this.group.alignAttr,\n            a = this.clipHeight || this.legendHeight,\n            c = this.titleHeight;\n\n        if (d) {\n          var l = d.translateY;\n          this.allItems.forEach(function (f) {\n            var k = f.checkbox;\n\n            if (k) {\n              var m = l + c + k.y + (this.scrollOffset || 0) + 3;\n              B(k, {\n                left: d.translateX + f.checkboxOffset + k.x - 20 + \"px\",\n                top: m + \"px\",\n                display: this.proximate || m > l - 6 && m < l + a - 6 ? \"\" : \"none\"\n              });\n            }\n          }, this);\n        }\n      };\n\n      d.prototype.renderTitle = function () {\n        var d = this.options,\n            a = this.padding,\n            c = d.title,\n            k = 0;\n        c.text && (this.title || (this.title = this.chart.renderer.label(c.text, a - 3, a - 4, null, null, null, d.useHTML, null, \"legend-title\").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(c.style), this.title.add(this.group)), c.width || this.title.css({\n          width: this.maxLegendWidth + \"px\"\n        }), d = this.title.getBBox(), k = d.height, this.offsetWidth = d.width, this.contentGroup.attr({\n          translateY: k\n        }));\n        this.titleHeight = k;\n      };\n\n      d.prototype.setText = function (d) {\n        var a = this.options;\n        d.legendItem.attr({\n          text: a.labelFormat ? G(a.labelFormat, d, this.chart) : a.labelFormatter.call(d)\n        });\n      };\n\n      d.prototype.renderItem = function (d) {\n        var a = this.chart,\n            f = a.renderer,\n            c = this.options,\n            k = this.symbolWidth,\n            l = c.symbolPadding,\n            m = this.itemStyle,\n            p = this.itemHiddenStyle,\n            n = \"horizontal\" === c.layout ? K(c.itemDistance, 20) : 0,\n            g = !c.rtl,\n            e = d.legendItem,\n            b = !d.series,\n            h = !b && d.series.drawLegendSymbol ? d.series : d,\n            z = h.options;\n        z = this.createCheckboxForItem && z && z.showCheckbox;\n        n = k + l + n + (z ? 20 : 0);\n        var x = c.useHTML,\n            r = d.options.className;\n        e || (d.legendGroup = f.g(\"legend-item\").addClass(\"highcharts-\" + h.type + \"-series highcharts-color-\" + d.colorIndex + (r ? \" \" + r : \"\") + (b ? \" highcharts-series-\" + d.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), d.legendItem = e = f.text(\"\", g ? k + l : -l, this.baseline || 0, x), a.styledMode || e.css(v(d.visible ? m : p)), e.attr({\n          align: g ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(d.legendGroup), this.baseline || (this.fontMetrics = f.fontMetrics(a.styledMode ? 12 : m.fontSize, e), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, e.attr(\"y\", this.baseline)), this.symbolHeight = c.symbolHeight || this.fontMetrics.f, h.drawLegendSymbol(this, d), this.setItemEvents && this.setItemEvents(d, e, x));\n        z && !d.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(d);\n        this.colorizeItem(d, d.visible);\n        !a.styledMode && m.width || e.css({\n          width: (c.itemWidth || this.widthOption || a.spacingBox.width) - n + \"px\"\n        });\n        this.setText(d);\n        a = e.getBBox();\n        d.itemWidth = d.checkboxOffset = c.itemWidth || d.legendItemWidth || a.width + n;\n        this.maxItemWidth = Math.max(this.maxItemWidth, d.itemWidth);\n        this.totalItemWidth += d.itemWidth;\n        this.itemHeight = d.itemHeight = Math.round(d.legendItemHeight || a.height || this.symbolHeight);\n      };\n\n      d.prototype.layoutItem = function (d) {\n        var a = this.options,\n            f = this.padding,\n            c = \"horizontal\" === a.layout,\n            k = d.itemHeight,\n            l = this.itemMarginBottom,\n            m = this.itemMarginTop,\n            p = c ? K(a.itemDistance, 20) : 0,\n            n = this.maxLegendWidth;\n        a = a.alignColumns && this.totalItemWidth > n ? this.maxItemWidth : d.itemWidth;\n        c && this.itemX - f + a > n && (this.itemX = f, this.lastLineHeight && (this.itemY += m + this.lastLineHeight + l), this.lastLineHeight = 0);\n        this.lastItemY = m + this.itemY + l;\n        this.lastLineHeight = Math.max(k, this.lastLineHeight);\n        d._legendItemPos = [this.itemX, this.itemY];\n        c ? this.itemX += a : (this.itemY += m + k + l, this.lastLineHeight = k);\n        this.offsetWidth = this.widthOption || Math.max((c ? this.itemX - f - (d.checkbox ? 0 : p) : a) + f, this.offsetWidth);\n      };\n\n      d.prototype.getAllItems = function () {\n        var d = [];\n        this.chart.series.forEach(function (a) {\n          var f = a && a.options;\n          a && K(f.showInLegend, H(f.linkedTo) ? !1 : void 0, !0) && (d = d.concat(a.legendItems || (\"point\" === f.legendType ? a.data : a)));\n        });\n        t(this, \"afterGetAllItems\", {\n          allItems: d\n        });\n        return d;\n      };\n\n      d.prototype.getAlignment = function () {\n        var d = this.options;\n        return this.proximate ? d.align.charAt(0) + \"tv\" : d.floating ? \"\" : d.align.charAt(0) + d.verticalAlign.charAt(0) + d.layout.charAt(0);\n      };\n\n      d.prototype.adjustMargins = function (d, a) {\n        var c = this.chart,\n            f = this.options,\n            k = this.getAlignment();\n        k && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (l, p) {\n          l.test(k) && !H(d[p]) && (c[m[p]] = Math.max(c[m[p]], c.legend[(p + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][p] * f[p % 2 ? \"x\" : \"y\"] + K(f.margin, 12) + a[p] + (c.titleOffset[p] || 0)));\n        });\n      };\n\n      d.prototype.proximatePositions = function () {\n        var d = this.chart,\n            a = [],\n            c = \"left\" === this.options.align;\n        this.allItems.forEach(function (f) {\n          var k = c;\n\n          if (f.yAxis && f.points) {\n            f.xAxis.options.reversed && (k = !k);\n            var l = J(k ? f.points : f.points.slice(0).reverse(), function (a) {\n              return L(a.plotY);\n            });\n            k = this.itemMarginTop + f.legendItem.getBBox().height + this.itemMarginBottom;\n            var m = f.yAxis.top - d.plotTop;\n            f.visible ? (l = l ? l.plotY : f.yAxis.height, l += m - .3 * k) : l = m + f.yAxis.height;\n            a.push({\n              target: l,\n              size: k,\n              item: f\n            });\n          }\n        }, this);\n        g.distribute(a, d.plotHeight);\n        a.forEach(function (a) {\n          a.item._legendItemPos[1] = d.plotTop - d.spacing[0] + a.pos;\n        });\n      };\n\n      d.prototype.render = function () {\n        var d = this.chart,\n            a = d.renderer,\n            c = this.group,\n            k = this.box,\n            l = this.options,\n            m = this.padding;\n        this.itemX = m;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        this.widthOption = n(l.width, d.spacingBox.width - m);\n        var p = d.spacingBox.width - 2 * m - l.x;\n        -1 < [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) && (p /= 2);\n        this.maxLegendWidth = this.widthOption || p;\n        c || (this.group = c = a.g(\"legend\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = a.g().attr({\n          zIndex: 1\n        }).add(c), this.scrollGroup = a.g().add(this.contentGroup));\n        this.renderTitle();\n        var g = this.getAllItems();\n        C(g, function (a, e) {\n          return (a.options && a.options.legendIndex || 0) - (e.options && e.options.legendIndex || 0);\n        });\n        l.reversed && g.reverse();\n        this.allItems = g;\n        this.display = p = !!g.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        g.forEach(this.renderItem, this);\n        g.forEach(this.layoutItem, this);\n        g = (this.widthOption || this.offsetWidth) + m;\n        var r = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        r = this.handleOverflow(r);\n        r += m;\n        k || (this.box = k = a.rect().addClass(\"highcharts-legend-box\").attr({\n          r: l.borderRadius\n        }).add(c), k.isNew = !0);\n        d.styledMode || k.attr({\n          stroke: l.borderColor,\n          \"stroke-width\": l.borderWidth || 0,\n          fill: l.backgroundColor || \"none\"\n        }).shadow(l.shadow);\n        0 < g && 0 < r && (k[k.isNew ? \"attr\" : \"animate\"](k.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: g,\n          height: r\n        }, k.strokeWidth())), k.isNew = !1);\n        k[p ? \"show\" : \"hide\"]();\n        d.styledMode && \"none\" === c.getStyle(\"display\") && (g = r = 0);\n        this.legendWidth = g;\n        this.legendHeight = r;\n        p && this.align();\n        this.proximate || this.positionItems();\n        t(this, \"afterRender\");\n      };\n\n      d.prototype.align = function (d) {\n        void 0 === d && (d = this.chart.spacingBox);\n        var a = this.chart,\n            c = this.options,\n            f = d.y;\n        /(lth|ct|rth)/.test(this.getAlignment()) && 0 < a.titleOffset[0] ? f += a.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < a.titleOffset[2] && (f -= a.titleOffset[2]);\n        f !== d.y && (d = v(d, {\n          y: f\n        }));\n        this.group.align(v(c, {\n          width: this.legendWidth,\n          height: this.legendHeight,\n          verticalAlign: this.proximate ? \"top\" : c.verticalAlign\n        }), !0, d);\n      };\n\n      d.prototype.handleOverflow = function (d) {\n        var a = this,\n            c = this.chart,\n            f = c.renderer,\n            k = this.options,\n            l = k.y,\n            m = this.padding;\n        l = c.spacingBox.height + (\"top\" === k.verticalAlign ? -l : l) - m;\n\n        var p = k.maxHeight,\n            n,\n            g = this.clipRect,\n            e = k.navigation,\n            b = K(e.animation, !0),\n            h = e.arrowSize || 12,\n            z = this.nav,\n            x = this.pages,\n            r,\n            t = this.allItems,\n            v = function v(b) {\n          \"number\" === typeof b ? g.attr({\n            height: b\n          }) : g && (a.clipRect = g.destroy(), a.contentGroup.clip());\n          a.contentGroup.div && (a.contentGroup.div.style.clip = b ? \"rect(\" + m + \"px,9999px,\" + (m + b) + \"px,0)\" : \"auto\");\n        },\n            q = function q(b) {\n          a[b] = f.circle(0, 0, 1.3 * h).translate(h / 2, h / 2).add(z);\n          c.styledMode || a[b].attr(\"fill\", \"rgba(0,0,0,0.0001)\");\n          return a[b];\n        };\n\n        \"horizontal\" !== k.layout || \"middle\" === k.verticalAlign || k.floating || (l /= 2);\n        p && (l = Math.min(l, p));\n        x.length = 0;\n        d > l && !1 !== e.enabled ? (this.clipHeight = n = Math.max(l - 20 - this.titleHeight - m, 0), this.currentPage = K(this.currentPage, 1), this.fullHeight = d, t.forEach(function (b, a) {\n          var e = b._legendItemPos[1],\n              d = Math.round(b.legendItem.getBBox().height),\n              h = x.length;\n          if (!h || e - x[h - 1] > n && (r || e) !== x[h - 1]) x.push(r || e), h++;\n          b.pageIx = h - 1;\n          r && (t[a - 1].pageIx = h - 1);\n          a === t.length - 1 && e + d - x[h - 1] > n && e !== r && (x.push(e), b.pageIx = h);\n          e !== r && (r = e);\n        }), g || (g = a.clipRect = f.clipRect(0, m, 9999, 0), a.contentGroup.clip(g)), v(n), z || (this.nav = z = f.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = f.symbol(\"triangle\", 0, 0, h, h).add(z), q(\"upTracker\").on(\"click\", function () {\n          a.scroll(-1, b);\n        }), this.pager = f.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), c.styledMode || this.pager.css(e.style), this.pager.add(z), this.down = f.symbol(\"triangle-down\", 0, 0, h, h).add(z), q(\"downTracker\").on(\"click\", function () {\n          a.scroll(1, b);\n        })), a.scroll(0), d = l) : z && (v(), this.nav = z.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return d;\n      };\n\n      d.prototype.scroll = function (d, a) {\n        var c = this,\n            f = this.chart,\n            k = this.pages,\n            l = k.length,\n            m = this.currentPage + d;\n        d = this.clipHeight;\n        var p = this.options.navigation,\n            n = this.pager,\n            g = this.padding;\n        m > l && (m = l);\n        0 < m && (\"undefined\" !== typeof a && r(a, f), this.nav.attr({\n          translateX: g,\n          translateY: d + this.padding + 7 + this.titleHeight,\n          visibility: \"visible\"\n        }), [this.up, this.upTracker].forEach(function (a) {\n          a.attr({\n            \"class\": 1 === m ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }), n.attr({\n          text: m + \"/\" + l\n        }), [this.down, this.downTracker].forEach(function (a) {\n          a.attr({\n            x: 18 + this.pager.getBBox().width,\n            \"class\": m === l ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }, this), f.styledMode || (this.up.attr({\n          fill: 1 === m ? p.inactiveColor : p.activeColor\n        }), this.upTracker.css({\n          cursor: 1 === m ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: m === l ? p.inactiveColor : p.activeColor\n        }), this.downTracker.css({\n          cursor: m === l ? \"default\" : \"pointer\"\n        })), this.scrollOffset = -k[m - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = m, this.positionCheckboxes(), a = y(K(a, f.renderer.globalAnimation, !0)), I(function () {\n          t(c, \"afterScroll\", {\n            currentPage: m\n          });\n        }, a.duration || 0));\n      };\n\n      return d;\n    }();\n\n    (/Trident\\/7\\.0/.test(d.navigator && d.navigator.userAgent) || p) && c(l.prototype, \"positionItem\", function (d, c) {\n      var a = this,\n          f = function f() {\n        c._legendItemPos && d.call(a, c);\n      };\n\n      f();\n      a.bubbleLegend || setTimeout(f);\n    });\n    g.Legend = l;\n    return g.Legend;\n  });\n  O(q, \"parts/Chart.js\", [q[\"parts/Axis.js\"], q[\"parts/Globals.js\"], q[\"parts/Legend.js\"], q[\"parts/MSPointer.js\"], q[\"parts/Options.js\"], q[\"parts/Pointer.js\"], q[\"parts/Time.js\"], q[\"parts/Utilities.js\"]], function (g, c, q, y, B, H, D, J) {\n    var t = c.charts,\n        G = c.doc,\n        L = c.seriesTypes,\n        v = c.win,\n        K = B.defaultOptions,\n        n = J.addEvent,\n        r = J.animate,\n        C = J.animObject,\n        I = J.attr,\n        p = J.createElement,\n        m = J.css,\n        d = J.defined,\n        l = J.discardElement,\n        k = J.erase,\n        f = J.error,\n        a = J.extend,\n        A = J.find,\n        u = J.fireEvent,\n        E = J.getStyle,\n        P = J.isArray,\n        w = J.isFunction,\n        M = J.isNumber,\n        F = J.isObject,\n        Q = J.isString,\n        e = J.merge,\n        b = J.numberFormat,\n        h = J.objectEach,\n        z = J.pick,\n        x = J.pInt,\n        N = J.relativeLength,\n        aa = J.removeEvent,\n        Z = J.setAnimation,\n        V = J.splat,\n        Y = J.syncTimeout,\n        ba = J.uniqueKey,\n        U = c.marginNames,\n        X = function () {\n      function B(b, a, e) {\n        this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;\n        this.getArgs(b, a, e);\n      }\n\n      B.prototype.getArgs = function (b, a, e) {\n        Q(b) || b.nodeName ? (this.renderTo = b, this.init(a, e)) : this.init(b, a);\n      };\n\n      B.prototype.init = function (a, d) {\n        var f,\n            l = a.series,\n            k = a.plotOptions || {};\n        u(this, \"init\", {\n          args: arguments\n        }, function () {\n          a.series = null;\n          f = e(K, a);\n          var m = f.chart || {};\n          h(f.plotOptions, function (b, a) {\n            F(b) && (b.tooltip = k[a] && e(k[a].tooltip) || void 0);\n          });\n          f.tooltip.userOptions = a.chart && a.chart.forExport && a.tooltip.userOptions || a.tooltip;\n          f.series = a.series = l;\n          this.userOptions = a;\n          var p = m.events;\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = d;\n          this.isResizing = 0;\n          this.options = f;\n          this.axes = [];\n          this.series = [];\n          this.time = a.time && Object.keys(a.time).length ? new D(a.time) : c.time;\n          this.numberFormatter = m.numberFormatter || b;\n          this.styledMode = m.styledMode;\n          this.hasCartesianSeries = m.showAxes;\n          var g = this;\n          g.index = t.length;\n          t.push(g);\n          c.chartCount++;\n          p && h(p, function (b, a) {\n            w(b) && n(g, a, b);\n          });\n          g.xAxis = [];\n          g.yAxis = [];\n          g.pointCount = g.colorCounter = g.symbolCounter = 0;\n          u(g, \"afterInit\");\n          g.firstRender();\n        });\n      };\n\n      B.prototype.initSeries = function (b) {\n        var a = this.options.chart;\n        a = b.type || a.type || a.defaultSeriesType;\n        var e = L[a];\n        e || f(17, !0, this, {\n          missingModuleFor: a\n        });\n        a = new e();\n        a.init(this, b);\n        return a;\n      };\n\n      B.prototype.setSeriesData = function () {\n        this.getSeriesOrderByLinks().forEach(function (b) {\n          b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);\n        });\n      };\n\n      B.prototype.getSeriesOrderByLinks = function () {\n        return this.series.concat().sort(function (b, a) {\n          return b.linkedSeries.length || a.linkedSeries.length ? a.linkedSeries.length - b.linkedSeries.length : 0;\n        });\n      };\n\n      B.prototype.orderSeries = function (b) {\n        var a = this.series;\n\n        for (b = b || 0; b < a.length; b++) a[b] && (a[b].index = b, a[b].name = a[b].getName());\n      };\n\n      B.prototype.isInsidePlot = function (b, a, e) {\n        var d = e ? a : b;\n        b = e ? b : a;\n        d = {\n          x: d,\n          y: b,\n          isInsidePlot: 0 <= d && d <= this.plotWidth && 0 <= b && b <= this.plotHeight\n        };\n        u(this, \"afterIsInsidePlot\", d);\n        return d.isInsidePlot;\n      };\n\n      B.prototype.redraw = function (b) {\n        u(this, \"beforeRedraw\");\n        var e = this,\n            d = e.axes,\n            h = e.series,\n            c = e.pointer,\n            f = e.legend,\n            l = e.userOptions.legend,\n            k = e.isDirtyLegend,\n            m = e.hasCartesianSeries,\n            p = e.isDirtyBox,\n            g = e.renderer,\n            n = g.isHidden(),\n            x = [];\n        e.setResponsive && e.setResponsive(!1);\n        Z(e.hasRendered ? b : !1, e);\n        n && e.temporaryDisplay();\n        e.layOutTitles();\n\n        for (b = h.length; b--;) {\n          var z = h[b];\n\n          if (z.options.stacking) {\n            var w = !0;\n\n            if (z.isDirty) {\n              var r = !0;\n              break;\n            }\n          }\n        }\n\n        if (r) for (b = h.length; b--;) z = h[b], z.options.stacking && (z.isDirty = !0);\n        h.forEach(function (b) {\n          b.isDirty && (\"point\" === b.options.legendType ? (b.updateTotals && b.updateTotals(), k = !0) : l && (l.labelFormatter || l.labelFormat) && (k = !0));\n          b.isDirtyData && u(b, \"updatedData\");\n        });\n        k && f && f.options.enabled && (f.render(), e.isDirtyLegend = !1);\n        w && e.getStacks();\n        m && d.forEach(function (b) {\n          e.isResizing && M(b.min) || (b.updateNames(), b.setScale());\n        });\n        e.getMargins();\n        m && (d.forEach(function (b) {\n          b.isDirty && (p = !0);\n        }), d.forEach(function (b) {\n          var e = b.min + \",\" + b.max;\n          b.extKey !== e && (b.extKey = e, x.push(function () {\n            u(b, \"afterSetExtremes\", a(b.eventArgs, b.getExtremes()));\n            delete b.eventArgs;\n          }));\n          (p || w) && b.redraw();\n        }));\n        p && e.drawChartBox();\n        u(e, \"predraw\");\n        h.forEach(function (b) {\n          (p || b.isDirty) && b.visible && b.redraw();\n          b.isDirtyData = !1;\n        });\n        c && c.reset(!0);\n        g.draw();\n        u(e, \"redraw\");\n        u(e, \"render\");\n        n && e.temporaryDisplay(!0);\n        x.forEach(function (b) {\n          b.call();\n        });\n      };\n\n      B.prototype.get = function (b) {\n        function a(a) {\n          return a.id === b || a.options && a.options.id === b;\n        }\n\n        var e = this.series,\n            d;\n        var h = A(this.axes, a) || A(this.series, a);\n\n        for (d = 0; !h && d < e.length; d++) h = A(e[d].points || [], a);\n\n        return h;\n      };\n\n      B.prototype.getAxes = function () {\n        var b = this,\n            a = this.options,\n            e = a.xAxis = V(a.xAxis || {});\n        a = a.yAxis = V(a.yAxis || {});\n        u(this, \"getAxes\");\n        e.forEach(function (b, a) {\n          b.index = a;\n          b.isX = !0;\n        });\n        a.forEach(function (b, a) {\n          b.index = a;\n        });\n        e.concat(a).forEach(function (a) {\n          new g(b, a);\n        });\n        u(this, \"afterGetAxes\");\n      };\n\n      B.prototype.getSelectedPoints = function () {\n        var b = [];\n        this.series.forEach(function (a) {\n          b = b.concat(a.getPointsCollection().filter(function (b) {\n            return z(b.selectedStaging, b.selected);\n          }));\n        });\n        return b;\n      };\n\n      B.prototype.getSelectedSeries = function () {\n        return this.series.filter(function (b) {\n          return b.selected;\n        });\n      };\n\n      B.prototype.setTitle = function (b, a, e) {\n        this.applyDescription(\"title\", b);\n        this.applyDescription(\"subtitle\", a);\n        this.applyDescription(\"caption\", void 0);\n        this.layOutTitles(e);\n      };\n\n      B.prototype.applyDescription = function (b, a) {\n        var d = this,\n            h = \"title\" === b ? {\n          color: \"#333333\",\n          fontSize: this.options.isStock ? \"16px\" : \"18px\"\n        } : {\n          color: \"#666666\"\n        };\n        h = this.options[b] = e(!this.styledMode && {\n          style: h\n        }, this.options[b], a);\n        var c = this[b];\n        c && a && (this[b] = c = c.destroy());\n        h && !c && (c = this.renderer.text(h.text, 0, 0, h.useHTML).attr({\n          align: h.align,\n          \"class\": \"highcharts-\" + b,\n          zIndex: h.zIndex || 4\n        }).add(), c.update = function (a) {\n          d[{\n            title: \"setTitle\",\n            subtitle: \"setSubtitle\",\n            caption: \"setCaption\"\n          }[b]](a);\n        }, this.styledMode || c.css(h.style), this[b] = c);\n      };\n\n      B.prototype.layOutTitles = function (b) {\n        var e = [0, 0, 0],\n            d = this.renderer,\n            h = this.spacingBox;\n        [\"title\", \"subtitle\", \"caption\"].forEach(function (b) {\n          var c = this[b],\n              f = this.options[b],\n              l = f.verticalAlign || \"top\";\n          b = \"title\" === b ? -3 : \"top\" === l ? e[0] + 2 : 0;\n\n          if (c) {\n            if (!this.styledMode) var k = f.style.fontSize;\n            k = d.fontMetrics(k, c).b;\n            c.css({\n              width: (f.width || h.width + (f.widthAdjust || 0)) + \"px\"\n            });\n            var m = Math.round(c.getBBox(f.useHTML).height);\n            c.align(a({\n              y: \"bottom\" === l ? k : b + k,\n              height: m\n            }, f), !1, \"spacingBox\");\n            f.floating || (\"top\" === l ? e[0] = Math.ceil(e[0] + m) : \"bottom\" === l && (e[2] = Math.ceil(e[2] + m)));\n          }\n        }, this);\n        e[0] && \"top\" === (this.options.title.verticalAlign || \"top\") && (e[0] += this.options.title.margin);\n        e[2] && \"bottom\" === this.options.caption.verticalAlign && (e[2] += this.options.caption.margin);\n        var c = !this.titleOffset || this.titleOffset.join(\",\") !== e.join(\",\");\n        this.titleOffset = e;\n        u(this, \"afterLayOutTitles\");\n        !this.isDirtyBox && c && (this.isDirtyBox = this.isDirtyLegend = c, this.hasRendered && z(b, !0) && this.isDirtyBox && this.redraw());\n      };\n\n      B.prototype.getChartSize = function () {\n        var b = this.options.chart,\n            a = b.width;\n        b = b.height;\n        var e = this.renderTo;\n        d(a) || (this.containerWidth = E(e, \"width\"));\n        d(b) || (this.containerHeight = E(e, \"height\"));\n        this.chartWidth = Math.max(0, a || this.containerWidth || 600);\n        this.chartHeight = Math.max(0, N(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));\n      };\n\n      B.prototype.temporaryDisplay = function (b) {\n        var a = this.renderTo;\n        if (b) for (; a && a.style;) a.hcOrigStyle && (m(a, a.hcOrigStyle), delete a.hcOrigStyle), a.hcOrigDetached && (G.body.removeChild(a), a.hcOrigDetached = !1), a = a.parentNode;else for (; a && a.style;) {\n          G.body.contains(a) || a.parentNode || (a.hcOrigDetached = !0, G.body.appendChild(a));\n          if (\"none\" === E(a, \"display\", !1) || a.hcOricDetached) a.hcOrigStyle = {\n            display: a.style.display,\n            height: a.style.height,\n            overflow: a.style.overflow\n          }, b = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, a !== this.renderTo && (b.height = 0), m(a, b), a.offsetWidth || a.style.setProperty(\"display\", \"block\", \"important\");\n          a = a.parentNode;\n          if (a === G.body) break;\n        }\n      };\n\n      B.prototype.setClassName = function (b) {\n        this.container.className = \"highcharts-container \" + (b || \"\");\n      };\n\n      B.prototype.getContainer = function () {\n        var b = this.options,\n            e = b.chart;\n        var d = this.renderTo;\n        var h = ba(),\n            l,\n            k;\n        d || (this.renderTo = d = e.renderTo);\n        Q(d) && (this.renderTo = d = G.getElementById(d));\n        d || f(13, !0, this);\n        var g = x(I(d, \"data-highcharts-chart\"));\n        M(g) && t[g] && t[g].hasRendered && t[g].destroy();\n        I(d, \"data-highcharts-chart\", this.index);\n        d.innerHTML = \"\";\n        e.skipClone || d.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        g = this.chartWidth;\n        var n = this.chartHeight;\n        m(d, {\n          overflow: \"hidden\"\n        });\n        this.styledMode || (l = a({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: g + \"px\",\n          height: n + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\",\n          userSelect: \"none\"\n        }, e.style));\n        this.container = d = p(\"div\", {\n          id: h\n        }, l, d);\n        this._cursor = d.style.cursor;\n        this.renderer = new (c[e.renderer] || c.Renderer)(d, g, n, null, e.forExport, b.exporting && b.exporting.allowHTML, this.styledMode);\n        Z(void 0, this);\n        this.setClassName(e.className);\n        if (this.styledMode) for (k in b.defs) this.renderer.definition(b.defs[k]);else this.renderer.setStyle(e.style);\n        this.renderer.chartIndex = this.index;\n        u(this, \"afterGetContainer\");\n      };\n\n      B.prototype.getMargins = function (b) {\n        var a = this.spacing,\n            e = this.margin,\n            h = this.titleOffset;\n        this.resetMargins();\n        h[0] && !d(e[0]) && (this.plotTop = Math.max(this.plotTop, h[0] + a[0]));\n        h[2] && !d(e[2]) && (this.marginBottom = Math.max(this.marginBottom, h[2] + a[2]));\n        this.legend && this.legend.display && this.legend.adjustMargins(e, a);\n        u(this, \"getMargins\");\n        b || this.getAxisMargins();\n      };\n\n      B.prototype.getAxisMargins = function () {\n        var b = this,\n            a = b.axisOffset = [0, 0, 0, 0],\n            e = b.colorAxis,\n            h = b.margin,\n            c = function c(b) {\n          b.forEach(function (b) {\n            b.visible && b.getOffset();\n          });\n        };\n\n        b.hasCartesianSeries ? c(b.axes) : e && e.length && c(e);\n        U.forEach(function (e, c) {\n          d(h[c]) || (b[e] += a[c]);\n        });\n        b.setChartSize();\n      };\n\n      B.prototype.reflow = function (b) {\n        var a = this,\n            e = a.options.chart,\n            h = a.renderTo,\n            c = d(e.width) && d(e.height),\n            f = e.width || E(h, \"width\");\n        e = e.height || E(h, \"height\");\n        h = b ? b.target : v;\n\n        if (!c && !a.isPrinting && f && e && (h === v || h === G)) {\n          if (f !== a.containerWidth || e !== a.containerHeight) J.clearTimeout(a.reflowTimeout), a.reflowTimeout = Y(function () {\n            a.container && a.setSize(void 0, void 0, !1);\n          }, b ? 100 : 0);\n          a.containerWidth = f;\n          a.containerHeight = e;\n        }\n      };\n\n      B.prototype.setReflow = function (b) {\n        var a = this;\n        !1 === b || this.unbindReflow ? !1 === b && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = n(v, \"resize\", function (b) {\n          a.options && a.reflow(b);\n        }), n(this, \"destroy\", this.unbindReflow));\n      };\n\n      B.prototype.setSize = function (b, a, e) {\n        var d = this,\n            h = d.renderer;\n        d.isResizing += 1;\n        Z(e, d);\n        e = h.globalAnimation;\n        d.oldChartHeight = d.chartHeight;\n        d.oldChartWidth = d.chartWidth;\n        \"undefined\" !== typeof b && (d.options.chart.width = b);\n        \"undefined\" !== typeof a && (d.options.chart.height = a);\n        d.getChartSize();\n        d.styledMode || (e ? r : m)(d.container, {\n          width: d.chartWidth + \"px\",\n          height: d.chartHeight + \"px\"\n        }, e);\n        d.setChartSize(!0);\n        h.setSize(d.chartWidth, d.chartHeight, e);\n        d.axes.forEach(function (b) {\n          b.isDirty = !0;\n          b.setScale();\n        });\n        d.isDirtyLegend = !0;\n        d.isDirtyBox = !0;\n        d.layOutTitles();\n        d.getMargins();\n        d.redraw(e);\n        d.oldChartHeight = null;\n        u(d, \"resize\");\n        Y(function () {\n          d && u(d, \"endResize\", null, function () {\n            --d.isResizing;\n          });\n        }, C(e).duration || 0);\n      };\n\n      B.prototype.setChartSize = function (b) {\n        var a = this.inverted,\n            e = this.renderer,\n            d = this.chartWidth,\n            h = this.chartHeight,\n            c = this.options.chart,\n            f = this.spacing,\n            l = this.clipOffset,\n            k,\n            m,\n            p,\n            g;\n        this.plotLeft = k = Math.round(this.plotLeft);\n        this.plotTop = m = Math.round(this.plotTop);\n        this.plotWidth = p = Math.max(0, Math.round(d - k - this.marginRight));\n        this.plotHeight = g = Math.max(0, Math.round(h - m - this.marginBottom));\n        this.plotSizeX = a ? g : p;\n        this.plotSizeY = a ? p : g;\n        this.plotBorderWidth = c.plotBorderWidth || 0;\n        this.spacingBox = e.spacingBox = {\n          x: f[3],\n          y: f[0],\n          width: d - f[3] - f[1],\n          height: h - f[0] - f[2]\n        };\n        this.plotBox = e.plotBox = {\n          x: k,\n          y: m,\n          width: p,\n          height: g\n        };\n        d = 2 * Math.floor(this.plotBorderWidth / 2);\n        a = Math.ceil(Math.max(d, l[3]) / 2);\n        e = Math.ceil(Math.max(d, l[0]) / 2);\n        this.clipBox = {\n          x: a,\n          y: e,\n          width: Math.floor(this.plotSizeX - Math.max(d, l[1]) / 2 - a),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(d, l[2]) / 2 - e))\n        };\n        b || this.axes.forEach(function (b) {\n          b.setAxisSize();\n          b.setAxisTranslation();\n        });\n        u(this, \"afterSetChartSize\", {\n          skipAxes: b\n        });\n      };\n\n      B.prototype.resetMargins = function () {\n        u(this, \"resetMargins\");\n        var b = this,\n            a = b.options.chart;\n        [\"margin\", \"spacing\"].forEach(function (e) {\n          var d = a[e],\n              h = F(d) ? d : [d, d, d, d];\n          [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (d, c) {\n            b[e][c] = z(a[e + d], h[c]);\n          });\n        });\n        U.forEach(function (a, e) {\n          b[a] = z(b.margin[e], b.spacing[e]);\n        });\n        b.axisOffset = [0, 0, 0, 0];\n        b.clipOffset = [0, 0, 0, 0];\n      };\n\n      B.prototype.drawChartBox = function () {\n        var b = this.options.chart,\n            a = this.renderer,\n            e = this.chartWidth,\n            d = this.chartHeight,\n            h = this.chartBackground,\n            c = this.plotBackground,\n            f = this.plotBorder,\n            l = this.styledMode,\n            k = this.plotBGImage,\n            m = b.backgroundColor,\n            p = b.plotBackgroundColor,\n            g = b.plotBackgroundImage,\n            n,\n            x = this.plotLeft,\n            z = this.plotTop,\n            w = this.plotWidth,\n            r = this.plotHeight,\n            t = this.plotBox,\n            A = this.clipRect,\n            v = this.clipBox,\n            q = \"animate\";\n        h || (this.chartBackground = h = a.rect().addClass(\"highcharts-background\").add(), q = \"attr\");\n        if (l) var C = n = h.strokeWidth();else {\n          C = b.borderWidth || 0;\n          n = C + (b.shadow ? 8 : 0);\n          m = {\n            fill: m || \"none\"\n          };\n          if (C || h[\"stroke-width\"]) m.stroke = b.borderColor, m[\"stroke-width\"] = C;\n          h.attr(m).shadow(b.shadow);\n        }\n        h[q]({\n          x: n / 2,\n          y: n / 2,\n          width: e - n - C % 2,\n          height: d - n - C % 2,\n          r: b.borderRadius\n        });\n        q = \"animate\";\n        c || (q = \"attr\", this.plotBackground = c = a.rect().addClass(\"highcharts-plot-background\").add());\n        c[q](t);\n        l || (c.attr({\n          fill: p || \"none\"\n        }).shadow(b.plotShadow), g && (k ? (g !== k.attr(\"href\") && k.attr(\"href\", g), k.animate(t)) : this.plotBGImage = a.image(g, x, z, w, r).add()));\n        A ? A.animate({\n          width: v.width,\n          height: v.height\n        }) : this.clipRect = a.clipRect(v);\n        q = \"animate\";\n        f || (q = \"attr\", this.plotBorder = f = a.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        l || f.attr({\n          stroke: b.plotBorderColor,\n          \"stroke-width\": b.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        f[q](f.crisp({\n          x: x,\n          y: z,\n          width: w,\n          height: r\n        }, -f.strokeWidth()));\n        this.isDirtyBox = !1;\n        u(this, \"afterDrawChartBox\");\n      };\n\n      B.prototype.propFromSeries = function () {\n        var b = this,\n            a = b.options.chart,\n            e,\n            d = b.options.series,\n            h,\n            c;\n        [\"inverted\", \"angular\", \"polar\"].forEach(function (f) {\n          e = L[a.type || a.defaultSeriesType];\n          c = a[f] || e && e.prototype[f];\n\n          for (h = d && d.length; !c && h--;) (e = L[d[h].type]) && e.prototype[f] && (c = !0);\n\n          b[f] = c;\n        });\n      };\n\n      B.prototype.linkSeries = function () {\n        var b = this,\n            a = b.series;\n        a.forEach(function (b) {\n          b.linkedSeries.length = 0;\n        });\n        a.forEach(function (a) {\n          var e = a.options.linkedTo;\n          Q(e) && (e = \":previous\" === e ? b.series[a.index - 1] : b.get(e)) && e.linkedParent !== a && (e.linkedSeries.push(a), a.linkedParent = e, e.enabledDataSorting && a.setDataSortingOptions(), a.visible = z(a.options.visible, e.options.visible, a.visible));\n        });\n        u(this, \"afterLinkSeries\");\n      };\n\n      B.prototype.renderSeries = function () {\n        this.series.forEach(function (b) {\n          b.translate();\n          b.render();\n        });\n      };\n\n      B.prototype.renderLabels = function () {\n        var b = this,\n            e = b.options.labels;\n        e.items && e.items.forEach(function (d) {\n          var h = a(e.style, d.style),\n              c = x(h.left) + b.plotLeft,\n              f = x(h.top) + b.plotTop + 12;\n          delete h.left;\n          delete h.top;\n          b.renderer.text(d.html, c, f).attr({\n            zIndex: 2\n          }).css(h).add();\n        });\n      };\n\n      B.prototype.render = function () {\n        var b = this.axes,\n            a = this.colorAxis,\n            e = this.renderer,\n            d = this.options,\n            h = 0,\n            c = function c(b) {\n          b.forEach(function (b) {\n            b.visible && b.render();\n          });\n        };\n\n        this.setTitle();\n        this.legend = new q(this, d.legend);\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        d = this.plotWidth;\n        b.some(function (b) {\n          if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return h = 21, !0;\n        });\n        var f = this.plotHeight = Math.max(this.plotHeight - h, 0);\n        b.forEach(function (b) {\n          b.setScale();\n        });\n        this.getAxisMargins();\n        var l = 1.1 < d / this.plotWidth;\n        var k = 1.05 < f / this.plotHeight;\n        if (l || k) b.forEach(function (b) {\n          (b.horiz && l || !b.horiz && k) && b.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries ? c(b) : a && a.length && c(a);\n        this.seriesGroup || (this.seriesGroup = e.g(\"series-group\").attr({\n          zIndex: 3\n        }).add());\n        this.renderSeries();\n        this.renderLabels();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.updateContainerScaling();\n        this.hasRendered = !0;\n      };\n\n      B.prototype.addCredits = function (b) {\n        var a = this,\n            d = e(!0, this.options.credits, b);\n        d.enabled && !this.credits && (this.credits = this.renderer.text(d.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          d.href && (v.location.href = d.href);\n        }).attr({\n          align: d.position.align,\n          zIndex: 8\n        }), a.styledMode || this.credits.css(d.style), this.credits.add().align(d.position), this.credits.update = function (b) {\n          a.credits = a.credits.destroy();\n          a.addCredits(b);\n        });\n      };\n\n      B.prototype.updateContainerScaling = function () {\n        var b = this.container;\n\n        if (2 < b.offsetWidth && 2 < b.offsetHeight && b.getBoundingClientRect) {\n          var a = b.getBoundingClientRect(),\n              e = a.width / b.offsetWidth;\n          b = a.height / b.offsetHeight;\n          1 !== e || 1 !== b ? this.containerScaling = {\n            scaleX: e,\n            scaleY: b\n          } : delete this.containerScaling;\n        }\n      };\n\n      B.prototype.destroy = function () {\n        var b = this,\n            a = b.axes,\n            e = b.series,\n            d = b.container,\n            f,\n            m = d && d.parentNode;\n        u(b, \"destroy\");\n        b.renderer.forExport ? k(t, b) : t[b.index] = void 0;\n        c.chartCount--;\n        b.renderTo.removeAttribute(\"data-highcharts-chart\");\n        aa(b);\n\n        for (f = a.length; f--;) a[f] = a[f].destroy();\n\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n\n        for (f = e.length; f--;) e[f] = e[f].destroy();\n\n        \"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \").forEach(function (a) {\n          var e = b[a];\n          e && e.destroy && (b[a] = e.destroy());\n        });\n        d && (d.innerHTML = \"\", aa(d), m && l(d));\n        h(b, function (a, e) {\n          delete b[e];\n        });\n      };\n\n      B.prototype.firstRender = function () {\n        var b = this,\n            a = b.options;\n\n        if (!b.isReadyToRender || b.isReadyToRender()) {\n          b.getContainer();\n          b.resetMargins();\n          b.setChartSize();\n          b.propFromSeries();\n          b.getAxes();\n          (P(a.series) ? a.series : []).forEach(function (a) {\n            b.initSeries(a);\n          });\n          b.linkSeries();\n          b.setSeriesData();\n          u(b, \"beforeRender\");\n          H && (b.pointer = c.hasTouch || !v.PointerEvent && !v.MSPointerEvent ? new H(b, a) : new y(b, a));\n          b.render();\n          if (!b.renderer.imgCount && !b.hasLoaded) b.onload();\n          b.temporaryDisplay(!0);\n        }\n      };\n\n      B.prototype.onload = function () {\n        this.callbacks.concat([this.callback]).forEach(function (b) {\n          b && \"undefined\" !== typeof this.index && b.apply(this, [this]);\n        }, this);\n        u(this, \"load\");\n        u(this, \"render\");\n        d(this.index) && this.setReflow(this.options.chart.reflow);\n        this.hasLoaded = !0;\n      };\n\n      return B;\n    }();\n\n    X.prototype.callbacks = [];\n\n    c.chart = function (b, a, e) {\n      return new X(b, a, e);\n    };\n\n    return c.Chart = X;\n  });\n  O(q, \"parts/ScrollablePlotArea.js\", [q[\"parts/Chart.js\"], q[\"parts/Globals.js\"], q[\"parts/Utilities.js\"]], function (g, c, q) {\n    var y = q.addEvent,\n        B = q.createElement,\n        H = q.pick,\n        D = q.stop;\n    \"\";\n    y(g, \"afterSetChartSize\", function (g) {\n      var t = this.options.chart.scrollablePlotArea,\n          q = t && t.minWidth;\n      t = t && t.minHeight;\n\n      if (!this.renderer.forExport) {\n        if (q) {\n          if (this.scrollablePixelsX = q = Math.max(0, q - this.chartWidth)) {\n            this.plotWidth += q;\n            this.inverted ? (this.clipBox.height += q, this.plotBox.height += q) : (this.clipBox.width += q, this.plotBox.width += q);\n            var y = {\n              1: {\n                name: \"right\",\n                value: q\n              }\n            };\n          }\n        } else t && (this.scrollablePixelsY = q = Math.max(0, t - this.chartHeight)) && (this.plotHeight += q, this.inverted ? (this.clipBox.width += q, this.plotBox.width += q) : (this.clipBox.height += q, this.plotBox.height += q), y = {\n          2: {\n            name: \"bottom\",\n            value: q\n          }\n        });\n\n        y && !g.skipAxes && this.axes.forEach(function (g) {\n          y[g.side] ? g.getPlotLinePath = function () {\n            var t = y[g.side].name,\n                n = this[t];\n            this[t] = n - y[g.side].value;\n            var r = c.Axis.prototype.getPlotLinePath.apply(this, arguments);\n            this[t] = n;\n            return r;\n          } : (g.setAxisSize(), g.setAxisTranslation());\n        });\n      }\n    });\n    y(g, \"render\", function () {\n      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n\n    g.prototype.setUpScrolling = function () {\n      var c = this,\n          g = {\n        WebkitOverflowScrolling: \"touch\",\n        overflowX: \"hidden\",\n        overflowY: \"hidden\"\n      };\n      this.scrollablePixelsX && (g.overflowX = \"auto\");\n      this.scrollablePixelsY && (g.overflowY = \"auto\");\n      this.scrollingContainer = B(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, g, this.renderTo);\n      y(this.scrollingContainer, \"scroll\", function () {\n        c.pointer && delete c.pointer.chartPosition;\n      });\n      this.innerContainer = B(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n\n    g.prototype.moveFixedElements = function () {\n      var c = this.container,\n          g = this.fixedRenderer,\n          q = \".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-scrollbar .highcharts-subtitle .highcharts-title\".split(\" \"),\n          y;\n      this.scrollablePixelsX && !this.inverted ? y = \".highcharts-yaxis\" : this.scrollablePixelsX && this.inverted ? y = \".highcharts-xaxis\" : this.scrollablePixelsY && !this.inverted ? y = \".highcharts-xaxis\" : this.scrollablePixelsY && this.inverted && (y = \".highcharts-yaxis\");\n      q.push(y, y + \"-labels\");\n      q.forEach(function (t) {\n        [].forEach.call(c.querySelectorAll(t), function (c) {\n          (c.namespaceURI === g.SVG_NS ? g.box : g.box.parentNode).appendChild(c);\n          c.style.pointerEvents = \"auto\";\n        });\n      });\n    };\n\n    g.prototype.applyFixed = function () {\n      var g,\n          t,\n          q = !this.fixedDiv,\n          L = this.options.chart.scrollablePlotArea;\n      q ? (this.fixedDiv = B(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: 2\n      }, null, !0), this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = t = new c.Renderer(this.fixedDiv, this.chartWidth, this.chartHeight, null === (g = this.options.chart) || void 0 === g ? void 0 : g.style), this.scrollableMask = t.path().attr({\n        fill: this.options.chart.backgroundColor || \"#fff\",\n        \"fill-opacity\": H(L.opacity, .85),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), this.moveFixedElements(), y(this, \"afterShowResetZoom\", this.moveFixedElements), y(this, \"afterLayOutTitles\", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      g = this.chartWidth + (this.scrollablePixelsX || 0);\n      t = this.chartHeight + (this.scrollablePixelsY || 0);\n      D(this.container);\n      this.container.style.width = g + \"px\";\n      this.container.style.height = t + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: g,\n        height: t,\n        viewBox: [0, 0, g, t].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: g,\n        height: t\n      });\n      this.scrollingContainer.style.height = this.chartHeight + \"px\";\n      q && (L.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * L.scrollPositionX), L.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * L.scrollPositionY));\n      t = this.axisOffset;\n      q = this.plotTop - t[0] - 1;\n      L = this.plotLeft - t[3] - 1;\n      g = this.plotTop + this.plotHeight + t[2] + 1;\n      t = this.plotLeft + this.plotWidth + t[1] + 1;\n      var v = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),\n          K = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);\n      q = this.scrollablePixelsX ? [[\"M\", 0, q], [\"L\", this.plotLeft - 1, q], [\"L\", this.plotLeft - 1, g], [\"L\", 0, g], [\"Z\"], [\"M\", v, q], [\"L\", this.chartWidth, q], [\"L\", this.chartWidth, g], [\"L\", v, g], [\"Z\"]] : this.scrollablePixelsY ? [[\"M\", L, 0], [\"L\", L, this.plotTop - 1], [\"L\", t, this.plotTop - 1], [\"L\", t, 0], [\"Z\"], [\"M\", L, K], [\"L\", L, this.chartHeight], [\"L\", t, this.chartHeight], [\"L\", t, K], [\"Z\"]] : [[\"M\", 0, 0]];\n      \"adjustHeight\" !== this.redrawTrigger && this.scrollableMask.attr({\n        d: q\n      });\n    };\n  });\n  O(q, \"parts/StackingAxis.js\", [q[\"parts/Utilities.js\"]], function (g) {\n    var c = g.addEvent,\n        q = g.destroyObjectProperties,\n        y = g.fireEvent,\n        B = g.objectEach,\n        H = g.pick,\n        D = function () {\n      function c(c) {\n        this.oldStacks = {};\n        this.stacks = {};\n        this.stacksTouched = 0;\n        this.axis = c;\n      }\n\n      c.prototype.buildStacks = function () {\n        var c = this.axis,\n            g = c.series,\n            q = H(c.options.reversedStacks, !0),\n            v = g.length,\n            D;\n\n        if (!c.isXAxis) {\n          this.usePercentage = !1;\n\n          for (D = v; D--;) {\n            var n = g[q ? D : v - D - 1];\n            n.setStackedPoints();\n            n.setGroupedPoints();\n          }\n\n          for (D = 0; D < v; D++) g[D].modifyStacks();\n\n          y(c, \"afterBuildStacks\");\n        }\n      };\n\n      c.prototype.cleanStacks = function () {\n        if (!this.axis.isXAxis) {\n          if (this.oldStacks) var c = this.stacks = this.oldStacks;\n          B(c, function (c) {\n            B(c, function (c) {\n              c.cumulative = c.total;\n            });\n          });\n        }\n      };\n\n      c.prototype.resetStacks = function () {\n        var c = this,\n            g = c.stacks;\n        c.axis.isXAxis || B(g, function (g) {\n          B(g, function (q, t) {\n            q.touched < c.stacksTouched ? (q.destroy(), delete g[t]) : (q.total = null, q.cumulative = null);\n          });\n        });\n      };\n\n      c.prototype.renderStackTotals = function () {\n        var c = this.axis.chart,\n            g = c.renderer,\n            q = this.stacks,\n            v = this.stackTotalGroup = this.stackTotalGroup || g.g(\"stack-labels\").attr({\n          visibility: \"visible\",\n          zIndex: 6\n        }).add();\n        v.translate(c.plotLeft, c.plotTop);\n        B(q, function (c) {\n          B(c, function (c) {\n            c.render(v);\n          });\n        });\n      };\n\n      return c;\n    }();\n\n    return function () {\n      function g() {}\n\n      g.compose = function (q) {\n        c(q, \"init\", g.onInit);\n        c(q, \"destroy\", g.onDestroy);\n      };\n\n      g.onDestroy = function () {\n        var c = this.stacking;\n\n        if (c) {\n          var g = c.stacks;\n          B(g, function (c, t) {\n            q(c);\n            g[t] = null;\n          });\n          c && c.stackTotalGroup && c.stackTotalGroup.destroy();\n        }\n      };\n\n      g.onInit = function () {\n        this.stacking || (this.stacking = new D(this));\n      };\n\n      return g;\n    }();\n  });\n  O(q, \"mixins/legend-symbol.js\", [q[\"parts/Globals.js\"], q[\"parts/Utilities.js\"]], function (g, c) {\n    var q = c.merge,\n        y = c.pick;\n    g.LegendSymbolMixin = {\n      drawRectangle: function drawRectangle(c, g) {\n        var q = c.symbolHeight,\n            B = c.options.squareSymbol;\n        g.legendSymbol = this.chart.renderer.rect(B ? (c.symbolWidth - q) / 2 : 0, c.baseline - q + 1, B ? q : c.symbolWidth, q, y(c.options.symbolRadius, q / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(g.legendGroup);\n      },\n      drawLineMarker: function drawLineMarker(c) {\n        var g = this.options,\n            D = g.marker,\n            B = c.symbolWidth,\n            t = c.symbolHeight,\n            G = t / 2,\n            L = this.chart.renderer,\n            v = this.legendGroup;\n        c = c.baseline - Math.round(.3 * c.fontMetrics.b);\n        var K = {};\n        this.chart.styledMode || (K = {\n          \"stroke-width\": g.lineWidth || 0\n        }, g.dashStyle && (K.dashstyle = g.dashStyle));\n        this.legendLine = L.path([\"M\", 0, c, \"L\", B, c]).addClass(\"highcharts-graph\").attr(K).add(v);\n        D && !1 !== D.enabled && B && (g = Math.min(y(D.radius, G), G), 0 === this.symbol.indexOf(\"url\") && (D = q(D, {\n          width: t,\n          height: t\n        }), g = 0), this.legendSymbol = D = L.symbol(this.symbol, B / 2 - g, c - g, 2 * g, 2 * g, D).addClass(\"highcharts-point\").add(v), D.isMarker = !0);\n      }\n    };\n    return g.LegendSymbolMixin;\n  });\n  O(q, \"parts/Point.js\", [q[\"parts/Globals.js\"], q[\"parts/Utilities.js\"]], function (g, c) {\n    var q = c.animObject,\n        y = c.defined,\n        B = c.erase,\n        H = c.extend,\n        D = c.fireEvent,\n        J = c.format,\n        t = c.getNestedProperty,\n        G = c.isArray,\n        L = c.isNumber,\n        v = c.isObject,\n        K = c.syncTimeout,\n        n = c.pick,\n        r = c.removeEvent,\n        C = c.uniqueKey;\n    \"\";\n\n    c = function () {\n      function c() {\n        this.colorIndex = this.category = void 0;\n        this.formatPrefix = \"point\";\n        this.id = void 0;\n        this.isNull = !1;\n        this.percentage = this.options = this.name = void 0;\n        this.selected = !1;\n        this.total = this.series = void 0;\n        this.visible = !0;\n        this.x = void 0;\n      }\n\n      c.prototype.animateBeforeDestroy = function () {\n        var c = this,\n            m = {\n          x: c.startXPos,\n          opacity: 0\n        },\n            d,\n            l = c.getGraphicalProps();\n        l.singular.forEach(function (l) {\n          d = \"dataLabel\" === l;\n          c[l] = c[l].animate(d ? {\n            x: c[l].startXPos,\n            y: c[l].startYPos,\n            opacity: 0\n          } : m);\n        });\n        l.plural.forEach(function (d) {\n          c[d].forEach(function (d) {\n            d.element && d.animate(H({\n              x: c.startXPos\n            }, d.startYPos ? {\n              x: d.startXPos,\n              y: d.startYPos\n            } : {}));\n          });\n        });\n      };\n\n      c.prototype.applyOptions = function (p, m) {\n        var d = this.series,\n            l = d.options.pointValKey || d.pointValKey;\n        p = c.prototype.optionsToObject.call(this, p);\n        H(this, p);\n        this.options = this.options ? H(this.options, p) : p;\n        p.group && delete this.group;\n        p.dataLabels && delete this.dataLabels;\n        l && (this.y = c.prototype.getNestedProperty.call(this, l));\n        this.formatPrefix = (this.isNull = n(this.isValid && !this.isValid(), null === this.x || !L(this.y))) ? \"null\" : \"point\";\n        this.selected && (this.state = \"select\");\n        \"name\" in this && \"undefined\" === typeof m && d.xAxis && d.xAxis.hasNames && (this.x = d.xAxis.nameToX(this));\n        \"undefined\" === typeof this.x && d && (this.x = \"undefined\" === typeof m ? d.autoIncrement(this) : m);\n        return this;\n      };\n\n      c.prototype.destroy = function () {\n        function c() {\n          if (m.graphic || m.dataLabel || m.dataLabels) r(m), m.destroyElements();\n\n          for (a in m) m[a] = null;\n        }\n\n        var m = this,\n            d = m.series,\n            l = d.chart;\n        d = d.options.dataSorting;\n        var k = l.hoverPoints,\n            f = q(m.series.chart.renderer.globalAnimation),\n            a;\n        m.legendItem && l.legend.destroyItem(m);\n        k && (m.setState(), B(k, m), k.length || (l.hoverPoints = null));\n        if (m === l.hoverPoint) m.onMouseOut();\n        d && d.enabled ? (this.animateBeforeDestroy(), K(c, f.duration)) : c();\n        l.pointCount--;\n      };\n\n      c.prototype.destroyElements = function (c) {\n        var m = this;\n        c = m.getGraphicalProps(c);\n        c.singular.forEach(function (d) {\n          m[d] = m[d].destroy();\n        });\n        c.plural.forEach(function (d) {\n          m[d].forEach(function (d) {\n            d.element && d.destroy();\n          });\n          delete m[d];\n        });\n      };\n\n      c.prototype.firePointEvent = function (c, m, d) {\n        var l = this,\n            k = this.series.options;\n        (k.point.events[c] || l.options && l.options.events && l.options.events[c]) && l.importEvents();\n        \"click\" === c && k.allowPointSelect && (d = function d(_d) {\n          l.select && l.select(null, _d.ctrlKey || _d.metaKey || _d.shiftKey);\n        });\n        D(l, c, m, d);\n      };\n\n      c.prototype.getClassName = function () {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (\"undefined\" !== typeof this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      };\n\n      c.prototype.getGraphicalProps = function (c) {\n        var m = this,\n            d = [],\n            l,\n            k = {\n          singular: [],\n          plural: []\n        };\n        c = c || {\n          graphic: 1,\n          dataLabel: 1\n        };\n        c.graphic && d.push(\"graphic\", \"shadowGroup\");\n        c.dataLabel && d.push(\"dataLabel\", \"dataLabelUpper\", \"connector\");\n\n        for (l = d.length; l--;) {\n          var f = d[l];\n          m[f] && k.singular.push(f);\n        }\n\n        [\"dataLabel\", \"connector\"].forEach(function (a) {\n          var d = a + \"s\";\n          c[a] && m[d] && k.plural.push(d);\n        });\n        return k;\n      };\n\n      c.prototype.getLabelConfig = function () {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      };\n\n      c.prototype.getNestedProperty = function (c) {\n        if (c) return 0 === c.indexOf(\"custom.\") ? t(c, this.options) : this[c];\n      };\n\n      c.prototype.getZone = function () {\n        var c = this.series,\n            m = c.zones;\n        c = c.zoneAxis || \"y\";\n        var d = 0,\n            l;\n\n        for (l = m[d]; this[c] >= l.value;) l = m[++d];\n\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = l && l.color && !this.options.color ? l.color : this.nonZonedColor;\n        return l;\n      };\n\n      c.prototype.hasNewShapeType = function () {\n        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;\n      };\n\n      c.prototype.init = function (c, m, d) {\n        this.series = c;\n        this.applyOptions(m, d);\n        this.id = y(this.id) ? this.id : C();\n        this.resolveColor();\n        c.chart.pointCount++;\n        D(this, \"afterInit\");\n        return this;\n      };\n\n      c.prototype.optionsToObject = function (g) {\n        var m = {},\n            d = this.series,\n            l = d.options.keys,\n            k = l || d.pointArrayMap || [\"y\"],\n            f = k.length,\n            a = 0,\n            p = 0;\n        if (L(g) || null === g) m[k[0]] = g;else if (G(g)) for (!l && g.length > f && (d = typeof g[0], \"string\" === d ? m.name = g[0] : \"number\" === d && (m.x = g[0]), a++); p < f;) l && \"undefined\" === typeof g[a] || (0 < k[p].indexOf(\".\") ? c.prototype.setNestedProperty(m, g[a], k[p]) : m[k[p]] = g[a]), a++, p++;else \"object\" === typeof g && (m = g, g.dataLabels && (d._hasPointLabels = !0), g.marker && (d._hasPointMarkers = !0));\n        return m;\n      };\n\n      c.prototype.resolveColor = function () {\n        var c = this.series;\n        var m = c.chart.options.chart.colorCount;\n        var d = c.chart.styledMode;\n        delete this.nonZonedColor;\n        d || this.options.color || (this.color = c.color);\n        c.options.colorByPoint ? (d || (m = c.options.colors || c.chart.options.colors, this.color = this.color || m[c.colorCounter], m = m.length), d = c.colorCounter, c.colorCounter++, c.colorCounter === m && (c.colorCounter = 0)) : d = c.colorIndex;\n        this.colorIndex = n(this.colorIndex, d);\n      };\n\n      c.prototype.setNestedProperty = function (c, m, d) {\n        d.split(\".\").reduce(function (d, c, f, a) {\n          d[c] = a.length - 1 === f ? m : v(d[c], !0) ? d[c] : {};\n          return d[c];\n        }, c);\n        return c;\n      };\n\n      c.prototype.tooltipFormatter = function (c) {\n        var m = this.series,\n            d = m.tooltipOptions,\n            l = n(d.valueDecimals, \"\"),\n            k = d.valuePrefix || \"\",\n            f = d.valueSuffix || \"\";\n        m.chart.styledMode && (c = m.chart.tooltip.styledModeFormat(c));\n        (m.pointArrayMap || [\"y\"]).forEach(function (a) {\n          a = \"{point.\" + a;\n          if (k || f) c = c.replace(RegExp(a + \"}\", \"g\"), k + a + \"}\" + f);\n          c = c.replace(RegExp(a + \"}\", \"g\"), a + \":,.\" + l + \"f}\");\n        });\n        return J(c, {\n          point: this,\n          series: this.series\n        }, m.chart);\n      };\n\n      return c;\n    }();\n\n    return g.Point = c;\n  });\n  O(q, \"parts/Series.js\", [q[\"parts/Globals.js\"], q[\"mixins/legend-symbol.js\"], q[\"parts/Options.js\"], q[\"parts/Point.js\"], q[\"parts/SVGElement.js\"], q[\"parts/Utilities.js\"]], function (g, c, q, y, B, H) {\n    var D = q.defaultOptions,\n        J = H.addEvent,\n        t = H.animObject,\n        G = H.arrayMax,\n        L = H.arrayMin,\n        v = H.clamp,\n        K = H.correctFloat,\n        n = H.defined,\n        r = H.erase,\n        C = H.error,\n        I = H.extend,\n        p = H.find,\n        m = H.fireEvent,\n        d = H.getNestedProperty,\n        l = H.isArray,\n        k = H.isFunction,\n        f = H.isNumber,\n        a = H.isString,\n        A = H.merge,\n        u = H.objectEach,\n        E = H.pick,\n        P = H.removeEvent;\n    q = H.seriesType;\n    var w = H.splat,\n        M = H.syncTimeout;\n    \"\";\n    var F = g.seriesTypes,\n        Q = g.win;\n    g.Series = q(\"line\", null, {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      crisp: !0,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      events: {},\n      marker: {\n        enabledThreshold: 2,\n        lineColor: \"#ffffff\",\n        lineWidth: 0,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 50\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        align: \"center\",\n        formatter: function formatter() {\n          var a = this.series.chart.numberFormatter;\n          return \"number\" !== typeof this.y ? \"\" : a(this.y, -1);\n        },\n        padding: 5,\n        style: {\n          fontSize: \"11px\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0\n      },\n      cropThreshold: 300,\n      opacity: 1,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 50\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        },\n        inactive: {\n          animation: {\n            duration: 50\n          },\n          opacity: .2\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    }, {\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      coll: \"series\",\n      colorCounter: 0,\n      cropShoulder: 1,\n      directTouch: !1,\n      eventsToUnbind: [],\n      isCartesian: !0,\n      parallelArrays: [\"x\", \"y\"],\n      pointClass: y,\n      requireSorting: !0,\n      sorted: !0,\n      init: function init(a, b) {\n        m(this, \"init\", {\n          options: b\n        });\n        var e = this,\n            d = a.series,\n            c;\n        this.eventOptions = this.eventOptions || {};\n        e.chart = a;\n        e.options = b = e.setOptions(b);\n        e.linkedSeries = [];\n        e.bindAxes();\n        I(e, {\n          name: b.name,\n          state: \"\",\n          visible: !1 !== b.visible,\n          selected: !0 === b.selected\n        });\n        var f = b.events;\n        u(f, function (b, a) {\n          k(b) && e.eventOptions[a] !== b && (k(e.eventOptions[a]) && P(e, a, e.eventOptions[a]), e.eventOptions[a] = b, J(e, a, b));\n        });\n        if (f && f.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0;\n        e.getColor();\n        e.getSymbol();\n        e.parallelArrays.forEach(function (b) {\n          e[b + \"Data\"] || (e[b + \"Data\"] = []);\n        });\n        e.isCartesian && (a.hasCartesianSeries = !0);\n        d.length && (c = d[d.length - 1]);\n        e._i = E(c && c._i, -1) + 1;\n        e.opacity = e.options.opacity;\n        a.orderSeries(this.insert(d));\n        b.dataSorting && b.dataSorting.enabled ? e.setDataSortingOptions() : e.points || e.data || e.setData(b.data, !1);\n        m(this, \"afterInit\");\n      },\n      is: function is(a) {\n        return F[a] && this instanceof F[a];\n      },\n      insert: function insert(a) {\n        var b = this.options.index,\n            e;\n\n        if (f(b)) {\n          for (e = a.length; e--;) if (b >= E(a[e].options.index, a[e]._i)) {\n            a.splice(e + 1, 0, this);\n            break;\n          }\n\n          -1 === e && a.unshift(this);\n          e += 1;\n        } else a.push(this);\n\n        return E(e, a.length - 1);\n      },\n      bindAxes: function bindAxes() {\n        var a = this,\n            b = a.options,\n            d = a.chart,\n            c;\n        m(this, \"bindAxes\", null, function () {\n          (a.axisTypes || []).forEach(function (e) {\n            d[e].forEach(function (d) {\n              c = d.options;\n              if (b[e] === c.index || \"undefined\" !== typeof b[e] && b[e] === c.id || \"undefined\" === typeof b[e] && 0 === c.index) a.insert(d.series), a[e] = d, d.isDirty = !0;\n            });\n            a[e] || a.optionalAxis === e || C(18, !0, d);\n          });\n        });\n        m(this, \"afterBindAxes\");\n      },\n      updateParallelArrays: function updateParallelArrays(a, b) {\n        var e = a.series,\n            d = arguments,\n            c = f(b) ? function (d) {\n          var c = \"y\" === d && e.toYData ? e.toYData(a) : a[d];\n          e[d + \"Data\"][b] = c;\n        } : function (a) {\n          Array.prototype[b].apply(e[a + \"Data\"], Array.prototype.slice.call(d, 2));\n        };\n        e.parallelArrays.forEach(c);\n      },\n      hasData: function hasData() {\n        return this.visible && \"undefined\" !== typeof this.dataMax && \"undefined\" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;\n      },\n      autoIncrement: function autoIncrement() {\n        var a = this.options,\n            b = this.xIncrement,\n            d,\n            c = a.pointIntervalUnit,\n            f = this.chart.time;\n        b = E(b, a.pointStart, 0);\n        this.pointInterval = d = E(this.pointInterval, a.pointInterval, 1);\n        c && (a = new f.Date(b), \"day\" === c ? f.set(\"Date\", a, f.get(\"Date\", a) + d) : \"month\" === c ? f.set(\"Month\", a, f.get(\"Month\", a) + d) : \"year\" === c && f.set(\"FullYear\", a, f.get(\"FullYear\", a) + d), d = a.getTime() - b);\n        this.xIncrement = b + d;\n        return b;\n      },\n      setDataSortingOptions: function setDataSortingOptions() {\n        var a = this.options;\n        I(this, {\n          requireSorting: !1,\n          sorted: !1,\n          enabledDataSorting: !0,\n          allowDG: !1\n        });\n        n(a.pointRange) || (a.pointRange = 1);\n      },\n      setOptions: function setOptions(a) {\n        var b = this.chart,\n            e = b.options,\n            d = e.plotOptions,\n            c = b.userOptions || {};\n        a = A(a);\n        b = b.styledMode;\n        var f = {\n          plotOptions: d,\n          userOptions: a\n        };\n        m(this, \"setOptions\", f);\n        var l = f.plotOptions[this.type],\n            k = c.plotOptions || {};\n        this.userOptions = f.userOptions;\n        c = A(l, d.series, c.plotOptions && c.plotOptions[this.type], a);\n        this.tooltipOptions = A(D.tooltip, D.plotOptions.series && D.plotOptions.series.tooltip, D.plotOptions[this.type].tooltip, e.tooltip.userOptions, d.series && d.series.tooltip, d[this.type].tooltip, a.tooltip);\n        this.stickyTracking = E(a.stickyTracking, k[this.type] && k[this.type].stickyTracking, k.series && k.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : c.stickyTracking);\n        null === l.marker && delete c.marker;\n        this.zoneAxis = c.zoneAxis;\n        e = this.zones = (c.zones || []).slice();\n        !c.negativeColor && !c.negativeFillColor || c.zones || (d = {\n          value: c[this.zoneAxis + \"Threshold\"] || c.threshold || 0,\n          className: \"highcharts-negative\"\n        }, b || (d.color = c.negativeColor, d.fillColor = c.negativeFillColor), e.push(d));\n        e.length && n(e[e.length - 1].value) && e.push(b ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        m(this, \"afterSetOptions\", {\n          options: c\n        });\n        return c;\n      },\n      getName: function getName() {\n        return E(this.options.name, \"Series \" + (this.index + 1));\n      },\n      getCyclic: function getCyclic(a, b, d) {\n        var e = this.chart,\n            c = this.userOptions,\n            h = a + \"Index\",\n            f = a + \"Counter\",\n            l = d ? d.length : E(e.options.chart[a + \"Count\"], e[a + \"Count\"]);\n\n        if (!b) {\n          var k = E(c[h], c[\"_\" + h]);\n          n(k) || (e.series.length || (e[f] = 0), c[\"_\" + h] = k = e[f] % l, e[f] += 1);\n          d && (b = d[k]);\n        }\n\n        \"undefined\" !== typeof k && (this[h] = k);\n        this[a] = b;\n      },\n      getColor: function getColor() {\n        this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.options.color = null : this.getCyclic(\"color\", this.options.color || D.plotOptions[this.type].color, this.chart.options.colors);\n      },\n      getPointsCollection: function getPointsCollection() {\n        return (this.hasGroupedData ? this.points : this.data) || [];\n      },\n      getSymbol: function getSymbol() {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      },\n      findPointIndex: function findPointIndex(a, b) {\n        var e = a.id,\n            d = a.x,\n            c = this.points,\n            l,\n            k = this.options.dataSorting;\n        if (e) var m = this.chart.get(e);else if (this.linkedParent || this.enabledDataSorting) {\n          var g = k && k.matchByName ? \"name\" : \"index\";\n          m = p(c, function (b) {\n            return !b.touched && b[g] === a[g];\n          });\n          if (!m) return;\n        }\n\n        if (m) {\n          var n = m && m.index;\n          \"undefined\" !== typeof n && (l = !0);\n        }\n\n        \"undefined\" === typeof n && f(d) && (n = this.xData.indexOf(d, b));\n        -1 !== n && \"undefined\" !== typeof n && this.cropped && (n = n >= this.cropStart ? n - this.cropStart : n);\n        !l && c[n] && c[n].touched && (n = void 0);\n        return n;\n      },\n      drawLegendSymbol: c.drawLineMarker,\n      updateData: function updateData(a, b) {\n        var e = this.options,\n            d = e.dataSorting,\n            c = this.points,\n            l = [],\n            k,\n            m,\n            g,\n            p = this.requireSorting,\n            u = a.length === c.length,\n            w = !0;\n        this.xIncrement = null;\n        a.forEach(function (b, a) {\n          var h = n(b) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, b) || {};\n          var m = h.x;\n\n          if (h.id || f(m)) {\n            if (m = this.findPointIndex(h, g), -1 === m || \"undefined\" === typeof m ? l.push(b) : c[m] && b !== e.data[m] ? (c[m].update(b, !1, null, !1), c[m].touched = !0, p && (g = m + 1)) : c[m] && (c[m].touched = !0), !u || a !== m || d && d.enabled || this.hasDerivedData) k = !0;\n          } else l.push(b);\n        }, this);\n        if (k) for (a = c.length; a--;) (m = c[a]) && !m.touched && m.remove && m.remove(!1, b);else !u || d && d.enabled ? w = !1 : (a.forEach(function (b, a) {\n          c[a].update && b !== c[a].y && c[a].update(b, !1, null, !1);\n        }), l.length = 0);\n        c.forEach(function (b) {\n          b && (b.touched = !1);\n        });\n        if (!w) return !1;\n        l.forEach(function (b) {\n          this.addPoint(b, !1, null, null, !1);\n        }, this);\n        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = G(this.xData), this.autoIncrement());\n        return !0;\n      },\n      setData: function setData(e, b, d, c) {\n        var h = this,\n            k = h.points,\n            m = k && k.length || 0,\n            g,\n            p = h.options,\n            n = h.chart,\n            u = p.dataSorting,\n            w = null,\n            z = h.xAxis;\n        w = p.turboThreshold;\n        var r = this.xData,\n            q = this.yData,\n            A = (g = h.pointArrayMap) && g.length,\n            t = p.keys,\n            v = 0,\n            F = 1,\n            M;\n        e = e || [];\n        g = e.length;\n        b = E(b, !0);\n        u && u.enabled && (e = this.sortData(e));\n        !1 !== c && g && m && !h.cropped && !h.hasGroupedData && h.visible && !h.isSeriesBoosting && (M = this.updateData(e, d));\n\n        if (!M) {\n          h.xIncrement = null;\n          h.colorCounter = 0;\n          this.parallelArrays.forEach(function (b) {\n            h[b + \"Data\"].length = 0;\n          });\n          if (w && g > w) {\n            if (w = h.getFirstValidPoint(e), f(w)) for (d = 0; d < g; d++) r[d] = this.autoIncrement(), q[d] = e[d];else if (l(w)) {\n              if (A) for (d = 0; d < g; d++) c = e[d], r[d] = c[0], q[d] = c.slice(1, A + 1);else for (t && (v = t.indexOf(\"x\"), F = t.indexOf(\"y\"), v = 0 <= v ? v : 0, F = 0 <= F ? F : 1), d = 0; d < g; d++) c = e[d], r[d] = c[v], q[d] = c[F];\n            } else C(12, !1, n);\n          } else for (d = 0; d < g; d++) \"undefined\" !== typeof e[d] && (c = {\n            series: h\n          }, h.pointClass.prototype.applyOptions.apply(c, [e[d]]), h.updateParallelArrays(c, d));\n          q && a(q[0]) && C(14, !0, n);\n          h.data = [];\n          h.options.data = h.userOptions.data = e;\n\n          for (d = m; d--;) k[d] && k[d].destroy && k[d].destroy();\n\n          z && (z.minRange = z.userMinRange);\n          h.isDirty = n.isDirtyBox = !0;\n          h.isDirtyData = !!k;\n          d = !1;\n        }\n\n        \"point\" === p.legendType && (this.processData(), this.generatePoints());\n        b && n.redraw(d);\n      },\n      sortData: function sortData(a) {\n        var b = this,\n            e = b.options.dataSorting.sortKey || \"y\",\n            c = function c(b, a) {\n          return n(a) && b.pointClass.prototype.optionsToObject.call({\n            series: b\n          }, a) || {};\n        };\n\n        a.forEach(function (e, d) {\n          a[d] = c(b, e);\n          a[d].index = d;\n        }, this);\n        a.concat().sort(function (b, a) {\n          b = d(e, b);\n          a = d(e, a);\n          return a < b ? -1 : a > b ? 1 : 0;\n        }).forEach(function (b, a) {\n          b.x = a;\n        }, this);\n        b.linkedSeries && b.linkedSeries.forEach(function (b) {\n          var e = b.options,\n              d = e.data;\n          e.dataSorting && e.dataSorting.enabled || !d || (d.forEach(function (e, h) {\n            d[h] = c(b, e);\n            a[h] && (d[h].x = a[h].x, d[h].index = h);\n          }), b.setData(d, !1));\n        });\n        return a;\n      },\n      getProcessedData: function getProcessedData(a) {\n        var b = this.xData,\n            e = this.yData,\n            d = b.length;\n        var c = 0;\n        var f = this.xAxis,\n            l = this.options;\n        var k = l.cropThreshold;\n        var m = a || this.getExtremesFromAll || l.getExtremesFromAll,\n            g = this.isCartesian;\n        a = f && f.val2lin;\n        l = !(!f || !f.logarithmic);\n        var p = this.requireSorting;\n\n        if (f) {\n          f = f.getExtremes();\n          var n = f.min;\n          var w = f.max;\n        }\n\n        if (g && this.sorted && !m && (!k || d > k || this.forceCrop)) if (b[d - 1] < n || b[0] > w) b = [], e = [];else if (this.yData && (b[0] < n || b[d - 1] > w)) {\n          c = this.cropData(this.xData, this.yData, n, w);\n          b = c.xData;\n          e = c.yData;\n          c = c.start;\n          var u = !0;\n        }\n\n        for (k = b.length || 1; --k;) if (d = l ? a(b[k]) - a(b[k - 1]) : b[k] - b[k - 1], 0 < d && (\"undefined\" === typeof r || d < r)) var r = d;else 0 > d && p && (C(15, !1, this.chart), p = !1);\n\n        return {\n          xData: b,\n          yData: e,\n          cropped: u,\n          cropStart: c,\n          closestPointRange: r\n        };\n      },\n      processData: function processData(a) {\n        var b = this.xAxis;\n        if (this.isCartesian && !this.isDirty && !b.isDirty && !this.yAxis.isDirty && !a) return !1;\n        a = this.getProcessedData();\n        this.cropped = a.cropped;\n        this.cropStart = a.cropStart;\n        this.processedXData = a.xData;\n        this.processedYData = a.yData;\n        this.closestPointRange = this.basePointRange = a.closestPointRange;\n      },\n      cropData: function cropData(a, b, d, c, f) {\n        var e = a.length,\n            h = 0,\n            k = e,\n            l;\n        f = E(f, this.cropShoulder);\n\n        for (l = 0; l < e; l++) if (a[l] >= d) {\n          h = Math.max(0, l - f);\n          break;\n        }\n\n        for (d = l; d < e; d++) if (a[d] > c) {\n          k = d + f;\n          break;\n        }\n\n        return {\n          xData: a.slice(h, k),\n          yData: b.slice(h, k),\n          start: h,\n          end: k\n        };\n      },\n      generatePoints: function generatePoints() {\n        var a = this.options,\n            b = a.data,\n            d = this.data,\n            c,\n            f = this.processedXData,\n            k = this.processedYData,\n            l = this.pointClass,\n            g = f.length,\n            p = this.cropStart || 0,\n            n = this.hasGroupedData;\n        a = a.keys;\n        var u = [],\n            r;\n        d || n || (d = [], d.length = b.length, d = this.data = d);\n        a && n && (this.options.keys = !1);\n\n        for (r = 0; r < g; r++) {\n          var q = p + r;\n\n          if (n) {\n            var A = new l().init(this, [f[r]].concat(w(k[r])));\n            A.dataGroup = this.groupMap[r];\n            A.dataGroup.options && (A.options = A.dataGroup.options, I(A, A.dataGroup.options), delete A.dataLabels);\n          } else (A = d[q]) || \"undefined\" === typeof b[q] || (d[q] = A = new l().init(this, b[q], f[r]));\n\n          A && (A.index = q, u[r] = A);\n        }\n\n        this.options.keys = a;\n        if (d && (g !== (c = d.length) || n)) for (r = 0; r < c; r++) r !== p || n || (r += g), d[r] && (d[r].destroyElements(), d[r].plotX = void 0);\n        this.data = d;\n        this.points = u;\n        m(this, \"afterGeneratePoints\");\n      },\n      getXExtremes: function getXExtremes(a) {\n        return {\n          min: L(a),\n          max: G(a)\n        };\n      },\n      getExtremes: function getExtremes(a, b) {\n        var d = this.xAxis,\n            e = this.yAxis,\n            c = this.processedXData || this.xData,\n            k = [],\n            g = 0,\n            p = 0;\n        var n = 0;\n        var w = this.requireSorting ? this.cropShoulder : 0,\n            u = e ? e.positiveValuesOnly : !1,\n            r;\n        a = a || this.stackedYData || this.processedYData || [];\n        e = a.length;\n        d && (n = d.getExtremes(), p = n.min, n = n.max);\n\n        for (r = 0; r < e; r++) {\n          var q = c[r];\n          var A = a[r];\n          var t = (f(A) || l(A)) && (A.length || 0 < A || !u);\n          q = b || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !d || (c[r + w] || q) >= p && (c[r - w] || q) <= n;\n          if (t && q) if (t = A.length) for (; t--;) f(A[t]) && (k[g++] = A[t]);else k[g++] = A;\n        }\n\n        a = {\n          dataMin: L(k),\n          dataMax: G(k)\n        };\n        m(this, \"afterGetExtremes\", {\n          dataExtremes: a\n        });\n        return a;\n      },\n      applyExtremes: function applyExtremes() {\n        var a = this.getExtremes();\n        this.dataMin = a.dataMin;\n        this.dataMax = a.dataMax;\n        return a;\n      },\n      getFirstValidPoint: function getFirstValidPoint(a) {\n        for (var b = null, d = a.length, e = 0; null === b && e < d;) b = a[e], e++;\n\n        return b;\n      },\n      translate: function translate() {\n        this.processedXData || this.processData();\n        this.generatePoints();\n        var a = this.options,\n            b = a.stacking,\n            d = this.xAxis,\n            c = d.categories,\n            k = this.enabledDataSorting,\n            g = this.yAxis,\n            p = this.points,\n            w = p.length,\n            u = !!this.modifyValue,\n            r,\n            q = this.pointPlacementToXValue(),\n            A = !!q,\n            t = a.threshold,\n            C = a.startFromThreshold ? t : 0,\n            F,\n            M = this.zoneAxis || \"y\",\n            y = Number.MAX_VALUE;\n\n        for (r = 0; r < w; r++) {\n          var I = p[r],\n              D = I.x,\n              B = I.y,\n              G = I.low,\n              P = b && g.stacking && g.stacking.stacks[(this.negStacks && B < (C ? 0 : t) ? \"-\" : \"\") + this.stackKey];\n          g.positiveValuesOnly && null !== B && 0 >= B && (I.isNull = !0);\n          I.plotX = F = K(v(d.translate(D, 0, 0, 0, 1, q, \"flags\" === this.type), -1E5, 1E5));\n\n          if (b && this.visible && P && P[D]) {\n            var H = this.getStackIndicator(H, D, this.index);\n\n            if (!I.isNull) {\n              var Q = P[D];\n              var J = Q.points[H.key];\n            }\n          }\n\n          l(J) && (G = J[0], B = J[1], G === C && H.key === P[D].base && (G = E(f(t) && t, g.min)), g.positiveValuesOnly && 0 >= G && (G = null), I.total = I.stackTotal = Q.total, I.percentage = Q.total && I.y / Q.total * 100, I.stackY = B, this.irregularWidths || Q.setOffset(this.pointXOffset || 0, this.barW || 0));\n          I.yBottom = n(G) ? v(g.translate(G, 0, 1, 0, 1), -1E5, 1E5) : null;\n          u && (B = this.modifyValue(B, I));\n          I.plotY = \"number\" === typeof B && Infinity !== B ? v(g.translate(B, 0, 1, 0, 1), -1E5, 1E5) : void 0;\n          I.isInside = this.isPointInside(I);\n          I.clientX = A ? K(d.translate(D, 0, 0, 0, 1, q)) : F;\n          I.negative = I[M] < (a[M + \"Threshold\"] || t || 0);\n          I.category = c && \"undefined\" !== typeof c[I.x] ? c[I.x] : I.x;\n\n          if (!I.isNull && !1 !== I.visible) {\n            \"undefined\" !== typeof L && (y = Math.min(y, Math.abs(F - L)));\n            var L = F;\n          }\n\n          I.zone = this.zones.length && I.getZone();\n          !I.graphic && this.group && k && (I.isNew = !0);\n        }\n\n        this.closestPointRangePx = y;\n        m(this, \"afterTranslate\");\n      },\n      getValidPoints: function getValidPoints(a, b, d) {\n        var e = this.chart;\n        return (a || this.points || []).filter(function (a) {\n          return b && !e.isInsidePlot(a.plotX, a.plotY, e.inverted) ? !1 : !1 !== a.visible && (d || !a.isNull);\n        });\n      },\n      getClipBox: function getClipBox(a, b) {\n        var d = this.options,\n            e = this.chart,\n            c = e.inverted,\n            f = this.xAxis,\n            k = f && this.yAxis,\n            l = e.options.chart.scrollablePlotArea || {};\n        a && !1 === d.clip && k ? a = c ? {\n          y: -e.chartWidth + k.len + k.pos,\n          height: e.chartWidth,\n          width: e.chartHeight,\n          x: -e.chartHeight + f.len + f.pos\n        } : {\n          y: -k.pos,\n          height: e.chartHeight,\n          width: e.chartWidth,\n          x: -f.pos\n        } : (a = this.clipBox || e.clipBox, b && (a.width = e.plotSizeX, a.x = (e.scrollablePixelsX || 0) * (l.scrollPositionX || 0)));\n        return b ? {\n          width: a.width,\n          x: a.x\n        } : a;\n      },\n      setClip: function setClip(a) {\n        var b = this.chart,\n            d = this.options,\n            e = b.renderer,\n            c = b.inverted,\n            f = this.clipBox,\n            k = this.getClipBox(a),\n            l = this.sharedClipKey || [\"_sharedClip\", a && a.duration, a && a.easing, k.height, d.xAxis, d.yAxis].join(),\n            m = b[l],\n            g = b[l + \"m\"];\n        a && (k.width = 0, c && (k.x = b.plotHeight + (!1 !== d.clip ? 0 : b.plotTop)));\n        m ? b.hasLoaded || m.attr(k) : (a && (b[l + \"m\"] = g = e.clipRect(c ? b.plotSizeX + 99 : -99, c ? -b.plotLeft : -b.plotTop, 99, c ? b.chartWidth : b.chartHeight)), b[l] = m = e.clipRect(k), m.count = {\n          length: 0\n        });\n        a && !m.count[this.index] && (m.count[this.index] = !0, m.count.length += 1);\n        if (!1 !== d.clip || a) this.group.clip(a || f ? m : b.clipRect), this.markerGroup.clip(g), this.sharedClipKey = l;\n        a || (m.count[this.index] && (delete m.count[this.index], --m.count.length), 0 === m.count.length && l && b[l] && (f || (b[l] = b[l].destroy()), b[l + \"m\"] && (b[l + \"m\"] = b[l + \"m\"].destroy())));\n      },\n      animate: function animate(a) {\n        var b = this.chart,\n            d = t(this.options.animation);\n        if (!b.hasRendered) if (a) this.setClip(d);else {\n          var e = this.sharedClipKey;\n          a = b[e];\n          var c = this.getClipBox(d, !0);\n          a && a.animate(c, d);\n          b[e + \"m\"] && b[e + \"m\"].animate({\n            width: c.width + 99,\n            x: c.x - (b.inverted ? 0 : 99)\n          }, d);\n        }\n      },\n      afterAnimate: function afterAnimate() {\n        this.setClip();\n        m(this, \"afterAnimate\");\n        this.finishedAnimating = !0;\n      },\n      drawPoints: function drawPoints() {\n        var a = this.points,\n            b = this.chart,\n            d,\n            c,\n            f = this.options.marker,\n            k = this[this.specialGroup] || this.markerGroup,\n            l = this.xAxis,\n            m = E(f.enabled, !l || l.isRadial ? !0 : null, this.closestPointRangePx >= f.enabledThreshold * f.radius);\n        if (!1 !== f.enabled || this._hasPointMarkers) for (d = 0; d < a.length; d++) {\n          var g = a[d];\n          var p = (c = g.graphic) ? \"animate\" : \"attr\";\n          var n = g.marker || {};\n          var w = !!g.marker;\n\n          if ((m && \"undefined\" === typeof n.enabled || n.enabled) && !g.isNull && !1 !== g.visible) {\n            var u = E(n.symbol, this.symbol);\n            var r = this.markerAttribs(g, g.selected && \"select\");\n            this.enabledDataSorting && (g.startXPos = l.reversed ? -r.width : l.width);\n            var q = !1 !== g.isInside;\n            c ? c[q ? \"show\" : \"hide\"](q).animate(r) : q && (0 < r.width || g.hasImage) && (g.graphic = c = b.renderer.symbol(u, r.x, r.y, r.width, r.height, w ? n : f).add(k), this.enabledDataSorting && b.hasRendered && (c.attr({\n              x: g.startXPos\n            }), p = \"animate\"));\n            c && \"animate\" === p && c[q ? \"show\" : \"hide\"](q).animate(r);\n            if (c && !b.styledMode) c[p](this.pointAttribs(g, g.selected && \"select\"));\n            c && c.addClass(g.getClassName(), !0);\n          } else c && (g.graphic = c.destroy());\n        }\n      },\n      markerAttribs: function markerAttribs(a, b) {\n        var d = this.options,\n            e = d.marker,\n            c = a.marker || {},\n            f = c.symbol || e.symbol,\n            k = E(c.radius, e.radius);\n        b && (e = e.states[b], b = c.states && c.states[b], k = E(b && b.radius, e && e.radius, k + (e && e.radiusPlus || 0)));\n        a.hasImage = f && 0 === f.indexOf(\"url\");\n        a.hasImage && (k = 0);\n        a = {\n          x: d.crisp ? Math.floor(a.plotX) - k : a.plotX - k,\n          y: a.plotY - k\n        };\n        k && (a.width = a.height = 2 * k);\n        return a;\n      },\n      pointAttribs: function pointAttribs(a, b) {\n        var d = this.options.marker,\n            e = a && a.options,\n            c = e && e.marker || {},\n            f = this.color,\n            k = e && e.color,\n            l = a && a.color;\n        e = E(c.lineWidth, d.lineWidth);\n        var m = a && a.zone && a.zone.color;\n        a = 1;\n        f = k || m || l || f;\n        k = c.fillColor || d.fillColor || f;\n        f = c.lineColor || d.lineColor || f;\n        b = b || \"normal\";\n        d = d.states[b];\n        b = c.states && c.states[b] || {};\n        e = E(b.lineWidth, d.lineWidth, e + E(b.lineWidthPlus, d.lineWidthPlus, 0));\n        k = b.fillColor || d.fillColor || k;\n        f = b.lineColor || d.lineColor || f;\n        a = E(b.opacity, d.opacity, a);\n        return {\n          stroke: f,\n          \"stroke-width\": e,\n          fill: k,\n          opacity: a\n        };\n      },\n      destroy: function destroy(a) {\n        var b = this,\n            d = b.chart,\n            e = /AppleWebKit\\/533/.test(Q.navigator.userAgent),\n            c,\n            f,\n            k = b.data || [],\n            l,\n            g;\n        m(b, \"destroy\");\n        this.removeEvents(a);\n        (b.axisTypes || []).forEach(function (a) {\n          (g = b[a]) && g.series && (r(g.series, b), g.isDirty = g.forceRedraw = !0);\n        });\n        b.legendItem && b.chart.legend.destroyItem(b);\n\n        for (f = k.length; f--;) (l = k[f]) && l.destroy && l.destroy();\n\n        b.points = null;\n        H.clearTimeout(b.animationTimeout);\n        u(b, function (b, a) {\n          b instanceof B && !b.survive && (c = e && \"group\" === a ? \"hide\" : \"destroy\", b[c]());\n        });\n        d.hoverSeries === b && (d.hoverSeries = null);\n        r(d.series, b);\n        d.orderSeries();\n        u(b, function (d, e) {\n          a && \"hcEvents\" === e || delete b[e];\n        });\n      },\n      getGraphPath: function getGraphPath(a, b, d) {\n        var e = this,\n            c = e.options,\n            f = c.step,\n            h,\n            k = [],\n            l = [],\n            m;\n        a = a || e.points;\n        (h = a.reversed) && a.reverse();\n        (f = {\n          right: 1,\n          center: 2\n        }[f] || f && 3) && h && (f = 4 - f);\n        a = this.getValidPoints(a, !1, !(c.connectNulls && !b && !d));\n        a.forEach(function (h, g) {\n          var p = h.plotX,\n              r = h.plotY,\n              w = a[g - 1];\n          (h.leftCliff || w && w.rightCliff) && !d && (m = !0);\n          h.isNull && !n(b) && 0 < g ? m = !c.connectNulls : h.isNull && !b ? m = !0 : (0 === g || m ? g = [[\"M\", h.plotX, h.plotY]] : e.getPointSpline ? g = [e.getPointSpline(a, h, g)] : f ? (g = 1 === f ? [[\"L\", w.plotX, r]] : 2 === f ? [[\"L\", (w.plotX + p) / 2, w.plotY], [\"L\", (w.plotX + p) / 2, r]] : [[\"L\", p, w.plotY]], g.push([\"L\", p, r])) : g = [[\"L\", p, r]], l.push(h.x), f && (l.push(h.x), 2 === f && l.push(h.x)), k.push.apply(k, g), m = !1);\n        });\n        k.xMap = l;\n        return e.graphPath = k;\n      },\n      drawGraph: function drawGraph() {\n        var a = this,\n            b = this.options,\n            d = (this.gappedPath || this.getGraphPath).call(this),\n            c = this.chart.styledMode,\n            f = [[\"graph\", \"highcharts-graph\"]];\n        c || f[0].push(b.lineColor || this.color || \"#cccccc\", b.dashStyle);\n        f = a.getZonesGraphs(f);\n        f.forEach(function (e, f) {\n          var h = e[0],\n              k = a[h],\n              l = k ? \"animate\" : \"attr\";\n          k ? (k.endX = a.preventGraphAnimation ? null : d.xMap, k.animate({\n            d: d\n          })) : d.length && (a[h] = k = a.chart.renderer.path(d).addClass(e[1]).attr({\n            zIndex: 1\n          }).add(a.group));\n          k && !c && (h = {\n            stroke: e[2],\n            \"stroke-width\": b.lineWidth,\n            fill: a.fillGraph && a.color || \"none\"\n          }, e[3] ? h.dashstyle = e[3] : \"square\" !== b.linecap && (h[\"stroke-linecap\"] = h[\"stroke-linejoin\"] = \"round\"), k[l](h).shadow(2 > f && b.shadow));\n          k && (k.startX = d.xMap, k.isArea = d.isArea);\n        });\n      },\n      getZonesGraphs: function getZonesGraphs(a) {\n        this.zones.forEach(function (b, d) {\n          d = [\"zone-graph-\" + d, \"highcharts-graph highcharts-zone-graph-\" + d + \" \" + (b.className || \"\")];\n          this.chart.styledMode || d.push(b.color || this.color, b.dashStyle || this.options.dashStyle);\n          a.push(d);\n        }, this);\n        return a;\n      },\n      applyZones: function applyZones() {\n        var a = this,\n            b = this.chart,\n            d = b.renderer,\n            c = this.zones,\n            f,\n            k,\n            l = this.clips || [],\n            m,\n            g = this.graph,\n            p = this.area,\n            n = Math.max(b.chartWidth, b.chartHeight),\n            r = this[(this.zoneAxis || \"y\") + \"Axis\"],\n            w = b.inverted,\n            u,\n            q,\n            A,\n            t = !1,\n            C,\n            F;\n\n        if (c.length && (g || p) && r && \"undefined\" !== typeof r.min) {\n          var M = r.reversed;\n          var I = r.horiz;\n          g && !this.showLine && g.hide();\n          p && p.hide();\n          var y = r.getExtremes();\n          c.forEach(function (e, c) {\n            f = M ? I ? b.plotWidth : 0 : I ? 0 : r.toPixels(y.min) || 0;\n            f = v(E(k, f), 0, n);\n            k = v(Math.round(r.toPixels(E(e.value, y.max), !0) || 0), 0, n);\n            t && (f = k = r.toPixels(y.max));\n            u = Math.abs(f - k);\n            q = Math.min(f, k);\n            A = Math.max(f, k);\n            r.isXAxis ? (m = {\n              x: w ? A : q,\n              y: 0,\n              width: u,\n              height: n\n            }, I || (m.x = b.plotHeight - m.x)) : (m = {\n              x: 0,\n              y: w ? A : q,\n              width: n,\n              height: u\n            }, I && (m.y = b.plotWidth - m.y));\n            w && d.isVML && (m = r.isXAxis ? {\n              x: 0,\n              y: M ? q : A,\n              height: m.width,\n              width: b.chartWidth\n            } : {\n              x: m.y - b.plotLeft - b.spacingBox.x,\n              y: 0,\n              width: m.height,\n              height: b.chartHeight\n            });\n            l[c] ? l[c].animate(m) : l[c] = d.clipRect(m);\n            C = a[\"zone-area-\" + c];\n            F = a[\"zone-graph-\" + c];\n            g && F && F.clip(l[c]);\n            p && C && C.clip(l[c]);\n            t = e.value > y.max;\n            a.resetZones && 0 === k && (k = void 0);\n          });\n          this.clips = l;\n        } else a.visible && (g && g.show(!0), p && p.show(!0));\n      },\n      invertGroups: function invertGroups(a) {\n        function b() {\n          [\"group\", \"markerGroup\"].forEach(function (b) {\n            d[b] && (e.renderer.isVML && d[b].attr({\n              width: d.yAxis.len,\n              height: d.xAxis.len\n            }), d[b].width = d.yAxis.len, d[b].height = d.xAxis.len, d[b].invert(d.isRadialSeries ? !1 : a));\n          });\n        }\n\n        var d = this,\n            e = d.chart;\n        d.xAxis && (d.eventsToUnbind.push(J(e, \"resize\", b)), b(), d.invertGroups = b);\n      },\n      plotGroup: function plotGroup(a, b, d, c, f) {\n        var e = this[a],\n            h = !e;\n        d = {\n          visibility: d,\n          zIndex: c || .1\n        };\n        \"undefined\" === typeof this.opacity || this.chart.styledMode || (d.opacity = this.opacity);\n        h && (this[a] = e = this.chart.renderer.g().add(f));\n        e.addClass(\"highcharts-\" + b + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (n(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (e.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        e.attr(d)[h ? \"attr\" : \"animate\"](this.getPlotBox());\n        return e;\n      },\n      getPlotBox: function getPlotBox() {\n        var a = this.chart,\n            b = this.xAxis,\n            d = this.yAxis;\n        a.inverted && (b = d, d = this.xAxis);\n        return {\n          translateX: b ? b.left : a.plotLeft,\n          translateY: d ? d.top : a.plotTop,\n          scaleX: 1,\n          scaleY: 1\n        };\n      },\n      removeEvents: function removeEvents(a) {\n        a ? this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (b) {\n          b();\n        }), this.eventsToUnbind.length = 0) : P(this);\n      },\n      render: function render() {\n        var a = this,\n            b = a.chart,\n            d = a.options,\n            c = !a.finishedAnimating && b.renderer.isSVG && t(d.animation).duration,\n            f = a.visible ? \"inherit\" : \"hidden\",\n            k = d.zIndex,\n            l = a.hasRendered,\n            g = b.seriesGroup,\n            p = b.inverted;\n        m(this, \"render\");\n        var n = a.plotGroup(\"group\", \"series\", f, k, g);\n        a.markerGroup = a.plotGroup(\"markerGroup\", \"markers\", f, k, g);\n        c && a.animate && a.animate(!0);\n        n.inverted = a.isCartesian || a.invertable ? p : !1;\n        a.drawGraph && (a.drawGraph(), a.applyZones());\n        a.visible && a.drawPoints();\n        a.drawDataLabels && a.drawDataLabels();\n        a.redrawPoints && a.redrawPoints();\n        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();\n        a.invertGroups(p);\n        !1 === d.clip || a.sharedClipKey || l || n.clip(b.clipRect);\n        c && a.animate && a.animate();\n        l || (a.animationTimeout = M(function () {\n          a.afterAnimate();\n        }, c || 0));\n        a.isDirty = !1;\n        a.hasRendered = !0;\n        m(a, \"afterRender\");\n      },\n      redraw: function redraw() {\n        var a = this.chart,\n            b = this.isDirty || this.isDirtyData,\n            d = this.group,\n            c = this.xAxis,\n            f = this.yAxis;\n        d && (a.inverted && d.attr({\n          width: a.plotWidth,\n          height: a.plotHeight\n        }), d.animate({\n          translateX: E(c && c.left, a.plotLeft),\n          translateY: E(f && f.top, a.plotTop)\n        }));\n        this.translate();\n        this.render();\n        b && delete this.kdTree;\n      },\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      searchPoint: function searchPoint(a, b) {\n        var d = this.xAxis,\n            e = this.yAxis,\n            c = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: c ? d.len - a.chartY + d.pos : a.chartX - d.pos,\n          plotY: c ? e.len - a.chartX + e.pos : a.chartY - e.pos\n        }, b, a);\n      },\n      buildKDTree: function buildKDTree(a) {\n        function b(a, e, c) {\n          var f;\n\n          if (f = a && a.length) {\n            var h = d.kdAxisArray[e % c];\n            a.sort(function (a, b) {\n              return a[h] - b[h];\n            });\n            f = Math.floor(f / 2);\n            return {\n              point: a[f],\n              left: b(a.slice(0, f), e + 1, c),\n              right: b(a.slice(f + 1), e + 1, c)\n            };\n          }\n        }\n\n        this.buildingKdTree = !0;\n        var d = this,\n            e = -1 < d.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete d.kdTree;\n        M(function () {\n          d.kdTree = b(d.getValidPoints(null, !d.directTouch), e, e);\n          d.buildingKdTree = !1;\n        }, d.options.kdNow || a && \"touchstart\" === a.type ? 0 : 1);\n      },\n      searchKDTree: function searchKDTree(a, b, d) {\n        function e(a, b, d, l) {\n          var m = b.point,\n              g = c.kdAxisArray[d % l],\n              p = m;\n          var r = n(a[f]) && n(m[f]) ? Math.pow(a[f] - m[f], 2) : null;\n          var w = n(a[h]) && n(m[h]) ? Math.pow(a[h] - m[h], 2) : null;\n          w = (r || 0) + (w || 0);\n          m.dist = n(w) ? Math.sqrt(w) : Number.MAX_VALUE;\n          m.distX = n(r) ? Math.sqrt(r) : Number.MAX_VALUE;\n          g = a[g] - m[g];\n          w = 0 > g ? \"left\" : \"right\";\n          r = 0 > g ? \"right\" : \"left\";\n          b[w] && (w = e(a, b[w], d + 1, l), p = w[k] < p[k] ? w : m);\n          b[r] && Math.sqrt(g * g) < p[k] && (a = e(a, b[r], d + 1, l), p = a[k] < p[k] ? a : p);\n          return p;\n        }\n\n        var c = this,\n            f = this.kdAxisArray[0],\n            h = this.kdAxisArray[1],\n            k = b ? \"distX\" : \"dist\";\n        b = -1 < c.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree(d);\n        if (this.kdTree) return e(a, this.kdTree, b, b);\n      },\n      pointPlacementToXValue: function pointPlacementToXValue() {\n        var a = this.options,\n            b = a.pointRange,\n            d = this.xAxis;\n        a = a.pointPlacement;\n        \"between\" === a && (a = d.reversed ? -.5 : .5);\n        return f(a) ? a * E(b, d.pointRange) : 0;\n      },\n      isPointInside: function isPointInside(a) {\n        return \"undefined\" !== typeof a.plotY && \"undefined\" !== typeof a.plotX && 0 <= a.plotY && a.plotY <= this.yAxis.len && 0 <= a.plotX && a.plotX <= this.xAxis.len;\n      }\n    });\n    \"\";\n  });\n  O(q, \"parts/Stacking.js\", [q[\"parts/Axis.js\"], q[\"parts/Chart.js\"], q[\"parts/Globals.js\"], q[\"parts/StackingAxis.js\"], q[\"parts/Utilities.js\"]], function (g, c, q, y, B) {\n    var H = B.correctFloat,\n        D = B.defined,\n        J = B.destroyObjectProperties,\n        t = B.format,\n        G = B.isNumber,\n        L = B.pick;\n    \"\";\n\n    var v = q.Series,\n        K = function () {\n      function c(c, g, n, p, m) {\n        var d = c.chart.inverted;\n        this.axis = c;\n        this.isNegative = n;\n        this.options = g = g || {};\n        this.x = p;\n        this.total = null;\n        this.points = {};\n        this.hasValidPoints = !1;\n        this.stack = m;\n        this.rightCliff = this.leftCliff = 0;\n        this.alignOptions = {\n          align: g.align || (d ? n ? \"left\" : \"right\" : \"center\"),\n          verticalAlign: g.verticalAlign || (d ? \"middle\" : n ? \"bottom\" : \"top\"),\n          y: g.y,\n          x: g.x\n        };\n        this.textAlign = g.textAlign || (d ? n ? \"right\" : \"left\" : \"center\");\n      }\n\n      c.prototype.destroy = function () {\n        J(this, this.axis);\n      };\n\n      c.prototype.render = function (c) {\n        var g = this.axis.chart,\n            n = this.options,\n            p = n.format;\n        p = p ? t(p, this, g) : n.formatter.call(this);\n        this.label ? this.label.attr({\n          text: p,\n          visibility: \"hidden\"\n        }) : (this.label = g.renderer.label(p, null, null, n.shape, null, null, n.useHTML, !1, \"stack-labels\"), p = {\n          r: n.borderRadius || 0,\n          text: p,\n          rotation: n.rotation,\n          padding: L(n.padding, 5),\n          visibility: \"hidden\"\n        }, g.styledMode || (p.fill = n.backgroundColor, p.stroke = n.borderColor, p[\"stroke-width\"] = n.borderWidth, this.label.css(n.style)), this.label.attr(p), this.label.added || this.label.add(c));\n        this.label.labelrank = g.plotHeight;\n      };\n\n      c.prototype.setOffset = function (c, g, n, p, m) {\n        var d = this.axis,\n            l = d.chart;\n        p = d.translate(d.stacking.usePercentage ? 100 : p ? p : this.total, 0, 0, 0, 1);\n        n = d.translate(n ? n : 0);\n        n = D(p) && Math.abs(p - n);\n        c = L(m, l.xAxis[0].translate(this.x)) + c;\n        d = D(p) && this.getStackBox(l, this, c, p, g, n, d);\n        g = this.label;\n        n = this.isNegative;\n        c = \"justify\" === L(this.options.overflow, \"justify\");\n        var k = this.textAlign;\n        g && d && (m = g.getBBox(), p = g.padding, k = \"left\" === k ? l.inverted ? -p : p : \"right\" === k ? m.width : l.inverted && \"center\" === k ? m.width / 2 : l.inverted ? n ? m.width + p : -p : m.width / 2, n = l.inverted ? m.height / 2 : n ? -p : m.height, this.alignOptions.x = L(this.options.x, 0), this.alignOptions.y = L(this.options.y, 0), d.x -= k, d.y -= n, g.align(this.alignOptions, null, d), l.isInsidePlot(g.alignAttr.x + k - this.alignOptions.x, g.alignAttr.y + n - this.alignOptions.y) ? g.show() : (g.alignAttr.y = -9999, c = !1), c && v.prototype.justifyDataLabel.call(this.axis, g, this.alignOptions, g.alignAttr, m, d), g.attr({\n          x: g.alignAttr.x,\n          y: g.alignAttr.y\n        }), L(!c && this.options.crop, !0) && ((l = G(g.x) && G(g.y) && l.isInsidePlot(g.x - p + g.width, g.y) && l.isInsidePlot(g.x + p, g.y)) || g.hide()));\n      };\n\n      c.prototype.getStackBox = function (c, g, n, p, m, d, l) {\n        var k = g.axis.reversed,\n            f = c.inverted,\n            a = l.height + l.pos - (f ? c.plotLeft : c.plotTop);\n        g = g.isNegative && !k || !g.isNegative && k;\n        return {\n          x: f ? g ? p - l.right : p - d + l.pos - c.plotLeft : n + c.xAxis[0].transB - c.plotLeft,\n          y: f ? l.height - n - m : g ? a - p - d : a - p,\n          width: f ? d : m,\n          height: f ? m : d\n        };\n      };\n\n      return c;\n    }();\n\n    c.prototype.getStacks = function () {\n      var c = this,\n          g = c.inverted;\n      c.yAxis.forEach(function (c) {\n        c.stacking && c.stacking.stacks && c.hasVisibleSeries && (c.stacking.oldStacks = c.stacking.stacks);\n      });\n      c.series.forEach(function (n) {\n        var r = n.xAxis && n.xAxis.options || {};\n        !n.options.stacking || !0 !== n.visible && !1 !== c.options.chart.ignoreHiddenSeries || (n.stackKey = [n.type, L(n.options.stack, \"\"), g ? r.top : r.left, g ? r.height : r.width].join());\n      });\n    };\n\n    y.compose(g);\n\n    v.prototype.setGroupedPoints = function () {\n      this.options.centerInCategory && (this.is(\"column\") || this.is(\"columnrange\")) && !this.options.stacking && 1 < this.chart.series.length && v.prototype.setStackedPoints.call(this, \"group\");\n    };\n\n    v.prototype.setStackedPoints = function (c) {\n      var g = c || this.options.stacking;\n\n      if (g && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {\n        var n = this.processedXData,\n            q = this.processedYData,\n            p = [],\n            m = q.length,\n            d = this.options,\n            l = d.threshold,\n            k = L(d.startFromThreshold && l, 0);\n        d = d.stack;\n        c = c ? this.type + \",\" + g : this.stackKey;\n        var f = \"-\" + c,\n            a = this.negStacks,\n            A = this.yAxis,\n            u = A.stacking.stacks,\n            t = A.stacking.oldStacks,\n            v,\n            w;\n        A.stacking.stacksTouched += 1;\n\n        for (w = 0; w < m; w++) {\n          var M = n[w];\n          var F = q[w];\n          var y = this.getStackIndicator(y, M, this.index);\n          var e = y.key;\n          var b = (v = a && F < (k ? 0 : l)) ? f : c;\n          u[b] || (u[b] = {});\n          u[b][M] || (t[b] && t[b][M] ? (u[b][M] = t[b][M], u[b][M].total = null) : u[b][M] = new K(A, A.options.stackLabels, v, M, d));\n          b = u[b][M];\n          null !== F ? (b.points[e] = b.points[this.index] = [L(b.cumulative, k)], D(b.cumulative) || (b.base = e), b.touched = A.stacking.stacksTouched, 0 < y.index && !1 === this.singleStacks && (b.points[e][0] = b.points[this.index + \",\" + M + \",0\"][0])) : b.points[e] = b.points[this.index] = null;\n          \"percent\" === g ? (v = v ? c : f, a && u[v] && u[v][M] ? (v = u[v][M], b.total = v.total = Math.max(v.total, b.total) + Math.abs(F) || 0) : b.total = H(b.total + (Math.abs(F) || 0))) : \"group\" === g ? null !== F && (b.total = (b.total || 0) + 1) : b.total = H(b.total + (F || 0));\n          b.cumulative = \"group\" === g ? (b.total || 1) - 1 : L(b.cumulative, k) + (F || 0);\n          null !== F && (b.points[e].push(b.cumulative), p[w] = b.cumulative, b.hasValidPoints = !0);\n        }\n\n        \"percent\" === g && (A.stacking.usePercentage = !0);\n        \"group\" !== g && (this.stackedYData = p);\n        A.stacking.oldStacks = {};\n      }\n    };\n\n    v.prototype.modifyStacks = function () {\n      var c = this,\n          g = c.stackKey,\n          q = c.yAxis.stacking.stacks,\n          t = c.processedXData,\n          p,\n          m = c.options.stacking;\n      c[m + \"Stacker\"] && [g, \"-\" + g].forEach(function (d) {\n        for (var l = t.length, k, f; l--;) if (k = t[l], p = c.getStackIndicator(p, k, c.index, d), f = (k = q[d] && q[d][k]) && k.points[p.key]) c[m + \"Stacker\"](f, k, l);\n      });\n    };\n\n    v.prototype.percentStacker = function (c, g, q) {\n      g = g.total ? 100 / g.total : 0;\n      c[0] = H(c[0] * g);\n      c[1] = H(c[1] * g);\n      this.stackedYData[q] = c[1];\n    };\n\n    v.prototype.getStackIndicator = function (c, g, q, t) {\n      !D(c) || c.x !== g || t && c.key !== t ? c = {\n        x: g,\n        index: 0,\n        key: t\n      } : c.index++;\n      c.key = [q, g, c.index].join();\n      return c;\n    };\n\n    q.StackItem = K;\n    return q.StackItem;\n  });\n  O(q, \"parts/Dynamics.js\", [q[\"parts/Axis.js\"], q[\"parts/Chart.js\"], q[\"parts/Globals.js\"], q[\"parts/Options.js\"], q[\"parts/Point.js\"], q[\"parts/Time.js\"], q[\"parts/Utilities.js\"]], function (g, c, q, y, B, H, D) {\n    var J = y.time,\n        t = D.addEvent,\n        G = D.animate,\n        L = D.createElement,\n        v = D.css,\n        K = D.defined,\n        n = D.erase,\n        r = D.error,\n        C = D.extend,\n        I = D.fireEvent,\n        p = D.isArray,\n        m = D.isNumber,\n        d = D.isObject,\n        l = D.isString,\n        k = D.merge,\n        f = D.objectEach,\n        a = D.pick,\n        A = D.relativeLength,\n        u = D.setAnimation,\n        E = D.splat;\n    y = q.Series;\n    var P = q.seriesTypes;\n\n    q.cleanRecursively = function (a, c) {\n      var k = {};\n      f(a, function (f, e) {\n        if (d(a[e], !0) && !a.nodeType && c[e]) f = q.cleanRecursively(a[e], c[e]), Object.keys(f).length && (k[e] = f);else if (d(a[e]) || a[e] !== c[e]) k[e] = a[e];\n      });\n      return k;\n    };\n\n    C(c.prototype, {\n      addSeries: function addSeries(d, c, f) {\n        var k,\n            e = this;\n        d && (c = a(c, !0), I(e, \"addSeries\", {\n          options: d\n        }, function () {\n          k = e.initSeries(d);\n          e.isDirtyLegend = !0;\n          e.linkSeries();\n          k.enabledDataSorting && k.setData(d.data, !1);\n          I(e, \"afterAddSeries\", {\n            series: k\n          });\n          c && e.redraw(f);\n        }));\n        return k;\n      },\n      addAxis: function addAxis(a, d, c, f) {\n        return this.createAxis(d ? \"xAxis\" : \"yAxis\", {\n          axis: a,\n          redraw: c,\n          animation: f\n        });\n      },\n      addColorAxis: function addColorAxis(a, d, c) {\n        return this.createAxis(\"colorAxis\", {\n          axis: a,\n          redraw: d,\n          animation: c\n        });\n      },\n      createAxis: function createAxis(d, c) {\n        var f = this.options,\n            l = \"colorAxis\" === d,\n            e = c.redraw,\n            b = c.animation;\n        c = k(c.axis, {\n          index: this[d].length,\n          isX: \"xAxis\" === d\n        });\n        var h = l ? new q.ColorAxis(this, c) : new g(this, c);\n        f[d] = E(f[d] || {});\n        f[d].push(c);\n        l && (this.isDirtyLegend = !0, this.axes.forEach(function (a) {\n          a.series = [];\n        }), this.series.forEach(function (a) {\n          a.bindAxes();\n          a.isDirtyData = !0;\n        }));\n        a(e, !0) && this.redraw(b);\n        return h;\n      },\n      showLoading: function showLoading(d) {\n        var c = this,\n            f = c.options,\n            k = c.loadingDiv,\n            e = f.loading,\n            b = function b() {\n          k && v(k, {\n            left: c.plotLeft + \"px\",\n            top: c.plotTop + \"px\",\n            width: c.plotWidth + \"px\",\n            height: c.plotHeight + \"px\"\n          });\n        };\n\n        k || (c.loadingDiv = k = L(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, c.container), c.loadingSpan = L(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, k), t(c, \"redraw\", b));\n        k.className = \"highcharts-loading\";\n        c.loadingSpan.innerHTML = a(d, f.lang.loading, \"\");\n        c.styledMode || (v(k, C(e.style, {\n          zIndex: 10\n        })), v(c.loadingSpan, e.labelStyle), c.loadingShown || (v(k, {\n          opacity: 0,\n          display: \"\"\n        }), G(k, {\n          opacity: e.style.opacity || .5\n        }, {\n          duration: e.showDuration || 0\n        })));\n        c.loadingShown = !0;\n        b();\n      },\n      hideLoading: function hideLoading() {\n        var a = this.options,\n            d = this.loadingDiv;\n        d && (d.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || G(d, {\n          opacity: 0\n        }, {\n          duration: a.loading.hideDuration || 100,\n          complete: function complete() {\n            v(d, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      },\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireReflow: \"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \"),\n      collectionsWithUpdate: [\"xAxis\", \"yAxis\", \"zAxis\", \"series\"],\n      update: function update(d, c, g, p) {\n        var e = this,\n            b = {\n          credits: \"addCredits\",\n          title: \"setTitle\",\n          subtitle: \"setSubtitle\",\n          caption: \"setCaption\"\n        },\n            h,\n            n,\n            u,\n            r = d.isResponsiveOptions,\n            w = [];\n        I(e, \"update\", {\n          options: d\n        });\n        r || e.setResponsive(!1, !0);\n        d = q.cleanRecursively(d, e.options);\n        k(!0, e.userOptions, d);\n\n        if (h = d.chart) {\n          k(!0, e.options.chart, h);\n          \"className\" in h && e.setClassName(h.className);\n          \"reflow\" in h && e.setReflow(h.reflow);\n\n          if (\"inverted\" in h || \"polar\" in h || \"type\" in h) {\n            e.propFromSeries();\n            var t = !0;\n          }\n\n          \"alignTicks\" in h && (t = !0);\n          f(h, function (a, b) {\n            -1 !== e.propsRequireUpdateSeries.indexOf(\"chart.\" + b) && (n = !0);\n            -1 !== e.propsRequireDirtyBox.indexOf(b) && (e.isDirtyBox = !0);\n            -1 !== e.propsRequireReflow.indexOf(b) && (r ? e.isDirtyBox = !0 : u = !0);\n          });\n          !e.styledMode && \"style\" in h && e.renderer.setStyle(h.style);\n        }\n\n        !e.styledMode && d.colors && (this.options.colors = d.colors);\n        d.plotOptions && k(!0, this.options.plotOptions, d.plotOptions);\n        d.time && this.time === J && (this.time = new H(d.time));\n        f(d, function (a, d) {\n          if (e[d] && \"function\" === typeof e[d].update) e[d].update(a, !1);else if (\"function\" === typeof e[b[d]]) e[b[d]](a);\n          \"chart\" !== d && -1 !== e.propsRequireUpdateSeries.indexOf(d) && (n = !0);\n        });\n        this.collectionsWithUpdate.forEach(function (b) {\n          if (d[b]) {\n            if (\"series\" === b) {\n              var c = [];\n              e[b].forEach(function (b, d) {\n                b.options.isInternal || c.push(a(b.options.index, d));\n              });\n            }\n\n            E(d[b]).forEach(function (a, d) {\n              var f = K(a.id),\n                  h;\n              f && (h = e.get(a.id));\n              h || (h = e[b][c ? c[d] : d]) && f && K(h.options.id) && (h = void 0);\n              h && h.coll === b && (h.update(a, !1), g && (h.touched = !0));\n              !h && g && e.collectionsWithInit[b] && (e.collectionsWithInit[b][0].apply(e, [a].concat(e.collectionsWithInit[b][1] || []).concat([!1])).touched = !0);\n            });\n            g && e[b].forEach(function (a) {\n              a.touched || a.options.isInternal ? delete a.touched : w.push(a);\n            });\n          }\n        });\n        w.forEach(function (a) {\n          a.remove && a.remove(!1);\n        });\n        t && e.axes.forEach(function (a) {\n          a.update({}, !1);\n        });\n        n && e.getSeriesOrderByLinks().forEach(function (a) {\n          a.chart && a.update({}, !1);\n        }, this);\n        d.loading && k(!0, e.options.loading, d.loading);\n        t = h && h.width;\n        h = h && h.height;\n        l(h) && (h = A(h, t || e.chartWidth));\n        u || m(t) && t !== e.chartWidth || m(h) && h !== e.chartHeight ? e.setSize(t, h, p) : a(c, !0) && e.redraw(p);\n        I(e, \"afterUpdate\", {\n          options: d,\n          redraw: c,\n          animation: p\n        });\n      },\n      setSubtitle: function setSubtitle(a, d) {\n        this.applyDescription(\"subtitle\", a);\n        this.layOutTitles(d);\n      },\n      setCaption: function setCaption(a, d) {\n        this.applyDescription(\"caption\", a);\n        this.layOutTitles(d);\n      }\n    });\n    c.prototype.collectionsWithInit = {\n      xAxis: [c.prototype.addAxis, [!0]],\n      yAxis: [c.prototype.addAxis, [!1]],\n      series: [c.prototype.addSeries]\n    };\n    C(B.prototype, {\n      update: function update(c, f, k, l) {\n        function e() {\n          b.applyOptions(c);\n          var e = g && b.hasDummyGraphic;\n          e = null === b.y ? !e : e;\n          g && e && (b.graphic = g.destroy(), delete b.hasDummyGraphic);\n          d(c, !0) && (g && g.element && c && c.marker && \"undefined\" !== typeof c.marker.symbol && (b.graphic = g.destroy()), c && c.dataLabels && b.dataLabel && (b.dataLabel = b.dataLabel.destroy()), b.connector && (b.connector = b.connector.destroy()));\n          m = b.index;\n          h.updateParallelArrays(b, m);\n          n.data[m] = d(n.data[m], !0) || d(c, !0) ? b.options : a(c, n.data[m]);\n          h.isDirty = h.isDirtyData = !0;\n          !h.fixedBox && h.hasCartesianSeries && (p.isDirtyBox = !0);\n          \"point\" === n.legendType && (p.isDirtyLegend = !0);\n          f && p.redraw(k);\n        }\n\n        var b = this,\n            h = b.series,\n            g = b.graphic,\n            m,\n            p = h.chart,\n            n = h.options;\n        f = a(f, !0);\n        !1 === l ? e() : b.firePointEvent(\"update\", {\n          options: c\n        }, e);\n      },\n      remove: function remove(a, d) {\n        this.series.removePoint(this.series.data.indexOf(this), a, d);\n      }\n    });\n    C(y.prototype, {\n      addPoint: function addPoint(d, c, f, k, e) {\n        var b = this.options,\n            h = this.data,\n            l = this.chart,\n            g = this.xAxis;\n        g = g && g.hasNames && g.names;\n        var m = b.data,\n            p = this.xData,\n            n;\n        c = a(c, !0);\n        var u = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(u, [d]);\n        var r = u.x;\n        var w = p.length;\n        if (this.requireSorting && r < p[w - 1]) for (n = !0; w && p[w - 1] > r;) w--;\n        this.updateParallelArrays(u, \"splice\", w, 0, 0);\n        this.updateParallelArrays(u, w);\n        g && u.name && (g[r] = u.name);\n        m.splice(w, 0, d);\n        n && (this.data.splice(w, 0, null), this.processData());\n        \"point\" === b.legendType && this.generatePoints();\n        f && (h[0] && h[0].remove ? h[0].remove(!1) : (h.shift(), this.updateParallelArrays(u, \"shift\"), m.shift()));\n        !1 !== e && I(this, \"addPoint\", {\n          point: u\n        });\n        this.isDirtyData = this.isDirty = !0;\n        c && l.redraw(k);\n      },\n      removePoint: function removePoint(d, c, f) {\n        var k = this,\n            e = k.data,\n            b = e[d],\n            h = k.points,\n            l = k.chart,\n            g = function g() {\n          h && h.length === e.length && h.splice(d, 1);\n          e.splice(d, 1);\n          k.options.data.splice(d, 1);\n          k.updateParallelArrays(b || {\n            series: k\n          }, \"splice\", d, 1);\n          b && b.destroy();\n          k.isDirty = !0;\n          k.isDirtyData = !0;\n          c && l.redraw();\n        };\n\n        u(f, l);\n        c = a(c, !0);\n        b ? b.firePointEvent(\"remove\", null, g) : g();\n      },\n      remove: function remove(d, c, f, k) {\n        function e() {\n          b.destroy(k);\n          b.remove = null;\n          h.isDirtyLegend = h.isDirtyBox = !0;\n          h.linkSeries();\n          a(d, !0) && h.redraw(c);\n        }\n\n        var b = this,\n            h = b.chart;\n        !1 !== f ? I(b, \"remove\", null, e) : e();\n      },\n      update: function update(d, c) {\n        d = q.cleanRecursively(d, this.userOptions);\n        I(this, \"update\", {\n          options: d\n        });\n        var f = this,\n            l = f.chart,\n            e = f.userOptions,\n            b = f.initialType || f.type,\n            h = d.type || e.type || l.options.chart.type,\n            g = !(this.hasDerivedData || d.dataGrouping || h && h !== this.type || \"undefined\" !== typeof d.pointStart || d.pointInterval || d.pointIntervalUnit || d.keys),\n            m = P[b].prototype,\n            p,\n            n = [\"eventOptions\", \"navigatorSeries\", \"baseSeries\"],\n            u = f.finishedAnimating && {\n          animation: !1\n        },\n            w = {};\n        g && (n.push(\"data\", \"isDirtyData\", \"points\", \"processedXData\", \"processedYData\", \"xIncrement\", \"cropped\", \"_hasPointMarkers\", \"_hasPointLabels\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\"), !1 !== d.visible && n.push(\"area\", \"graph\"), f.parallelArrays.forEach(function (a) {\n          n.push(a + \"Data\");\n        }), d.data && (d.dataSorting && C(f.options.dataSorting, d.dataSorting), this.setData(d.data, !1)));\n        d = k(e, u, {\n          index: \"undefined\" === typeof e.index ? f.index : e.index,\n          pointStart: a(e.pointStart, f.xData[0])\n        }, !g && {\n          data: f.options.data\n        }, d);\n        g && d.data && (d.data = f.options.data);\n        n = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"].concat(n);\n        n.forEach(function (a) {\n          n[a] = f[a];\n          delete f[a];\n        });\n        f.remove(!1, null, !1, !0);\n\n        for (p in m) f[p] = void 0;\n\n        P[h || b] ? C(f, P[h || b].prototype) : r(17, !0, l, {\n          missingModuleFor: h || b\n        });\n        n.forEach(function (a) {\n          f[a] = n[a];\n        });\n        f.init(l, d);\n\n        if (g && this.points) {\n          var A = f.options;\n          !1 === A.visible ? (w.graphic = 1, w.dataLabel = 1) : f._hasPointLabels || (d = A.marker, e = A.dataLabels, d && (!1 === d.enabled || \"symbol\" in d) && (w.graphic = 1), e && !1 === e.enabled && (w.dataLabel = 1));\n          this.points.forEach(function (a) {\n            a && a.series && (a.resolveColor(), Object.keys(w).length && a.destroyElements(w), !1 === A.showInLegend && a.legendItem && l.legend.destroyItem(a));\n          }, this);\n        }\n\n        f.initialType = b;\n        l.linkSeries();\n        I(this, \"afterUpdate\");\n        a(c, !0) && l.redraw(g ? void 0 : !1);\n      },\n      setName: function setName(a) {\n        this.name = this.options.name = this.userOptions.name = a;\n        this.chart.isDirtyLegend = !0;\n      }\n    });\n    C(g.prototype, {\n      update: function update(d, c) {\n        var l = this.chart,\n            g = d && d.events || {};\n        d = k(this.userOptions, d);\n        l.options[this.coll].indexOf && (l.options[this.coll][l.options[this.coll].indexOf(this.userOptions)] = d);\n        f(l.options[this.coll].events, function (a, b) {\n          \"undefined\" === typeof g[b] && (g[b] = void 0);\n        });\n        this.destroy(!0);\n        this.init(l, C(d, {\n          events: g\n        }));\n        l.isDirtyBox = !0;\n        a(c, !0) && l.redraw();\n      },\n      remove: function remove(d) {\n        for (var c = this.chart, f = this.coll, k = this.series, e = k.length; e--;) k[e] && k[e].remove(!1);\n\n        n(c.axes, this);\n        n(c[f], this);\n        p(c.options[f]) ? c.options[f].splice(this.options.index, 1) : delete c.options[f];\n        c[f].forEach(function (a, d) {\n          a.options.index = a.userOptions.index = d;\n        });\n        this.destroy();\n        c.isDirtyBox = !0;\n        a(d, !0) && c.redraw();\n      },\n      setTitle: function setTitle(a, d) {\n        this.update({\n          title: a\n        }, d);\n      },\n      setCategories: function setCategories(a, d) {\n        this.update({\n          categories: a\n        }, d);\n      }\n    });\n  });\n  O(q, \"parts/AreaSeries.js\", [q[\"parts/Globals.js\"], q[\"parts/Color.js\"], q[\"mixins/legend-symbol.js\"], q[\"parts/Utilities.js\"]], function (g, c, q, y) {\n    var B = c.parse,\n        H = y.objectEach,\n        D = y.pick;\n    c = y.seriesType;\n    var J = g.Series;\n    c(\"area\", \"line\", {\n      softThreshold: !1,\n      threshold: 0\n    }, {\n      singleStacks: !1,\n      getStackPoints: function getStackPoints(c) {\n        var g = [],\n            q = [],\n            t = this.xAxis,\n            y = this.yAxis,\n            n = y.stacking.stacks[this.stackKey],\n            r = {},\n            C = this.index,\n            I = y.series,\n            p = I.length,\n            m = D(y.options.reversedStacks, !0) ? 1 : -1,\n            d;\n        c = c || this.points;\n\n        if (this.options.stacking) {\n          for (d = 0; d < c.length; d++) c[d].leftNull = c[d].rightNull = void 0, r[c[d].x] = c[d];\n\n          H(n, function (d, c) {\n            null !== d.total && q.push(c);\n          });\n          q.sort(function (d, c) {\n            return d - c;\n          });\n          var l = I.map(function (d) {\n            return d.visible;\n          });\n          q.forEach(function (c, f) {\n            var a = 0,\n                k,\n                u;\n            if (r[c] && !r[c].isNull) g.push(r[c]), [-1, 1].forEach(function (a) {\n              var g = 1 === a ? \"rightNull\" : \"leftNull\",\n                  w = 0,\n                  A = n[q[f + a]];\n              if (A) for (d = C; 0 <= d && d < p;) k = A.points[d], k || (d === C ? r[c][g] = !0 : l[d] && (u = n[c].points[d]) && (w -= u[1] - u[0])), d += m;\n              r[c][1 === a ? \"rightCliff\" : \"leftCliff\"] = w;\n            });else {\n              for (d = C; 0 <= d && d < p;) {\n                if (k = n[c].points[d]) {\n                  a = k[1];\n                  break;\n                }\n\n                d += m;\n              }\n\n              a = y.translate(a, 0, 1, 0, 1);\n              g.push({\n                isNull: !0,\n                plotX: t.translate(c, 0, 0, 0, 1),\n                x: c,\n                plotY: a,\n                yBottom: a\n              });\n            }\n          });\n        }\n\n        return g;\n      },\n      getGraphPath: function getGraphPath(c) {\n        var g = J.prototype.getGraphPath,\n            q = this.options,\n            t = q.stacking,\n            y = this.yAxis,\n            n,\n            r = [],\n            C = [],\n            I = this.index,\n            p = y.stacking.stacks[this.stackKey],\n            m = q.threshold,\n            d = Math.round(y.getThreshold(q.threshold));\n        q = D(q.connectNulls, \"percent\" === t);\n\n        var l = function l(a, k, _l) {\n          var g = c[a];\n          a = t && p[g.x].points[I];\n          var n = g[_l + \"Null\"] || 0;\n          _l = g[_l + \"Cliff\"] || 0;\n          g = !0;\n\n          if (_l || n) {\n            var u = (n ? a[0] : a[1]) + _l;\n            var q = a[0] + _l;\n            g = !!n;\n          } else !t && c[k] && c[k].isNull && (u = q = m);\n\n          \"undefined\" !== typeof u && (C.push({\n            plotX: f,\n            plotY: null === u ? d : y.getThreshold(u),\n            isNull: g,\n            isCliff: !0\n          }), r.push({\n            plotX: f,\n            plotY: null === q ? d : y.getThreshold(q),\n            doCurve: !1\n          }));\n        };\n\n        c = c || this.points;\n        t && (c = this.getStackPoints(c));\n\n        for (n = 0; n < c.length; n++) {\n          t || (c[n].leftCliff = c[n].rightCliff = c[n].leftNull = c[n].rightNull = void 0);\n          var k = c[n].isNull;\n          var f = D(c[n].rectPlotX, c[n].plotX);\n          var a = D(c[n].yBottom, d);\n          if (!k || q) q || l(n, n - 1, \"left\"), k && !t && q || (C.push(c[n]), r.push({\n            x: n,\n            plotX: f,\n            plotY: a\n          })), q || l(n, n + 1, \"right\");\n        }\n\n        n = g.call(this, C, !0, !0);\n        r.reversed = !0;\n        k = g.call(this, r, !0, !0);\n        (a = k[0]) && \"M\" === a[0] && (k[0] = [\"L\", a[1], a[2]]);\n        k = n.concat(k);\n        g = g.call(this, C, !1, q);\n        k.xMap = n.xMap;\n        this.areaPath = k;\n        return g;\n      },\n      drawGraph: function drawGraph() {\n        this.areaPath = [];\n        J.prototype.drawGraph.apply(this);\n        var c = this,\n            g = this.areaPath,\n            q = this.options,\n            v = [[\"area\", \"highcharts-area\", this.color, q.fillColor]];\n        this.zones.forEach(function (g, n) {\n          v.push([\"zone-area-\" + n, \"highcharts-area highcharts-zone-area-\" + n + \" \" + g.className, g.color || c.color, g.fillColor || q.fillColor]);\n        });\n        v.forEach(function (t) {\n          var n = t[0],\n              r = c[n],\n              v = r ? \"animate\" : \"attr\",\n              y = {};\n          r ? (r.endX = c.preventGraphAnimation ? null : g.xMap, r.animate({\n            d: g\n          })) : (y.zIndex = 0, r = c[n] = c.chart.renderer.path(g).addClass(t[1]).add(c.group), r.isArea = !0);\n          c.chart.styledMode || (y.fill = D(t[3], B(t[2]).setOpacity(D(q.fillOpacity, .75)).get()));\n          r[v](y);\n          r.startX = g.xMap;\n          r.shiftUnit = q.step ? 2 : 1;\n        });\n      },\n      drawLegendSymbol: q.drawRectangle\n    });\n    \"\";\n  });\n  O(q, \"parts/SplineSeries.js\", [q[\"parts/Utilities.js\"]], function (g) {\n    var c = g.pick;\n    g = g.seriesType;\n    g(\"spline\", \"line\", {}, {\n      getPointSpline: function getPointSpline(g, q, B) {\n        var y = q.plotX || 0,\n            D = q.plotY || 0,\n            J = g[B - 1];\n        B = g[B + 1];\n\n        if (J && !J.isNull && !1 !== J.doCurve && !q.isCliff && B && !B.isNull && !1 !== B.doCurve && !q.isCliff) {\n          g = J.plotY || 0;\n          var t = B.plotX || 0;\n          B = B.plotY || 0;\n          var G = 0;\n          var L = (1.5 * y + (J.plotX || 0)) / 2.5;\n          var v = (1.5 * D + g) / 2.5;\n          t = (1.5 * y + t) / 2.5;\n          var K = (1.5 * D + B) / 2.5;\n          t !== L && (G = (K - v) * (t - y) / (t - L) + D - K);\n          v += G;\n          K += G;\n          v > g && v > D ? (v = Math.max(g, D), K = 2 * D - v) : v < g && v < D && (v = Math.min(g, D), K = 2 * D - v);\n          K > B && K > D ? (K = Math.max(B, D), v = 2 * D - K) : K < B && K < D && (K = Math.min(B, D), v = 2 * D - K);\n          q.rightContX = t;\n          q.rightContY = K;\n        }\n\n        q = [\"C\", c(J.rightContX, J.plotX, 0), c(J.rightContY, J.plotY, 0), c(L, y, 0), c(v, D, 0), y, D];\n        J.rightContX = J.rightContY = void 0;\n        return q;\n      }\n    });\n    \"\";\n  });\n  O(q, \"parts/AreaSplineSeries.js\", [q[\"parts/Globals.js\"], q[\"mixins/legend-symbol.js\"], q[\"parts/Options.js\"], q[\"parts/Utilities.js\"]], function (g, c, q, y) {\n    y = y.seriesType;\n    g = g.seriesTypes.area.prototype;\n    y(\"areaspline\", \"spline\", q.defaultOptions.plotOptions.area, {\n      getStackPoints: g.getStackPoints,\n      getGraphPath: g.getGraphPath,\n      drawGraph: g.drawGraph,\n      drawLegendSymbol: c.drawRectangle\n    });\n    \"\";\n  });\n  O(q, \"parts/ColumnSeries.js\", [q[\"parts/Globals.js\"], q[\"parts/Color.js\"], q[\"mixins/legend-symbol.js\"], q[\"parts/Utilities.js\"]], function (g, c, q, y) {\n    \"\";\n\n    var B = c.parse,\n        H = y.animObject,\n        D = y.clamp,\n        J = y.defined,\n        t = y.extend,\n        G = y.isNumber,\n        L = y.merge,\n        v = y.pick;\n    c = y.seriesType;\n    var K = g.Series;\n    c(\"column\", \"line\", {\n      borderRadius: 0,\n      centerInCategory: !1,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        y: void 0\n      },\n      softThreshold: !1,\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    }, {\n      cropShoulder: 0,\n      directTouch: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      negStacks: !0,\n      init: function init() {\n        K.prototype.init.apply(this, arguments);\n        var c = this,\n            g = c.chart;\n        g.hasRendered && g.series.forEach(function (g) {\n          g.type === c.type && (g.isDirty = !0);\n        });\n      },\n      getColumnMetrics: function getColumnMetrics() {\n        var c = this,\n            g = c.options,\n            q = c.xAxis,\n            t = c.yAxis,\n            p = q.options.reversedStacks;\n        p = q.reversed && !p || !q.reversed && p;\n        var m,\n            d = {},\n            l = 0;\n        !1 === g.grouping ? l = 1 : c.chart.series.forEach(function (a) {\n          var f = a.yAxis,\n              k = a.options;\n\n          if (a.type === c.type && (a.visible || !c.chart.options.chart.ignoreHiddenSeries) && t.len === f.len && t.pos === f.pos) {\n            if (k.stacking && \"group\" !== k.stacking) {\n              m = a.stackKey;\n              \"undefined\" === typeof d[m] && (d[m] = l++);\n              var g = d[m];\n            } else !1 !== k.grouping && (g = l++);\n\n            a.columnIndex = g;\n          }\n        });\n        var k = Math.min(Math.abs(q.transA) * (q.ordinal && q.ordinal.slope || g.pointRange || q.closestPointRange || q.tickInterval || 1), q.len),\n            f = k * g.groupPadding,\n            a = (k - 2 * f) / (l || 1);\n        g = Math.min(g.maxPointWidth || q.len, v(g.pointWidth, a * (1 - 2 * g.pointPadding)));\n        c.columnMetrics = {\n          width: g,\n          offset: (a - g) / 2 + (f + ((c.columnIndex || 0) + (p ? 1 : 0)) * a - k / 2) * (p ? -1 : 1),\n          paddedWidth: a,\n          columnCount: l\n        };\n        return c.columnMetrics;\n      },\n      crispCol: function crispCol(c, g, q, t) {\n        var p = this.chart,\n            m = this.borderWidth,\n            d = -(m % 2 ? .5 : 0);\n        m = m % 2 ? .5 : 1;\n        p.inverted && p.renderer.isVML && (m += 1);\n        this.options.crisp && (q = Math.round(c + q) + d, c = Math.round(c) + d, q -= c);\n        t = Math.round(g + t) + m;\n        d = .5 >= Math.abs(g) && .5 < t;\n        g = Math.round(g) + m;\n        t -= g;\n        d && t && (--g, t += 1);\n        return {\n          x: c,\n          y: g,\n          width: q,\n          height: t\n        };\n      },\n      adjustForMissingColumns: function adjustForMissingColumns(c, q, t, v) {\n        var p = this,\n            m = this.options.stacking;\n\n        if (!t.isNull && 1 < v.columnCount) {\n          var d = 0,\n              l = 0;\n          Highcharts.objectEach(this.yAxis.stacking && this.yAxis.stacking.stacks, function (c) {\n            if (\"number\" === typeof t.x && (c = c[t.x.toString()])) {\n              var f = c.points[p.index],\n                  a = c.total;\n              m ? (f && (d = l), c.hasValidPoints && l++) : g.isArray(f) && (d = f[1], l = a || 0);\n            }\n          });\n          c = (t.plotX || 0) + ((l - 1) * v.paddedWidth + q) / 2 - q - d * v.paddedWidth;\n        }\n\n        return c;\n      },\n      translate: function translate() {\n        var c = this,\n            g = c.chart,\n            q = c.options,\n            t = c.dense = 2 > c.closestPointRange * c.xAxis.transA;\n        t = c.borderWidth = v(q.borderWidth, t ? 0 : 1);\n        var p = c.xAxis,\n            m = c.yAxis,\n            d = q.threshold,\n            l = c.translatedThreshold = m.getThreshold(d),\n            k = v(q.minPointLength, 5),\n            f = c.getColumnMetrics(),\n            a = f.width,\n            A = c.barW = Math.max(a, 1 + 2 * t),\n            u = c.pointXOffset = f.offset,\n            E = c.dataMin,\n            y = c.dataMax;\n        g.inverted && (l -= .5);\n        q.pointPadding && (A = Math.ceil(A));\n        K.prototype.translate.apply(c);\n        c.points.forEach(function (n) {\n          var r = v(n.yBottom, l),\n              w = 999 + Math.abs(r),\n              t = a,\n              e = n.plotX || 0;\n          w = D(n.plotY, -w, m.len + w);\n          var b = e + u,\n              h = A,\n              z = Math.min(w, r),\n              x = Math.max(w, r) - z;\n\n          if (k && Math.abs(x) < k) {\n            x = k;\n            var C = !m.reversed && !n.negative || m.reversed && n.negative;\n            G(d) && G(y) && n.y === d && y <= d && (m.min || 0) < d && E !== y && (C = !C);\n            z = Math.abs(z - l) > k ? r - k : l - (C ? k : 0);\n          }\n\n          J(n.options.pointWidth) && (t = h = Math.ceil(n.options.pointWidth), b -= Math.round((t - a) / 2));\n          q.centerInCategory && (b = c.adjustForMissingColumns(b, t, n, f));\n          n.barX = b;\n          n.pointWidth = t;\n          n.tooltipPos = g.inverted ? [m.len + m.pos - g.plotLeft - w, p.len + p.pos - g.plotTop - (e || 0) - u - h / 2, x] : [b + h / 2, w + m.pos - g.plotTop, x];\n          n.shapeType = c.pointClass.prototype.shapeType || \"rect\";\n          n.shapeArgs = c.crispCol.apply(c, n.isNull ? [b, l, h, 0] : [b, z, h, x]);\n        });\n      },\n      getSymbol: g.noop,\n      drawLegendSymbol: q.drawRectangle,\n      drawGraph: function drawGraph() {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      },\n      pointAttribs: function pointAttribs(c, g) {\n        var n = this.options,\n            q = this.pointAttrToOptions || {};\n        var p = q.stroke || \"borderColor\";\n        var m = q[\"stroke-width\"] || \"borderWidth\",\n            d = c && c.color || this.color,\n            l = c && c[p] || n[p] || this.color || d,\n            k = c && c[m] || n[m] || this[m] || 0;\n        q = c && c.options.dashStyle || n.dashStyle;\n        var f = v(c && c.opacity, n.opacity, 1);\n\n        if (c && this.zones.length) {\n          var a = c.getZone();\n          d = c.options.color || a && (a.color || c.nonZonedColor) || this.color;\n          a && (l = a.borderColor || l, q = a.dashStyle || q, k = a.borderWidth || k);\n        }\n\n        g && c && (c = L(n.states[g], c.options.states && c.options.states[g] || {}), g = c.brightness, d = c.color || \"undefined\" !== typeof g && B(d).brighten(c.brightness).get() || d, l = c[p] || l, k = c[m] || k, q = c.dashStyle || q, f = v(c.opacity, f));\n        p = {\n          fill: d,\n          stroke: l,\n          \"stroke-width\": k,\n          opacity: f\n        };\n        q && (p.dashstyle = q);\n        return p;\n      },\n      drawPoints: function drawPoints() {\n        var c = this,\n            g = this.chart,\n            q = c.options,\n            t = g.renderer,\n            p = q.animationLimit || 250,\n            m;\n        c.points.forEach(function (d) {\n          var l = d.graphic,\n              k = !!l,\n              f = l && g.pointCount < p ? \"animate\" : \"attr\";\n\n          if (G(d.plotY) && null !== d.y) {\n            m = d.shapeArgs;\n            l && d.hasNewShapeType() && (l = l.destroy());\n            c.enabledDataSorting && (d.startXPos = c.xAxis.reversed ? -(m ? m.width : 0) : c.xAxis.width);\n            l || (d.graphic = l = t[d.shapeType](m).add(d.group || c.group)) && c.enabledDataSorting && g.hasRendered && g.pointCount < p && (l.attr({\n              x: d.startXPos\n            }), k = !0, f = \"animate\");\n            if (l && k) l[f](L(m));\n            if (q.borderRadius) l[f]({\n              r: q.borderRadius\n            });\n            g.styledMode || l[f](c.pointAttribs(d, d.selected && \"select\")).shadow(!1 !== d.allowShadow && q.shadow, null, q.stacking && !q.borderRadius);\n            l.addClass(d.getClassName(), !0);\n          } else l && (d.graphic = l.destroy());\n        });\n      },\n      animate: function animate(c) {\n        var g = this,\n            n = this.yAxis,\n            q = g.options,\n            p = this.chart.inverted,\n            m = {},\n            d = p ? \"translateX\" : \"translateY\";\n        if (c) m.scaleY = .001, c = D(n.toPixels(q.threshold), n.pos, n.pos + n.len), p ? m.translateX = c - n.len : m.translateY = c, g.clipBox && g.setClip(), g.group.attr(m);else {\n          var l = g.group.attr(d);\n          g.group.animate({\n            scaleY: 1\n          }, t(H(g.options.animation), {\n            step: function step(c, f) {\n              g.group && (m[d] = l + f.pos * (n.pos - l), g.group.attr(m));\n            }\n          }));\n        }\n      },\n      remove: function remove() {\n        var c = this,\n            g = c.chart;\n        g.hasRendered && g.series.forEach(function (g) {\n          g.type === c.type && (g.isDirty = !0);\n        });\n        K.prototype.remove.apply(c, arguments);\n      }\n    });\n    \"\";\n  });\n  O(q, \"parts/BarSeries.js\", [q[\"parts/Utilities.js\"]], function (g) {\n    g = g.seriesType;\n    g(\"bar\", \"column\", null, {\n      inverted: !0\n    });\n    \"\";\n  });\n  O(q, \"parts/ScatterSeries.js\", [q[\"parts/Globals.js\"], q[\"parts/Utilities.js\"]], function (g, c) {\n    var q = c.addEvent;\n    c = c.seriesType;\n    var y = g.Series;\n    c(\"scatter\", \"line\", {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      jitter: {\n        x: 0,\n        y: 0\n      },\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <span style=\"font-size: 10px\"> {series.name}</span><br/>',\n        pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n      }\n    }, {\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1,\n      drawGraph: function drawGraph() {\n        this.options.lineWidth && y.prototype.drawGraph.call(this);\n      },\n      applyJitter: function applyJitter() {\n        var c = this,\n            g = this.options.jitter,\n            q = this.points.length;\n        g && this.points.forEach(function (y, t) {\n          [\"x\", \"y\"].forEach(function (D, B) {\n            var v = \"plot\" + D.toUpperCase();\n\n            if (g[D] && !y.isNull) {\n              var G = c[D + \"Axis\"];\n              var n = g[D] * G.transA;\n\n              if (G && !G.isLog) {\n                var r = Math.max(0, y[v] - n);\n                G = Math.min(G.len, y[v] + n);\n                B = 1E4 * Math.sin(t + B * q);\n                y[v] = r + (G - r) * (B - Math.floor(B));\n                \"x\" === D && (y.clientX = y.plotX);\n              }\n            }\n          });\n        });\n      }\n    });\n    q(y, \"afterTranslate\", function () {\n      this.applyJitter && this.applyJitter();\n    });\n    \"\";\n  });\n  O(q, \"mixins/centered-series.js\", [q[\"parts/Globals.js\"], q[\"parts/Utilities.js\"]], function (g, c) {\n    var q = c.isNumber,\n        y = c.pick,\n        B = c.relativeLength,\n        H = g.deg2rad;\n    g.CenteredSeriesMixin = {\n      getCenter: function getCenter() {\n        var c = this.options,\n            q = this.chart,\n            t = 2 * (c.slicedOffset || 0),\n            G = q.plotWidth - 2 * t,\n            H = q.plotHeight - 2 * t,\n            v = c.center,\n            K = Math.min(G, H),\n            n = c.size,\n            r = c.innerSize || 0;\n        \"string\" === typeof n && (n = parseFloat(n));\n        \"string\" === typeof r && (r = parseFloat(r));\n        c = [y(v[0], \"50%\"), y(v[1], \"50%\"), y(n && 0 > n ? void 0 : c.size, \"100%\"), y(r && 0 > r ? void 0 : c.innerSize || 0, \"0%\")];\n        !q.angular || this instanceof g.Series || (c[3] = 0);\n\n        for (v = 0; 4 > v; ++v) n = c[v], q = 2 > v || 2 === v && /%$/.test(n), c[v] = B(n, [G, H, K, c[2]][v]) + (q ? t : 0);\n\n        c[3] > c[2] && (c[3] = c[2]);\n        return c;\n      },\n      getStartAndEndRadians: function getStartAndEndRadians(c, g) {\n        c = q(c) ? c : 0;\n        g = q(g) && g > c && 360 > g - c ? g : c + 360;\n        return {\n          start: H * (c + -90),\n          end: H * (g + -90)\n        };\n      }\n    };\n  });\n  O(q, \"parts/PieSeries.js\", [q[\"parts/Globals.js\"], q[\"mixins/legend-symbol.js\"], q[\"parts/Point.js\"], q[\"parts/Utilities.js\"]], function (g, c, q, y) {\n    var B = y.addEvent,\n        H = y.clamp,\n        D = y.defined,\n        J = y.fireEvent,\n        t = y.isNumber,\n        G = y.merge,\n        L = y.pick,\n        v = y.relativeLength,\n        K = y.seriesType,\n        n = y.setAnimation;\n    y = g.CenteredSeriesMixin;\n    var r = y.getStartAndEndRadians,\n        C = g.noop,\n        I = g.Series;\n    K(\"pie\", \"line\", {\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        allowOverlap: !0,\n        connectorPadding: 5,\n        connectorShape: \"fixedOffset\",\n        crookDistance: \"70%\",\n        distance: 30,\n        enabled: !0,\n        formatter: function formatter() {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        softConnector: !0,\n        x: 0\n      },\n      fillColor: void 0,\n      ignoreHiddenPoint: !0,\n      inactiveOtherPoints: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      lineWidth: void 0,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    }, {\n      isCartesian: !1,\n      requireSorting: !1,\n      directTouch: !0,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      axisTypes: [],\n      pointAttribs: g.seriesTypes.column.prototype.pointAttribs,\n      animate: function animate(c) {\n        var g = this,\n            d = g.points,\n            l = g.startAngleRad;\n        c || d.forEach(function (d) {\n          var c = d.graphic,\n              a = d.shapeArgs;\n          c && a && (c.attr({\n            r: L(d.startR, g.center && g.center[3] / 2),\n            start: l,\n            end: l\n          }), c.animate({\n            r: a.r,\n            start: a.start,\n            end: a.end\n          }, g.options.animation));\n        });\n      },\n      hasData: function hasData() {\n        return !!this.processedXData.length;\n      },\n      updateTotals: function updateTotals() {\n        var c,\n            g = 0,\n            d = this.points,\n            l = d.length,\n            k = this.options.ignoreHiddenPoint;\n\n        for (c = 0; c < l; c++) {\n          var f = d[c];\n          g += k && !f.visible ? 0 : f.isNull ? 0 : f.y;\n        }\n\n        this.total = g;\n\n        for (c = 0; c < l; c++) f = d[c], f.percentage = 0 < g && (f.visible || !k) ? f.y / g * 100 : 0, f.total = g;\n      },\n      generatePoints: function generatePoints() {\n        I.prototype.generatePoints.call(this);\n        this.updateTotals();\n      },\n      getX: function getX(c, g, d) {\n        var l = this.center,\n            k = this.radii ? this.radii[d.index] : l[2] / 2;\n        c = Math.asin(H((c - l[1]) / (k + d.labelDistance), -1, 1));\n        return l[0] + (g ? -1 : 1) * Math.cos(c) * (k + d.labelDistance) + (0 < d.labelDistance ? (g ? -1 : 1) * this.options.dataLabels.padding : 0);\n      },\n      translate: function translate(c) {\n        this.generatePoints();\n        var g = 0,\n            d = this.options,\n            l = d.slicedOffset,\n            k = l + (d.borderWidth || 0),\n            f = r(d.startAngle, d.endAngle),\n            a = this.startAngleRad = f.start;\n        f = (this.endAngleRad = f.end) - a;\n        var p = this.points,\n            n = d.dataLabels.distance;\n        d = d.ignoreHiddenPoint;\n        var q,\n            t = p.length;\n        c || (this.center = c = this.getCenter());\n\n        for (q = 0; q < t; q++) {\n          var w = p[q];\n          var y = a + g * f;\n          if (!d || w.visible) g += w.percentage / 100;\n          var F = a + g * f;\n          w.shapeType = \"arc\";\n          w.shapeArgs = {\n            x: c[0],\n            y: c[1],\n            r: c[2] / 2,\n            innerR: c[3] / 2,\n            start: Math.round(1E3 * y) / 1E3,\n            end: Math.round(1E3 * F) / 1E3\n          };\n          w.labelDistance = L(w.options.dataLabels && w.options.dataLabels.distance, n);\n          w.labelDistance = v(w.labelDistance, w.shapeArgs.r);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, w.labelDistance);\n          F = (F + y) / 2;\n          F > 1.5 * Math.PI ? F -= 2 * Math.PI : F < -Math.PI / 2 && (F += 2 * Math.PI);\n          w.slicedTranslation = {\n            translateX: Math.round(Math.cos(F) * l),\n            translateY: Math.round(Math.sin(F) * l)\n          };\n          var C = Math.cos(F) * c[2] / 2;\n          var e = Math.sin(F) * c[2] / 2;\n          w.tooltipPos = [c[0] + .7 * C, c[1] + .7 * e];\n          w.half = F < -Math.PI / 2 || F > Math.PI / 2 ? 1 : 0;\n          w.angle = F;\n          y = Math.min(k, w.labelDistance / 5);\n          w.labelPosition = {\n            natural: {\n              x: c[0] + C + Math.cos(F) * w.labelDistance,\n              y: c[1] + e + Math.sin(F) * w.labelDistance\n            },\n            \"final\": {},\n            alignment: 0 > w.labelDistance ? \"center\" : w.half ? \"right\" : \"left\",\n            connectorPosition: {\n              breakAt: {\n                x: c[0] + C + Math.cos(F) * y,\n                y: c[1] + e + Math.sin(F) * y\n              },\n              touchingSliceAt: {\n                x: c[0] + C,\n                y: c[1] + e\n              }\n            }\n          };\n        }\n\n        J(this, \"afterTranslate\");\n      },\n      drawEmpty: function drawEmpty() {\n        var c = this.startAngleRad,\n            g = this.endAngleRad,\n            d = this.options;\n\n        if (0 === this.total) {\n          var l = this.center[0];\n          var k = this.center[1];\n          this.graph || (this.graph = this.chart.renderer.arc(l, k, this.center[1] / 2, 0, c, g).addClass(\"highcharts-empty-series\").add(this.group));\n          this.graph.attr({\n            d: Highcharts.SVGRenderer.prototype.symbols.arc(l, k, this.center[2] / 2, 0, {\n              start: c,\n              end: g,\n              innerR: this.center[3] / 2\n            })\n          });\n          this.chart.styledMode || this.graph.attr({\n            \"stroke-width\": d.borderWidth,\n            fill: d.fillColor || \"none\",\n            stroke: d.color || \"#cccccc\"\n          });\n        } else this.graph && (this.graph = this.graph.destroy());\n      },\n      redrawPoints: function redrawPoints() {\n        var c = this,\n            g = c.chart,\n            d = g.renderer,\n            l,\n            k,\n            f,\n            a,\n            n = c.options.shadow;\n        this.drawEmpty();\n        !n || c.shadowGroup || g.styledMode || (c.shadowGroup = d.g(\"shadow\").attr({\n          zIndex: -1\n        }).add(c.group));\n        c.points.forEach(function (m) {\n          var p = {};\n          k = m.graphic;\n\n          if (!m.isNull && k) {\n            a = m.shapeArgs;\n            l = m.getTranslate();\n\n            if (!g.styledMode) {\n              var q = m.shadowGroup;\n              n && !q && (q = m.shadowGroup = d.g(\"shadow\").add(c.shadowGroup));\n              q && q.attr(l);\n              f = c.pointAttribs(m, m.selected && \"select\");\n            }\n\n            m.delayedRendering ? (k.setRadialReference(c.center).attr(a).attr(l), g.styledMode || k.attr(f).attr({\n              \"stroke-linejoin\": \"round\"\n            }).shadow(n, q), m.delayedRendering = !1) : (k.setRadialReference(c.center), g.styledMode || G(!0, p, f), G(!0, p, a, l), k.animate(p));\n            k.attr({\n              visibility: m.visible ? \"inherit\" : \"hidden\"\n            });\n            k.addClass(m.getClassName());\n          } else k && (m.graphic = k.destroy());\n        });\n      },\n      drawPoints: function drawPoints() {\n        var c = this.chart.renderer;\n        this.points.forEach(function (g) {\n          g.graphic && g.hasNewShapeType() && (g.graphic = g.graphic.destroy());\n          g.graphic || (g.graphic = c[g.shapeType](g.shapeArgs).add(g.series.group), g.delayedRendering = !0);\n        });\n      },\n      searchPoint: C,\n      sortByAngle: function sortByAngle(c, g) {\n        c.sort(function (c, l) {\n          return \"undefined\" !== typeof c.angle && (l.angle - c.angle) * g;\n        });\n      },\n      drawLegendSymbol: c.drawRectangle,\n      getCenter: y.getCenter,\n      getSymbol: C,\n      drawGraph: null\n    }, {\n      init: function init() {\n        q.prototype.init.apply(this, arguments);\n        var c = this;\n        c.name = L(c.name, \"Slice\");\n\n        var g = function g(d) {\n          c.slice(\"select\" === d.type);\n        };\n\n        B(c, \"select\", g);\n        B(c, \"unselect\", g);\n        return c;\n      },\n      isValid: function isValid() {\n        return t(this.y) && 0 <= this.y;\n      },\n      setVisible: function setVisible(c, g) {\n        var d = this,\n            l = d.series,\n            k = l.chart,\n            f = l.options.ignoreHiddenPoint;\n        g = L(g, f);\n        c !== d.visible && (d.visible = d.options.visible = c = \"undefined\" === typeof c ? !d.visible : c, l.options.data[l.data.indexOf(d)] = d.options, [\"graphic\", \"dataLabel\", \"connector\", \"shadowGroup\"].forEach(function (a) {\n          if (d[a]) d[a][c ? \"show\" : \"hide\"](!0);\n        }), d.legendItem && k.legend.colorizeItem(d, c), c || \"hover\" !== d.state || d.setState(\"\"), f && (l.isDirty = !0), g && k.redraw());\n      },\n      slice: function slice(c, g, d) {\n        var l = this.series;\n        n(d, l.chart);\n        L(g, !0);\n        this.sliced = this.options.sliced = D(c) ? c : !this.sliced;\n        l.options.data[l.data.indexOf(this)] = this.options;\n        this.graphic && this.graphic.animate(this.getTranslate());\n        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());\n      },\n      getTranslate: function getTranslate() {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      },\n      haloPath: function haloPath(c) {\n        var g = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(g.x, g.y, g.r + c, g.r + c, {\n          innerR: g.r - 1,\n          start: g.start,\n          end: g.end\n        });\n      },\n      connectorShapes: {\n        fixedOffset: function fixedOffset(c, g, d) {\n          var l = g.breakAt;\n          g = g.touchingSliceAt;\n          return [[\"M\", c.x, c.y], d.softConnector ? [\"C\", c.x + (\"left\" === c.alignment ? -5 : 5), c.y, 2 * l.x - g.x, 2 * l.y - g.y, l.x, l.y] : [\"L\", l.x, l.y], [\"L\", g.x, g.y]];\n        },\n        straight: function straight(c, g) {\n          g = g.touchingSliceAt;\n          return [[\"M\", c.x, c.y], [\"L\", g.x, g.y]];\n        },\n        crookedLine: function crookedLine(c, g, d) {\n          g = g.touchingSliceAt;\n          var l = this.series,\n              k = l.center[0],\n              f = l.chart.plotWidth,\n              a = l.chart.plotLeft;\n          l = c.alignment;\n          var m = this.shapeArgs.r;\n          d = v(d.crookDistance, 1);\n          f = \"left\" === l ? k + m + (f + a - k - m) * (1 - d) : a + (k - m) * d;\n          d = [\"L\", f, c.y];\n          k = !0;\n          if (\"left\" === l ? f > c.x || f < g.x : f < c.x || f > g.x) k = !1;\n          c = [[\"M\", c.x, c.y]];\n          k && c.push(d);\n          c.push([\"L\", g.x, g.y]);\n          return c;\n        }\n      },\n      getConnectorPath: function getConnectorPath() {\n        var c = this.labelPosition,\n            g = this.series.options.dataLabels,\n            d = g.connectorShape,\n            l = this.connectorShapes;\n        l[d] && (d = l[d]);\n        return d.call(this, {\n          x: c.final.x,\n          y: c.final.y,\n          alignment: c.alignment\n        }, c.connectorPosition, g);\n      }\n    });\n    \"\";\n  });\n  O(q, \"parts/DataLabels.js\", [q[\"parts/Globals.js\"], q[\"parts/Utilities.js\"]], function (g, c) {\n    var q = g.noop,\n        y = g.seriesTypes,\n        B = c.animObject,\n        H = c.arrayMax,\n        D = c.clamp,\n        J = c.defined,\n        t = c.extend,\n        G = c.fireEvent,\n        L = c.format,\n        v = c.isArray,\n        K = c.merge,\n        n = c.objectEach,\n        r = c.pick,\n        C = c.relativeLength,\n        I = c.splat,\n        p = c.stableSort,\n        m = g.Series;\n\n    g.distribute = function (c, l, k) {\n      function d(a, c) {\n        return a.target - c.target;\n      }\n\n      var a,\n          m = !0,\n          n = c,\n          q = [];\n      var t = 0;\n      var w = n.reducedLen || l;\n\n      for (a = c.length; a--;) t += c[a].size;\n\n      if (t > w) {\n        p(c, function (a, c) {\n          return (c.rank || 0) - (a.rank || 0);\n        });\n\n        for (t = a = 0; t <= w;) t += c[a].size, a++;\n\n        q = c.splice(a - 1, c.length);\n      }\n\n      p(c, d);\n\n      for (c = c.map(function (a) {\n        return {\n          size: a.size,\n          targets: [a.target],\n          align: r(a.align, .5)\n        };\n      }); m;) {\n        for (a = c.length; a--;) m = c[a], t = (Math.min.apply(0, m.targets) + Math.max.apply(0, m.targets)) / 2, m.pos = D(t - m.size * m.align, 0, l - m.size);\n\n        a = c.length;\n\n        for (m = !1; a--;) 0 < a && c[a - 1].pos + c[a - 1].size > c[a].pos && (c[a - 1].size += c[a].size, c[a - 1].targets = c[a - 1].targets.concat(c[a].targets), c[a - 1].align = .5, c[a - 1].pos + c[a - 1].size > l && (c[a - 1].pos = l - c[a - 1].size), c.splice(a, 1), m = !0);\n      }\n\n      n.push.apply(n, q);\n      a = 0;\n      c.some(function (c) {\n        var d = 0;\n        if (c.targets.some(function () {\n          n[a].pos = c.pos + d;\n          if (\"undefined\" !== typeof k && Math.abs(n[a].pos - n[a].target) > k) return n.slice(0, a + 1).forEach(function (a) {\n            delete a.pos;\n          }), n.reducedLen = (n.reducedLen || l) - .1 * l, n.reducedLen > .1 * l && g.distribute(n, l, k), !0;\n          d += n[a].size;\n          a++;\n        })) return !0;\n      });\n      p(n, d);\n    };\n\n    m.prototype.drawDataLabels = function () {\n      function c(a, c) {\n        var b = c.filter;\n        return b ? (c = b.operator, a = a[b.property], b = b.value, \">\" === c && a > b || \"<\" === c && a < b || \">=\" === c && a >= b || \"<=\" === c && a <= b || \"==\" === c && a == b || \"===\" === c && a === b ? !0 : !1) : !0;\n      }\n\n      function g(a, c) {\n        var b = [],\n            d;\n        if (v(a) && !v(c)) b = a.map(function (a) {\n          return K(a, c);\n        });else if (v(c) && !v(a)) b = c.map(function (b) {\n          return K(a, b);\n        });else if (v(a) || v(c)) for (d = Math.max(a.length, c.length); d--;) b[d] = K(a[d], c[d]);else b = K(a, c);\n        return b;\n      }\n\n      var k = this,\n          f = k.chart,\n          a = k.options,\n          m = a.dataLabels,\n          p = k.points,\n          q,\n          t = k.hasRendered || 0,\n          w = B(a.animation).duration,\n          y = Math.min(w, 200),\n          F = !f.renderer.forExport && r(m.defer, 0 < y),\n          C = f.renderer;\n      m = g(g(f.options.plotOptions && f.options.plotOptions.series && f.options.plotOptions.series.dataLabels, f.options.plotOptions && f.options.plotOptions[k.type] && f.options.plotOptions[k.type].dataLabels), m);\n      G(this, \"drawDataLabels\");\n\n      if (v(m) || m.enabled || k._hasPointLabels) {\n        var e = k.plotGroup(\"dataLabelsGroup\", \"data-labels\", F && !t ? \"hidden\" : \"inherit\", m.zIndex || 6);\n        F && (e.attr({\n          opacity: +t\n        }), t || setTimeout(function () {\n          var b = k.dataLabelsGroup;\n          b && (k.visible && e.show(!0), b[a.animation ? \"animate\" : \"attr\"]({\n            opacity: 1\n          }, {\n            duration: y\n          }));\n        }, w - y));\n        p.forEach(function (b) {\n          q = I(g(m, b.dlOptions || b.options && b.options.dataLabels));\n          q.forEach(function (d, g) {\n            var h = d.enabled && (!b.isNull || b.dataLabelOnNull) && c(b, d),\n                l = b.dataLabels ? b.dataLabels[g] : b.dataLabel,\n                m = b.connectors ? b.connectors[g] : b.connector,\n                p = r(d.distance, b.labelDistance),\n                q = !l;\n\n            if (h) {\n              var u = b.getLabelConfig();\n              var w = r(d[b.formatPrefix + \"Format\"], d.format);\n              u = J(w) ? L(w, u, f) : (d[b.formatPrefix + \"Formatter\"] || d.formatter).call(u, d);\n              w = d.style;\n              var t = d.rotation;\n              f.styledMode || (w.color = r(d.color, w.color, k.color, \"#000000\"), \"contrast\" === w.color ? (b.contrastColor = C.getContrast(b.color || k.color), w.color = !J(p) && d.inside || 0 > p || a.stacking ? b.contrastColor : \"#000000\") : delete b.contrastColor, a.cursor && (w.cursor = a.cursor));\n              var A = {\n                r: d.borderRadius || 0,\n                rotation: t,\n                padding: d.padding,\n                zIndex: 1\n              };\n              f.styledMode || (A.fill = d.backgroundColor, A.stroke = d.borderColor, A[\"stroke-width\"] = d.borderWidth);\n              n(A, function (a, b) {\n                \"undefined\" === typeof a && delete A[b];\n              });\n            }\n\n            !l || h && J(u) ? h && J(u) && (l ? A.text = u : (b.dataLabels = b.dataLabels || [], l = b.dataLabels[g] = t ? C.text(u, 0, -9999, d.useHTML).addClass(\"highcharts-data-label\") : C.label(u, 0, -9999, d.shape, null, null, d.useHTML, null, \"data-label\"), g || (b.dataLabel = l), l.addClass(\" highcharts-data-label-color-\" + b.colorIndex + \" \" + (d.className || \"\") + (d.useHTML ? \" highcharts-tracker\" : \"\"))), l.options = d, l.attr(A), f.styledMode || l.css(w).shadow(d.shadow), l.added || l.add(e), d.textPath && !d.useHTML && (l.setTextPath(b.getDataLabelPath && b.getDataLabelPath(l) || b.graphic, d.textPath), b.dataLabelPath && !d.textPath.enabled && (b.dataLabelPath = b.dataLabelPath.destroy())), k.alignDataLabel(b, l, d, null, q)) : (b.dataLabel = b.dataLabel && b.dataLabel.destroy(), b.dataLabels && (1 === b.dataLabels.length ? delete b.dataLabels : delete b.dataLabels[g]), g || delete b.dataLabel, m && (b.connector = b.connector.destroy(), b.connectors && (1 === b.connectors.length ? delete b.connectors : delete b.connectors[g])));\n          });\n        });\n      }\n\n      G(this, \"afterDrawDataLabels\");\n    };\n\n    m.prototype.alignDataLabel = function (c, g, k, f, a) {\n      var d = this,\n          l = this.chart,\n          m = this.isCartesian && l.inverted,\n          n = this.enabledDataSorting,\n          p = r(c.dlBox && c.dlBox.centerX, c.plotX, -9999),\n          q = r(c.plotY, -9999),\n          v = g.getBBox(),\n          y = k.rotation,\n          e = k.align,\n          b = l.isInsidePlot(p, Math.round(q), m),\n          h = \"justify\" === r(k.overflow, n ? \"none\" : \"justify\"),\n          z = this.visible && !1 !== c.visible && (c.series.forceDL || n && !h || b || k.inside && f && l.isInsidePlot(p, m ? f.x + 1 : f.y + f.height - 1, m));\n\n      var x = function x(e) {\n        n && d.xAxis && !h && d.setDataLabelStartPos(c, g, a, b, e);\n      };\n\n      if (z) {\n        var C = l.renderer.fontMetrics(l.styledMode ? void 0 : k.style.fontSize, g).b;\n        f = t({\n          x: m ? this.yAxis.len - q : p,\n          y: Math.round(m ? this.xAxis.len - p : q),\n          width: 0,\n          height: 0\n        }, f);\n        t(k, {\n          width: v.width,\n          height: v.height\n        });\n        y ? (h = !1, p = l.renderer.rotCorr(C, y), p = {\n          x: f.x + (k.x || 0) + f.width / 2 + p.x,\n          y: f.y + (k.y || 0) + {\n            top: 0,\n            middle: .5,\n            bottom: 1\n          }[k.verticalAlign] * f.height\n        }, x(p), g[a ? \"attr\" : \"animate\"](p).attr({\n          align: e\n        }), x = (y + 720) % 360, x = 180 < x && 360 > x, \"left\" === e ? p.y -= x ? v.height : 0 : \"center\" === e ? (p.x -= v.width / 2, p.y -= v.height / 2) : \"right\" === e && (p.x -= v.width, p.y -= x ? 0 : v.height), g.placed = !0, g.alignAttr = p) : (x(f), g.align(k, null, f), p = g.alignAttr);\n        h && 0 <= f.height ? this.justifyDataLabel(g, k, p, v, f, a) : r(k.crop, !0) && (z = l.isInsidePlot(p.x, p.y) && l.isInsidePlot(p.x + v.width, p.y + v.height));\n        if (k.shape && !y) g[a ? \"attr\" : \"animate\"]({\n          anchorX: m ? l.plotWidth - c.plotY : c.plotX,\n          anchorY: m ? l.plotHeight - c.plotX : c.plotY\n        });\n      }\n\n      a && n && (g.placed = !1);\n      z || n && !h || (g.hide(!0), g.placed = !1);\n    };\n\n    m.prototype.setDataLabelStartPos = function (c, g, k, f, a) {\n      var d = this.chart,\n          l = d.inverted,\n          m = this.xAxis,\n          n = m.reversed,\n          p = l ? g.height / 2 : g.width / 2;\n      c = (c = c.pointWidth) ? c / 2 : 0;\n      m = l ? a.x : n ? -p - c : m.width - p + c;\n      a = l ? n ? this.yAxis.height - p + c : -p - c : a.y;\n      g.startXPos = m;\n      g.startYPos = a;\n      f ? \"hidden\" === g.visibility && (g.show(), g.attr({\n        opacity: 0\n      }).animate({\n        opacity: 1\n      })) : g.attr({\n        opacity: 1\n      }).animate({\n        opacity: 0\n      }, void 0, g.hide);\n      d.hasRendered && (k && g.attr({\n        x: g.startXPos,\n        y: g.startYPos\n      }), g.placed = !0);\n    };\n\n    m.prototype.justifyDataLabel = function (c, g, k, f, a, m) {\n      var d = this.chart,\n          l = g.align,\n          n = g.verticalAlign,\n          p = c.box ? 0 : c.padding || 0,\n          q = g.x;\n      q = void 0 === q ? 0 : q;\n      var r = g.y;\n      var t = void 0 === r ? 0 : r;\n      r = k.x + p;\n\n      if (0 > r) {\n        \"right\" === l && 0 <= q ? (g.align = \"left\", g.inside = !0) : q -= r;\n        var e = !0;\n      }\n\n      r = k.x + f.width - p;\n      r > d.plotWidth && (\"left\" === l && 0 >= q ? (g.align = \"right\", g.inside = !0) : q += d.plotWidth - r, e = !0);\n      r = k.y + p;\n      0 > r && (\"bottom\" === n && 0 <= t ? (g.verticalAlign = \"top\", g.inside = !0) : t -= r, e = !0);\n      r = k.y + f.height - p;\n      r > d.plotHeight && (\"top\" === n && 0 >= t ? (g.verticalAlign = \"bottom\", g.inside = !0) : t += d.plotHeight - r, e = !0);\n      e && (g.x = q, g.y = t, c.placed = !m, c.align(g, void 0, a));\n      return e;\n    };\n\n    y.pie && (y.pie.prototype.dataLabelPositioners = {\n      radialDistributionY: function radialDistributionY(c) {\n        return c.top + c.distributeBox.pos;\n      },\n      radialDistributionX: function radialDistributionX(c, g, k, f) {\n        return c.getX(k < g.top + 2 || k > g.bottom - 2 ? f : k, g.half, g);\n      },\n      justify: function justify(c, g, k) {\n        return k[0] + (c.half ? -1 : 1) * (g + c.labelDistance);\n      },\n      alignToPlotEdges: function alignToPlotEdges(c, g, k, f) {\n        c = c.getBBox().width;\n        return g ? c + f : k - c - f;\n      },\n      alignToConnectors: function alignToConnectors(c, g, k, f) {\n        var a = 0,\n            d;\n        c.forEach(function (c) {\n          d = c.dataLabel.getBBox().width;\n          d > a && (a = d);\n        });\n        return g ? a + f : k - a - f;\n      }\n    }, y.pie.prototype.drawDataLabels = function () {\n      var c = this,\n          l = c.data,\n          k,\n          f = c.chart,\n          a = c.options.dataLabels || {},\n          n = a.connectorPadding,\n          p,\n          q = f.plotWidth,\n          t = f.plotHeight,\n          w = f.plotLeft,\n          v = Math.round(f.chartWidth / 3),\n          y,\n          C = c.center,\n          e = C[2] / 2,\n          b = C[1],\n          h,\n          z,\n          x,\n          B,\n          D = [[], []],\n          G,\n          I,\n          L,\n          O,\n          U = [0, 0, 0, 0],\n          R = c.dataLabelPositioners,\n          T;\n      c.visible && (a.enabled || c._hasPointLabels) && (l.forEach(function (a) {\n        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n          width: \"auto\"\n        }).css({\n          width: \"auto\",\n          textOverflow: \"clip\"\n        }), a.dataLabel.shortened = !1);\n      }), m.prototype.drawDataLabels.apply(c), l.forEach(function (b) {\n        b.dataLabel && (b.visible ? (D[b.half].push(b), b.dataLabel._pos = null, !J(a.style.width) && !J(b.options.dataLabels && b.options.dataLabels.style && b.options.dataLabels.style.width) && b.dataLabel.getBBox().width > v && (b.dataLabel.css({\n          width: Math.round(.7 * v) + \"px\"\n        }), b.dataLabel.shortened = !0)) : (b.dataLabel = b.dataLabel.destroy(), b.dataLabels && 1 === b.dataLabels.length && delete b.dataLabels));\n      }), D.forEach(function (d, l) {\n        var m = d.length,\n            p = [],\n            u;\n\n        if (m) {\n          c.sortByAngle(d, l - .5);\n\n          if (0 < c.maxLabelDistance) {\n            var v = Math.max(0, b - e - c.maxLabelDistance);\n            var A = Math.min(b + e + c.maxLabelDistance, f.plotHeight);\n            d.forEach(function (a) {\n              0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, b - e - a.labelDistance), a.bottom = Math.min(b + e + a.labelDistance, f.plotHeight), u = a.dataLabel.getBBox().height || 21, a.distributeBox = {\n                target: a.labelPosition.natural.y - a.top + u / 2,\n                size: u,\n                rank: a.y\n              }, p.push(a.distributeBox));\n            });\n            v = A + u - v;\n            g.distribute(p, v, v / 5);\n          }\n\n          for (O = 0; O < m; O++) {\n            k = d[O];\n            x = k.labelPosition;\n            h = k.dataLabel;\n            L = !1 === k.visible ? \"hidden\" : \"inherit\";\n            I = v = x.natural.y;\n            p && J(k.distributeBox) && (\"undefined\" === typeof k.distributeBox.pos ? L = \"hidden\" : (B = k.distributeBox.size, I = R.radialDistributionY(k)));\n            delete k.positionIndex;\n            if (a.justify) G = R.justify(k, e, C);else switch (a.alignTo) {\n              case \"connectors\":\n                G = R.alignToConnectors(d, l, q, w);\n                break;\n\n              case \"plotEdges\":\n                G = R.alignToPlotEdges(h, l, q, w);\n                break;\n\n              default:\n                G = R.radialDistributionX(c, k, I, v);\n            }\n            h._attr = {\n              visibility: L,\n              align: x.alignment\n            };\n            T = k.options.dataLabels || {};\n            h._pos = {\n              x: G + r(T.x, a.x) + ({\n                left: n,\n                right: -n\n              }[x.alignment] || 0),\n              y: I + r(T.y, a.y) - 10\n            };\n            x.final.x = G;\n            x.final.y = I;\n            r(a.crop, !0) && (z = h.getBBox().width, v = null, G - z < n && 1 === l ? (v = Math.round(z - G + n), U[3] = Math.max(v, U[3])) : G + z > q - n && 0 === l && (v = Math.round(G + z - q + n), U[1] = Math.max(v, U[1])), 0 > I - B / 2 ? U[0] = Math.max(Math.round(-I + B / 2), U[0]) : I + B / 2 > t && (U[2] = Math.max(Math.round(I + B / 2 - t), U[2])), h.sideOverflow = v);\n          }\n        }\n      }), 0 === H(U) || this.verifyDataLabelOverflow(U)) && (this.placeDataLabels(), this.points.forEach(function (b) {\n        T = K(a, b.options.dataLabels);\n\n        if (p = r(T.connectorWidth, 1)) {\n          var d;\n          y = b.connector;\n\n          if ((h = b.dataLabel) && h._pos && b.visible && 0 < b.labelDistance) {\n            L = h._attr.visibility;\n            if (d = !y) b.connector = y = f.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + b.colorIndex + (b.className ? \" \" + b.className : \"\")).add(c.dataLabelsGroup), f.styledMode || y.attr({\n              \"stroke-width\": p,\n              stroke: T.connectorColor || b.color || \"#666666\"\n            });\n            y[d ? \"attr\" : \"animate\"]({\n              d: b.getConnectorPath()\n            });\n            y.attr(\"visibility\", L);\n          } else y && (b.connector = y.destroy());\n        }\n      }));\n    }, y.pie.prototype.placeDataLabels = function () {\n      this.points.forEach(function (c) {\n        var d = c.dataLabel,\n            g;\n        d && c.visible && ((g = d._pos) ? (d.sideOverflow && (d._attr.width = Math.max(d.getBBox().width - d.sideOverflow, 0), d.css({\n          width: d._attr.width + \"px\",\n          textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n        }), d.shortened = !0), d.attr(d._attr), d[d.moved ? \"animate\" : \"attr\"](g), d.moved = !0) : d && d.attr({\n          y: -9999\n        }));\n        delete c.distributeBox;\n      }, this);\n    }, y.pie.prototype.alignDataLabel = q, y.pie.prototype.verifyDataLabelOverflow = function (c) {\n      var d = this.center,\n          g = this.options,\n          f = g.center,\n          a = g.minSize || 80,\n          m = null !== g.size;\n\n      if (!m) {\n        if (null !== f[0]) var n = Math.max(d[2] - Math.max(c[1], c[3]), a);else n = Math.max(d[2] - c[1] - c[3], a), d[0] += (c[3] - c[1]) / 2;\n        null !== f[1] ? n = D(n, a, d[2] - Math.max(c[0], c[2])) : (n = D(n, a, d[2] - c[0] - c[2]), d[1] += (c[0] - c[2]) / 2);\n        n < d[2] ? (d[2] = n, d[3] = Math.min(C(g.innerSize || 0, n), n), this.translate(d), this.drawDataLabels && this.drawDataLabels()) : m = !0;\n      }\n\n      return m;\n    });\n    y.column && (y.column.prototype.alignDataLabel = function (c, g, k, f, a) {\n      var d = this.chart.inverted,\n          l = c.series,\n          n = c.dlBox || c.shapeArgs,\n          p = r(c.below, c.plotY > r(this.translatedThreshold, l.yAxis.len)),\n          q = r(k.inside, !!this.options.stacking);\n      n && (f = K(n), 0 > f.y && (f.height += f.y, f.y = 0), n = f.y + f.height - l.yAxis.len, 0 < n && n < f.height && (f.height -= n), d && (f = {\n        x: l.yAxis.len - f.y - f.height,\n        y: l.xAxis.len - f.x - f.width,\n        width: f.height,\n        height: f.width\n      }), q || (d ? (f.x += p ? 0 : f.width, f.width = 0) : (f.y += p ? f.height : 0, f.height = 0)));\n      k.align = r(k.align, !d || q ? \"center\" : p ? \"right\" : \"left\");\n      k.verticalAlign = r(k.verticalAlign, d || q ? \"middle\" : p ? \"top\" : \"bottom\");\n      m.prototype.alignDataLabel.call(this, c, g, k, f, a);\n      k.inside && c.contrastColor && g.css({\n        color: c.contrastColor\n      });\n    });\n  });\n  O(q, \"modules/overlapping-datalabels.src.js\", [q[\"parts/Chart.js\"], q[\"parts/Utilities.js\"]], function (g, c) {\n    var q = c.addEvent,\n        y = c.fireEvent,\n        B = c.isArray,\n        H = c.isNumber,\n        D = c.objectEach,\n        J = c.pick;\n    q(g, \"render\", function () {\n      var c = [];\n      (this.labelCollectors || []).forEach(function (g) {\n        c = c.concat(g());\n      });\n      (this.yAxis || []).forEach(function (g) {\n        g.stacking && g.options.stackLabels && !g.options.stackLabels.allowOverlap && D(g.stacking.stacks, function (g) {\n          D(g, function (g) {\n            c.push(g.label);\n          });\n        });\n      });\n      (this.series || []).forEach(function (g) {\n        var q = g.options.dataLabels;\n        g.visible && (!1 !== q.enabled || g._hasPointLabels) && (g.nodes || g.points).forEach(function (g) {\n          g.visible && (B(g.dataLabels) ? g.dataLabels : g.dataLabel ? [g.dataLabel] : []).forEach(function (q) {\n            var n = q.options;\n            q.labelrank = J(n.labelrank, g.labelrank, g.shapeArgs && g.shapeArgs.height);\n            n.allowOverlap || c.push(q);\n          });\n        });\n      });\n      this.hideOverlappingLabels(c);\n    });\n\n    g.prototype.hideOverlappingLabels = function (c) {\n      var g = this,\n          q = c.length,\n          t = g.renderer,\n          B,\n          n,\n          r,\n          C = !1;\n\n      var D = function D(c) {\n        var d,\n            g = c.box ? 0 : c.padding || 0,\n            f = d = 0,\n            a;\n\n        if (c && (!c.alignAttr || c.placed)) {\n          var m = c.alignAttr || {\n            x: c.attr(\"x\"),\n            y: c.attr(\"y\")\n          };\n          var n = c.parentGroup;\n          c.width || (d = c.getBBox(), c.width = d.width, c.height = d.height, d = t.fontMetrics(null, c.element).h);\n          var p = c.width - 2 * g;\n          (a = {\n            left: \"0\",\n            center: \"0.5\",\n            right: \"1\"\n          }[c.alignValue]) ? f = +a * p : H(c.x) && Math.round(c.x) !== c.translateX && (f = c.x - c.translateX);\n          return {\n            x: m.x + (n.translateX || 0) + g - f,\n            y: m.y + (n.translateY || 0) + g - d,\n            width: c.width - 2 * g,\n            height: c.height - 2 * g\n          };\n        }\n      };\n\n      for (n = 0; n < q; n++) if (B = c[n]) B.oldOpacity = B.opacity, B.newOpacity = 1, B.absoluteBox = D(B);\n\n      c.sort(function (c, g) {\n        return (g.labelrank || 0) - (c.labelrank || 0);\n      });\n\n      for (n = 0; n < q; n++) {\n        var p = (D = c[n]) && D.absoluteBox;\n\n        for (B = n + 1; B < q; ++B) {\n          var m = (r = c[B]) && r.absoluteBox;\n          !p || !m || D === r || 0 === D.newOpacity || 0 === r.newOpacity || m.x > p.x + p.width || m.x + m.width < p.x || m.y > p.y + p.height || m.y + m.height < p.y || ((D.labelrank < r.labelrank ? D : r).newOpacity = 0);\n        }\n      }\n\n      c.forEach(function (c) {\n        if (c) {\n          var d = c.newOpacity;\n          c.oldOpacity !== d && (c.alignAttr && c.placed ? (c[d ? \"removeClass\" : \"addClass\"](\"highcharts-data-label-hidden\"), C = !0, c.alignAttr.opacity = d, c[c.isOld ? \"animate\" : \"attr\"](c.alignAttr, null, function () {\n            g.styledMode || c.css({\n              pointerEvents: d ? \"auto\" : \"none\"\n            });\n            c.visibility = d ? \"inherit\" : \"hidden\";\n            c.placed = !!d;\n          }), y(g, \"afterHideOverlappingLabel\")) : c.attr({\n            opacity: d\n          }));\n          c.isOld = !0;\n        }\n      });\n      C && y(g, \"afterHideAllOverlappingLabels\");\n    };\n  });\n  O(q, \"parts/Interaction.js\", [q[\"parts/Chart.js\"], q[\"parts/Globals.js\"], q[\"parts/Legend.js\"], q[\"parts/Options.js\"], q[\"parts/Point.js\"], q[\"parts/Utilities.js\"]], function (g, c, q, y, B, H) {\n    var D = y.defaultOptions,\n        J = H.addEvent,\n        t = H.createElement,\n        G = H.css,\n        L = H.defined,\n        v = H.extend,\n        K = H.fireEvent,\n        n = H.isArray,\n        r = H.isFunction,\n        C = H.isNumber,\n        I = H.isObject,\n        p = H.merge,\n        m = H.objectEach,\n        d = H.pick,\n        l = c.hasTouch;\n    y = c.Series;\n    H = c.seriesTypes;\n    var k = c.svg;\n    var f = c.TrackerMixin = {\n      drawTrackerPoint: function drawTrackerPoint() {\n        var a = this,\n            c = a.chart,\n            d = c.pointer,\n            f = function f(a) {\n          var c = d.getPointFromEvent(a);\n          \"undefined\" !== typeof c && (d.isDirectTouch = !0, c.onMouseOver(a));\n        },\n            g;\n\n        a.points.forEach(function (a) {\n          g = n(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];\n          a.graphic && (a.graphic.element.point = a);\n          g.forEach(function (c) {\n            c.div ? c.div.point = a : c.element.point = a;\n          });\n        });\n        a._hasTracking || (a.trackerGroups.forEach(function (g) {\n          if (a[g]) {\n            a[g].addClass(\"highcharts-tracker\").on(\"mouseover\", f).on(\"mouseout\", function (a) {\n              d.onTrackerMouseOut(a);\n            });\n            if (l) a[g].on(\"touchstart\", f);\n            !c.styledMode && a.options.cursor && a[g].css(G).css({\n              cursor: a.options.cursor\n            });\n          }\n        }), a._hasTracking = !0);\n        K(this, \"afterDrawTracker\");\n      },\n      drawTrackerGraph: function drawTrackerGraph() {\n        var a = this,\n            c = a.options,\n            d = c.trackByArea,\n            f = [].concat(d ? a.areaPath : a.graphPath),\n            g = a.chart,\n            m = g.pointer,\n            n = g.renderer,\n            p = g.options.tooltip.snap,\n            q = a.tracker,\n            e = function e(b) {\n          if (g.hoverSeries !== a) a.onMouseOver();\n        },\n            b = \"rgba(192,192,192,\" + (k ? .0001 : .002) + \")\";\n\n        q ? q.attr({\n          d: f\n        }) : a.graph && (a.tracker = n.path(f).attr({\n          visibility: a.visible ? \"visible\" : \"hidden\",\n          zIndex: 2\n        }).addClass(d ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(a.group), g.styledMode || a.tracker.attr({\n          \"stroke-linecap\": \"round\",\n          \"stroke-linejoin\": \"round\",\n          stroke: b,\n          fill: d ? b : \"none\",\n          \"stroke-width\": a.graph.strokeWidth() + (d ? 0 : 2 * p)\n        }), [a.tracker, a.markerGroup].forEach(function (a) {\n          a.addClass(\"highcharts-tracker\").on(\"mouseover\", e).on(\"mouseout\", function (a) {\n            m.onTrackerMouseOut(a);\n          });\n          c.cursor && !g.styledMode && a.css({\n            cursor: c.cursor\n          });\n          if (l) a.on(\"touchstart\", e);\n        }));\n        K(this, \"afterDrawTracker\");\n      }\n    };\n    H.column && (H.column.prototype.drawTracker = f.drawTrackerPoint);\n    H.pie && (H.pie.prototype.drawTracker = f.drawTrackerPoint);\n    H.scatter && (H.scatter.prototype.drawTracker = f.drawTrackerPoint);\n    v(q.prototype, {\n      setItemEvents: function setItemEvents(a, c, d) {\n        var f = this,\n            g = f.chart.renderer.boxWrapper,\n            k = a instanceof B,\n            l = \"highcharts-legend-\" + (k ? \"point\" : \"series\") + \"-active\",\n            m = f.chart.styledMode;\n        (d ? [c, a.legendSymbol] : [a.legendGroup]).forEach(function (d) {\n          if (d) d.on(\"mouseover\", function () {\n            a.visible && f.allItems.forEach(function (c) {\n              a !== c && c.setState(\"inactive\", !k);\n            });\n            a.setState(\"hover\");\n            a.visible && g.addClass(l);\n            m || c.css(f.options.itemHoverStyle);\n          }).on(\"mouseout\", function () {\n            f.chart.styledMode || c.css(p(a.visible ? f.itemStyle : f.itemHiddenStyle));\n            f.allItems.forEach(function (c) {\n              a !== c && c.setState(\"\", !k);\n            });\n            g.removeClass(l);\n            a.setState();\n          }).on(\"click\", function (c) {\n            var b = function b() {\n              a.setVisible && a.setVisible();\n              f.allItems.forEach(function (b) {\n                a !== b && b.setState(a.visible ? \"inactive\" : \"\", !k);\n              });\n            };\n\n            g.removeClass(l);\n            c = {\n              browserEvent: c\n            };\n            a.firePointEvent ? a.firePointEvent(\"legendItemClick\", c, b) : K(a, \"legendItemClick\", c, b);\n          });\n        });\n      },\n      createCheckboxForItem: function createCheckboxForItem(a) {\n        a.checkbox = t(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: a.selected,\n          defaultChecked: a.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        J(a.checkbox, \"click\", function (c) {\n          K(a.series || a, \"checkboxClick\", {\n            checked: c.target.checked,\n            item: a\n          }, function () {\n            a.select();\n          });\n        });\n      }\n    });\n    v(g.prototype, {\n      showResetZoom: function showResetZoom() {\n        function a() {\n          c.zoomOut();\n        }\n\n        var c = this,\n            d = D.lang,\n            f = c.options.chart.resetZoomButton,\n            g = f.theme,\n            k = g.states,\n            l = \"chart\" === f.relativeTo || \"spaceBox\" === f.relativeTo ? null : \"plotBox\";\n        K(this, \"beforeShowResetZoom\", null, function () {\n          c.resetZoomButton = c.renderer.button(d.resetZoom, null, null, a, g, k && k.hover).attr({\n            align: f.position.align,\n            title: d.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(f.position, !1, l);\n        });\n        K(this, \"afterShowResetZoom\");\n      },\n      zoomOut: function zoomOut() {\n        K(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      },\n      zoom: function zoom(a) {\n        var c = this,\n            f,\n            g = c.pointer,\n            k = !1,\n            l = c.inverted ? g.mouseDownX : g.mouseDownY;\n        !a || a.resetSelection ? (c.axes.forEach(function (a) {\n          f = a.zoom();\n        }), g.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {\n          var d = a.axis,\n              e = c.inverted ? d.left : d.top,\n              b = c.inverted ? e + d.width : e + d.height,\n              h = d.isXAxis,\n              m = !1;\n          if (!h && l >= e && l <= b || h || !L(l)) m = !0;\n          g[h ? \"zoomX\" : \"zoomY\"] && m && (f = d.zoom(a.min, a.max), d.displayBtn && (k = !0));\n        });\n        var m = c.resetZoomButton;\n        k && !m ? c.showResetZoom() : !k && I(m) && (c.resetZoomButton = m.destroy());\n        f && c.redraw(d(c.options.chart.animation, a && a.animation, 100 > c.pointCount));\n      },\n      pan: function pan(a, d) {\n        var f = this,\n            g = f.hoverPoints,\n            k = f.options.chart,\n            l = f.options.mapNavigation && f.options.mapNavigation.enabled,\n            m;\n        d = \"object\" === typeof d ? d : {\n          enabled: d,\n          type: \"x\"\n        };\n        k && k.panning && (k.panning = d);\n        var n = d.type;\n        K(this, \"pan\", {\n          originalEvent: a\n        }, function () {\n          g && g.forEach(function (a) {\n            a.setState();\n          });\n          var d = [1];\n          \"xy\" === n ? d = [1, 0] : \"y\" === n && (d = [0]);\n          d.forEach(function (d) {\n            var b = f[d ? \"xAxis\" : \"yAxis\"][0],\n                e = b.horiz,\n                g = a[e ? \"chartX\" : \"chartY\"];\n            e = e ? \"mouseDownX\" : \"mouseDownY\";\n            var k = f[e],\n                p = (b.pointRange || 0) / 2,\n                q = b.reversed && !f.inverted || !b.reversed && f.inverted ? -1 : 1,\n                r = b.getExtremes(),\n                u = b.toValue(k - g, !0) + p * q;\n            q = b.toValue(k + b.len - g, !0) - p * q;\n            var t = q < u;\n            k = t ? q : u;\n            u = t ? u : q;\n            var w = b.hasVerticalPanning(),\n                v = b.panningState;\n            b.series.forEach(function (a) {\n              if (w && !d && (!v || v.isDirty)) {\n                var b = a.getProcessedData(!0);\n                a = a.getExtremes(b.yData, !0);\n                v || (v = {\n                  startMin: Number.MAX_VALUE,\n                  startMax: -Number.MAX_VALUE\n                });\n                C(a.dataMin) && C(a.dataMax) && (v.startMin = Math.min(a.dataMin, v.startMin), v.startMax = Math.max(a.dataMax, v.startMax));\n              }\n            });\n            q = Math.min(c.pick(null === v || void 0 === v ? void 0 : v.startMin, r.dataMin), p ? r.min : b.toValue(b.toPixels(r.min) - b.minPixelPadding));\n            p = Math.max(c.pick(null === v || void 0 === v ? void 0 : v.startMax, r.dataMax), p ? r.max : b.toValue(b.toPixels(r.max) + b.minPixelPadding));\n            b.panningState = v;\n            b.isOrdinal || (t = q - k, 0 < t && (u += t, k = q), t = u - p, 0 < t && (u = p, k -= t), b.series.length && k !== r.min && u !== r.max && k >= q && u <= p && (b.setExtremes(k, u, !1, !1, {\n              trigger: \"pan\"\n            }), f.resetZoomButton || l || k === q || u === p || !n.match(\"y\") || (f.showResetZoom(), b.displayBtn = !1), m = !0), f[e] = g);\n          });\n          m && f.redraw(!1);\n          G(f.container, {\n            cursor: \"move\"\n          });\n        });\n      }\n    });\n    v(B.prototype, {\n      select: function select(a, c) {\n        var f = this,\n            g = f.series,\n            k = g.chart;\n        this.selectedStaging = a = d(a, !f.selected);\n        f.firePointEvent(a ? \"select\" : \"unselect\", {\n          accumulate: c\n        }, function () {\n          f.selected = f.options.selected = a;\n          g.options.data[g.data.indexOf(f)] = f.options;\n          f.setState(a && \"select\");\n          c || k.getSelectedPoints().forEach(function (a) {\n            var c = a.series;\n            a.selected && a !== f && (a.selected = a.options.selected = !1, c.options.data[c.data.indexOf(a)] = a.options, a.setState(k.hoverPoints && c.options.inactiveOtherPoints ? \"inactive\" : \"\"), a.firePointEvent(\"unselect\"));\n          });\n        });\n        delete this.selectedStaging;\n      },\n      onMouseOver: function onMouseOver(a) {\n        var c = this.series.chart,\n            d = c.pointer;\n        a = a ? d.normalize(a) : d.getChartCoordinatesFromPoint(this, c.inverted);\n        d.runPointActions(a, this);\n      },\n      onMouseOut: function onMouseOut() {\n        var a = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (a) {\n          a.setState();\n        });\n        a.hoverPoints = a.hoverPoint = null;\n      },\n      importEvents: function importEvents() {\n        if (!this.hasImportedEvents) {\n          var a = this,\n              c = p(a.series.options.point, a.options).events;\n          a.events = c;\n          m(c, function (c, d) {\n            r(c) && J(a, d, c);\n          });\n          this.hasImportedEvents = !0;\n        }\n      },\n      setState: function setState(a, c) {\n        var f = this.series,\n            g = this.state,\n            k = f.options.states[a || \"normal\"] || {},\n            l = D.plotOptions[f.type].marker && f.options.marker,\n            m = l && !1 === l.enabled,\n            n = l && l.states && l.states[a || \"normal\"] || {},\n            p = !1 === n.enabled,\n            e = f.stateMarkerGraphic,\n            b = this.marker || {},\n            h = f.chart,\n            q = f.halo,\n            r,\n            t = l && f.markerAttribs;\n        a = a || \"\";\n\n        if (!(a === this.state && !c || this.selected && \"select\" !== a || !1 === k.enabled || a && (p || m && !1 === n.enabled) || a && b.states && b.states[a] && !1 === b.states[a].enabled)) {\n          this.state = a;\n          t && (r = f.markerAttribs(this, a));\n\n          if (this.graphic) {\n            g && this.graphic.removeClass(\"highcharts-point-\" + g);\n            a && this.graphic.addClass(\"highcharts-point-\" + a);\n\n            if (!h.styledMode) {\n              var y = f.pointAttribs(this, a);\n              var A = d(h.options.chart.animation, k.animation);\n              f.options.inactiveOtherPoints && y.opacity && ((this.dataLabels || []).forEach(function (a) {\n                a && a.animate({\n                  opacity: y.opacity\n                }, A);\n              }), this.connector && this.connector.animate({\n                opacity: y.opacity\n              }, A));\n              this.graphic.animate(y, A);\n            }\n\n            r && this.graphic.animate(r, d(h.options.chart.animation, n.animation, l.animation));\n            e && e.hide();\n          } else {\n            if (a && n) {\n              g = b.symbol || f.symbol;\n              e && e.currentSymbol !== g && (e = e.destroy());\n              if (r) if (e) e[c ? \"animate\" : \"attr\"]({\n                x: r.x,\n                y: r.y\n              });else g && (f.stateMarkerGraphic = e = h.renderer.symbol(g, r.x, r.y, r.width, r.height).add(f.markerGroup), e.currentSymbol = g);\n              !h.styledMode && e && e.attr(f.pointAttribs(this, a));\n            }\n\n            e && (e[a && this.isInside ? \"show\" : \"hide\"](), e.element.point = this);\n          }\n\n          a = k.halo;\n          k = (e = this.graphic || e) && e.visibility || \"inherit\";\n          a && a.size && e && \"hidden\" !== k && !this.isCluster ? (q || (f.halo = q = h.renderer.path().add(e.parentGroup)), q.show()[c ? \"animate\" : \"attr\"]({\n            d: this.haloPath(a.size)\n          }), q.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + d(this.colorIndex, f.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            visibility: k,\n            zIndex: -1\n          }), q.point = this, h.styledMode || q.attr(v({\n            fill: this.color || f.color,\n            \"fill-opacity\": a.opacity\n          }, a.attributes))) : q && q.point && q.point.haloPath && q.animate({\n            d: q.point.haloPath(0)\n          }, null, q.hide);\n          K(this, \"afterSetState\");\n        }\n      },\n      haloPath: function haloPath(a) {\n        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);\n      }\n    });\n    v(y.prototype, {\n      onMouseOver: function onMouseOver() {\n        var a = this.chart,\n            c = a.hoverSeries;\n        a.pointer.setHoverChartIndex();\n        if (c && c !== this) c.onMouseOut();\n        this.options.events.mouseOver && K(this, \"mouseOver\");\n        this.setState(\"hover\");\n        a.hoverSeries = this;\n      },\n      onMouseOut: function onMouseOut() {\n        var a = this.options,\n            c = this.chart,\n            d = c.tooltip,\n            f = c.hoverPoint;\n        c.hoverSeries = null;\n        if (f) f.onMouseOut();\n        this && a.events.mouseOut && K(this, \"mouseOut\");\n        !d || this.stickyTracking || d.shared && !this.noSharedTooltip || d.hide();\n        c.series.forEach(function (a) {\n          a.setState(\"\", !0);\n        });\n      },\n      setState: function setState(a, c) {\n        var f = this,\n            g = f.options,\n            k = f.graph,\n            l = g.inactiveOtherPoints,\n            m = g.states,\n            n = g.lineWidth,\n            p = g.opacity,\n            e = d(m[a || \"normal\"] && m[a || \"normal\"].animation, f.chart.options.chart.animation);\n        g = 0;\n        a = a || \"\";\n\n        if (f.state !== a && ([f.group, f.markerGroup, f.dataLabelsGroup].forEach(function (b) {\n          b && (f.state && b.removeClass(\"highcharts-series-\" + f.state), a && b.addClass(\"highcharts-series-\" + a));\n        }), f.state = a, !f.chart.styledMode)) {\n          if (m[a] && !1 === m[a].enabled) return;\n          a && (n = m[a].lineWidth || n + (m[a].lineWidthPlus || 0), p = d(m[a].opacity, p));\n          if (k && !k.dashstyle) for (m = {\n            \"stroke-width\": n\n          }, k.animate(m, e); f[\"zone-graph-\" + g];) f[\"zone-graph-\" + g].attr(m), g += 1;\n          l || [f.group, f.markerGroup, f.dataLabelsGroup, f.labelBySeries].forEach(function (a) {\n            a && a.animate({\n              opacity: p\n            }, e);\n          });\n        }\n\n        c && l && f.points && f.setAllPointsToState(a);\n      },\n      setAllPointsToState: function setAllPointsToState(a) {\n        this.points.forEach(function (c) {\n          c.setState && c.setState(a);\n        });\n      },\n      setVisible: function setVisible(a, c) {\n        var d = this,\n            f = d.chart,\n            g = d.legendItem,\n            k = f.options.chart.ignoreHiddenSeries,\n            l = d.visible;\n        var m = (d.visible = a = d.options.visible = d.userOptions.visible = \"undefined\" === typeof a ? !l : a) ? \"show\" : \"hide\";\n        [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (a) {\n          if (d[a]) d[a][m]();\n        });\n        if (f.hoverSeries === d || (f.hoverPoint && f.hoverPoint.series) === d) d.onMouseOut();\n        g && f.legend.colorizeItem(d, a);\n        d.isDirty = !0;\n        d.options.stacking && f.series.forEach(function (a) {\n          a.options.stacking && a.visible && (a.isDirty = !0);\n        });\n        d.linkedSeries.forEach(function (c) {\n          c.setVisible(a, !1);\n        });\n        k && (f.isDirtyBox = !0);\n        K(d, m);\n        !1 !== c && f.redraw();\n      },\n      show: function show() {\n        this.setVisible(!0);\n      },\n      hide: function hide() {\n        this.setVisible(!1);\n      },\n      select: function select(a) {\n        this.selected = a = this.options.selected = \"undefined\" === typeof a ? !this.selected : a;\n        this.checkbox && (this.checkbox.checked = a);\n        K(this, a ? \"select\" : \"unselect\");\n      },\n      drawTracker: f.drawTrackerGraph\n    });\n  });\n  O(q, \"parts/Responsive.js\", [q[\"parts/Chart.js\"], q[\"parts/Utilities.js\"]], function (g, c) {\n    var q = c.find,\n        y = c.isArray,\n        B = c.isObject,\n        H = c.merge,\n        D = c.objectEach,\n        J = c.pick,\n        t = c.splat,\n        G = c.uniqueKey;\n\n    g.prototype.setResponsive = function (c, g) {\n      var t = this.options.responsive,\n          n = [],\n          r = this.currentResponsive;\n      !g && t && t.rules && t.rules.forEach(function (c) {\n        \"undefined\" === typeof c._id && (c._id = G());\n        this.matchResponsiveRule(c, n);\n      }, this);\n      g = H.apply(0, n.map(function (c) {\n        return q(t.rules, function (g) {\n          return g._id === c;\n        }).chartOptions;\n      }));\n      g.isResponsiveOptions = !0;\n      n = n.toString() || void 0;\n      n !== (r && r.ruleIds) && (r && this.update(r.undoOptions, c, !0), n ? (r = this.currentOptions(g), r.isResponsiveOptions = !0, this.currentResponsive = {\n        ruleIds: n,\n        mergedOptions: g,\n        undoOptions: r\n      }, this.update(g, c, !0)) : this.currentResponsive = void 0);\n    };\n\n    g.prototype.matchResponsiveRule = function (c, g) {\n      var q = c.condition;\n      (q.callback || function () {\n        return this.chartWidth <= J(q.maxWidth, Number.MAX_VALUE) && this.chartHeight <= J(q.maxHeight, Number.MAX_VALUE) && this.chartWidth >= J(q.minWidth, 0) && this.chartHeight >= J(q.minHeight, 0);\n      }).call(this) && g.push(c._id);\n    };\n\n    g.prototype.currentOptions = function (c) {\n      function g(c, n, v, p) {\n        var m;\n        D(c, function (c, l) {\n          if (!p && -1 < q.collectionsWithUpdate.indexOf(l)) for (c = t(c), v[l] = [], m = 0; m < Math.max(c.length, n[l].length); m++) n[l][m] && (void 0 === c[m] ? v[l][m] = n[l][m] : (v[l][m] = {}, g(c[m], n[l][m], v[l][m], p + 1)));else B(c) ? (v[l] = y(c) ? [] : {}, g(c, n[l] || {}, v[l], p + 1)) : v[l] = \"undefined\" === typeof n[l] ? null : n[l];\n        });\n      }\n\n      var q = this,\n          n = {};\n      g(c, this.options, n, 0);\n      return n;\n    };\n  });\n  O(q, \"masters/highcharts.src.js\", [q[\"parts/Globals.js\"]], function (g) {\n    return g;\n  });\n  q[\"masters/highcharts.src.js\"]._modules = q;\n  return q[\"masters/highcharts.src.js\"];\n});","map":null,"metadata":{},"sourceType":"script"}