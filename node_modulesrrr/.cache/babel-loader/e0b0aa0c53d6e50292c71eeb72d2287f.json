{"ast":null,"code":"(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['d3'], function (d3) {\n      return root.Rickshaw = factory(d3);\n    });\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('d3'));\n  } else {\n    root.Rickshaw = factory(d3);\n  }\n})(this, function (d3) {\n  /* jshint -W079 */\n  var Rickshaw = {\n    version: '1.7.1',\n    namespace: function namespace(_namespace, obj) {\n      var parts = _namespace.split('.');\n\n      var parent = Rickshaw;\n\n      for (var i = 1, length = parts.length; i < length; i++) {\n        var currentPart = parts[i];\n        parent[currentPart] = parent[currentPart] || {};\n        parent = parent[currentPart];\n      }\n\n      return parent;\n    },\n    keys: function keys(obj) {\n      var keys = [];\n\n      for (var key in obj) keys.push(key);\n\n      return keys;\n    },\n    extend: function extend(destination, source) {\n      for (var property in source) {\n        destination[property] = source[property];\n      }\n\n      return destination;\n    },\n    clone: function clone(obj) {\n      return JSON.parse(JSON.stringify(obj));\n    }\n  };\n  /* Adapted from https://github.com/Jakobo/PTClass */\n\n  /*\n  Copyright (c) 2005-2010 Sam Stephenson\n  \n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n  \n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n  */\n\n  /* Based on Alex Arnell's inheritance implementation. */\n\n  /** section: Language\n   * class Class\n   *\n   *  Manages Prototype's class-based OOP system.\n   *\n   *  Refer to Prototype's web site for a [tutorial on classes and\n   *  inheritance](http://prototypejs.org/learn/class-inheritance).\n  **/\n\n  (function (globalContext) {\n    /* ------------------------------------ */\n\n    /* Import from object.js                */\n\n    /* ------------------------------------ */\n    var _toString = Object.prototype.toString,\n        NULL_TYPE = 'Null',\n        UNDEFINED_TYPE = 'Undefined',\n        BOOLEAN_TYPE = 'Boolean',\n        NUMBER_TYPE = 'Number',\n        STRING_TYPE = 'String',\n        OBJECT_TYPE = 'Object',\n        FUNCTION_CLASS = '[object Function]';\n\n    function isFunction(object) {\n      return _toString.call(object) === FUNCTION_CLASS;\n    }\n\n    function extend(destination, source) {\n      for (var property in source) if (source.hasOwnProperty(property)) // modify protect primitive slaughter\n        destination[property] = source[property];\n\n      return destination;\n    }\n\n    function keys(object) {\n      if (Type(object) !== OBJECT_TYPE) {\n        throw new TypeError();\n      }\n\n      var results = [];\n\n      for (var property in object) {\n        if (object.hasOwnProperty(property)) {\n          results.push(property);\n        }\n      }\n\n      return results;\n    }\n\n    function Type(o) {\n      switch (o) {\n        case null:\n          return NULL_TYPE;\n\n        case void 0:\n          return UNDEFINED_TYPE;\n      }\n\n      var type = typeof o;\n\n      switch (type) {\n        case 'boolean':\n          return BOOLEAN_TYPE;\n\n        case 'number':\n          return NUMBER_TYPE;\n\n        case 'string':\n          return STRING_TYPE;\n      }\n\n      return OBJECT_TYPE;\n    }\n\n    function isUndefined(object) {\n      return typeof object === \"undefined\";\n    }\n    /* ------------------------------------ */\n\n    /* Import from Function.js              */\n\n    /* ------------------------------------ */\n\n\n    var slice = Array.prototype.slice;\n\n    function argumentNames(fn) {\n      var names = fn.toString().match(/^[\\s\\(]*function[^(]*\\(([^)]*)\\)/)[1].replace(/\\/\\/.*?[\\r\\n]|\\/\\*(?:.|[\\r\\n])*?\\*\\//g, '').replace(/\\s+/g, '').split(',');\n      return names.length == 1 && !names[0] ? [] : names;\n    }\n\n    function wrap(fn, wrapper) {\n      var __method = fn;\n      return function () {\n        var a = update([bind(__method, this)], arguments);\n        return wrapper.apply(this, a);\n      };\n    }\n\n    function update(array, args) {\n      var arrayLength = array.length,\n          length = args.length;\n\n      while (length--) array[arrayLength + length] = args[length];\n\n      return array;\n    }\n\n    function merge(array, args) {\n      array = slice.call(array, 0);\n      return update(array, args);\n    }\n\n    function bind(fn, context) {\n      if (arguments.length < 2 && isUndefined(arguments[0])) return this;\n      var __method = fn,\n          args = slice.call(arguments, 2);\n      return function () {\n        var a = merge(args, arguments);\n        return __method.apply(context, a);\n      };\n    }\n    /* ------------------------------------ */\n\n    /* Import from Prototype.js             */\n\n    /* ------------------------------------ */\n\n\n    var emptyFunction = function emptyFunction() {};\n\n    var Class = function () {\n      // Some versions of JScript fail to enumerate over properties, names of which \n      // correspond to non-enumerable properties in the prototype chain\n      var IS_DONTENUM_BUGGY = function () {\n        for (var p in {\n          toString: 1\n        }) {\n          // check actual property name, so that it works with augmented Object.prototype\n          if (p === 'toString') return false;\n        }\n\n        return true;\n      }();\n\n      function subclass() {}\n\n      ;\n\n      function create() {\n        var parent = null,\n            properties = [].slice.apply(arguments);\n        if (isFunction(properties[0])) parent = properties.shift();\n\n        function klass() {\n          this.initialize.apply(this, arguments);\n        }\n\n        extend(klass, Class.Methods);\n        klass.superclass = parent;\n        klass.subclasses = [];\n\n        if (parent) {\n          subclass.prototype = parent.prototype;\n          klass.prototype = new subclass();\n\n          try {\n            parent.subclasses.push(klass);\n          } catch (e) {}\n        }\n\n        for (var i = 0, length = properties.length; i < length; i++) klass.addMethods(properties[i]);\n\n        if (!klass.prototype.initialize) klass.prototype.initialize = emptyFunction;\n        klass.prototype.constructor = klass;\n        return klass;\n      }\n\n      function addMethods(source) {\n        var ancestor = this.superclass && this.superclass.prototype,\n            properties = keys(source); // IE6 doesn't enumerate `toString` and `valueOf` (among other built-in `Object.prototype`) properties,\n        // Force copy if they're not Object.prototype ones.\n        // Do not copy other Object.prototype.* for performance reasons\n\n        if (IS_DONTENUM_BUGGY) {\n          if (source.toString != Object.prototype.toString) properties.push(\"toString\");\n          if (source.valueOf != Object.prototype.valueOf) properties.push(\"valueOf\");\n        }\n\n        for (var i = 0, length = properties.length; i < length; i++) {\n          var property = properties[i],\n              value = source[property];\n\n          if (ancestor && isFunction(value) && argumentNames(value)[0] == \"$super\") {\n            var method = value;\n            value = wrap(function (m) {\n              return function () {\n                return ancestor[m].apply(this, arguments);\n              };\n            }(property), method);\n            value.valueOf = bind(method.valueOf, method);\n            value.toString = bind(method.toString, method);\n          }\n\n          this.prototype[property] = value;\n        }\n\n        return this;\n      }\n\n      return {\n        create: create,\n        Methods: {\n          addMethods: addMethods\n        }\n      };\n    }();\n\n    if (globalContext.exports) {\n      globalContext.exports.Class = Class;\n    } else {\n      globalContext.Class = Class;\n    }\n  })(Rickshaw);\n\n  Rickshaw.namespace('Rickshaw.Compat.ClassList');\n\n  Rickshaw.Compat.ClassList = function () {\n    /* adapted from http://purl.eligrey.com/github/classList.js/blob/master/classList.js */\n    if (typeof document !== \"undefined\" && !(\"classList\" in document.createElement(\"a\"))) {\n      (function (view) {\n        \"use strict\";\n\n        var classListProp = \"classList\",\n            protoProp = \"prototype\",\n            elemCtrProto = (view.HTMLElement || view.Element)[protoProp],\n            objCtr = Object,\n            strTrim = String[protoProp].trim || function () {\n          return this.replace(/^\\s+|\\s+$/g, \"\");\n        },\n            arrIndexOf = Array[protoProp].indexOf || function (item) {\n          var i = 0,\n              len = this.length;\n\n          for (; i < len; i++) {\n            if (i in this && this[i] === item) {\n              return i;\n            }\n          }\n\n          return -1;\n        } // Vendors: please allow content code to instantiate DOMExceptions\n        ,\n            DOMEx = function DOMEx(type, message) {\n          this.name = type;\n          this.code = DOMException[type];\n          this.message = message;\n        },\n            checkTokenAndGetIndex = function checkTokenAndGetIndex(classList, token) {\n          if (token === \"\") {\n            throw new DOMEx(\"SYNTAX_ERR\", \"An invalid or illegal string was specified\");\n          }\n\n          if (/\\s/.test(token)) {\n            throw new DOMEx(\"INVALID_CHARACTER_ERR\", \"String contains an invalid character\");\n          }\n\n          return arrIndexOf.call(classList, token);\n        },\n            ClassList = function ClassList(elem) {\n          var trimmedClasses = strTrim.call(elem.className),\n              classes = trimmedClasses ? trimmedClasses.split(/\\s+/) : [],\n              i = 0,\n              len = classes.length;\n\n          for (; i < len; i++) {\n            this.push(classes[i]);\n          }\n\n          this._updateClassName = function () {\n            elem.className = this.toString();\n          };\n        },\n            classListProto = ClassList[protoProp] = [],\n            classListGetter = function classListGetter() {\n          return new ClassList(this);\n        }; // Most DOMException implementations don't allow calling DOMException's toString()\n        // on non-DOMExceptions. Error's toString() is sufficient here.\n\n\n        DOMEx[protoProp] = Error[protoProp];\n\n        classListProto.item = function (i) {\n          return this[i] || null;\n        };\n\n        classListProto.contains = function (token) {\n          token += \"\";\n          return checkTokenAndGetIndex(this, token) !== -1;\n        };\n\n        classListProto.add = function (token) {\n          token += \"\";\n\n          if (checkTokenAndGetIndex(this, token) === -1) {\n            this.push(token);\n\n            this._updateClassName();\n          }\n        };\n\n        classListProto.remove = function (token) {\n          token += \"\";\n          var index = checkTokenAndGetIndex(this, token);\n\n          if (index !== -1) {\n            this.splice(index, 1);\n\n            this._updateClassName();\n          }\n        };\n\n        classListProto.toggle = function (token) {\n          token += \"\";\n\n          if (checkTokenAndGetIndex(this, token) === -1) {\n            this.add(token);\n          } else {\n            this.remove(token);\n          }\n        };\n\n        classListProto.toString = function () {\n          return this.join(\" \");\n        };\n\n        if (objCtr.defineProperty) {\n          var classListPropDesc = {\n            get: classListGetter,\n            enumerable: true,\n            configurable: true\n          };\n\n          try {\n            objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n          } catch (ex) {\n            // IE 8 doesn't support enumerable:true\n            if (ex.number === -0x7FF5EC54) {\n              classListPropDesc.enumerable = false;\n              objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n            }\n          }\n        } else if (objCtr[protoProp].__defineGetter__) {\n          elemCtrProto.__defineGetter__(classListProp, classListGetter);\n        }\n      })(window);\n    }\n  };\n\n  if (typeof RICKSHAW_NO_COMPAT !== \"undefined\" && !RICKSHAW_NO_COMPAT || typeof RICKSHAW_NO_COMPAT === \"undefined\") {\n    new Rickshaw.Compat.ClassList();\n  }\n\n  Rickshaw.namespace('Rickshaw.Graph');\n\n  Rickshaw.Graph = function (args) {\n    var self = this;\n\n    this.initialize = function (args) {\n      if (!args.element) throw \"Rickshaw.Graph needs a reference to an element\";\n      if (args.element.nodeType !== 1) throw \"Rickshaw.Graph element was defined but not an HTML element\";\n      this.element = args.element;\n      this.series = args.series;\n      this.window = {};\n      this.updateCallbacks = [];\n      this.configureCallbacks = [];\n      this.defaults = {\n        interpolation: 'cardinal',\n        offset: 'zero',\n        min: undefined,\n        max: undefined,\n        preserve: false,\n        xScale: undefined,\n        yScale: undefined,\n        stack: true\n      };\n\n      this._loadRenderers();\n\n      this.configure(args);\n      this.setSeries(args.series);\n      this.setSize({\n        width: args.width,\n        height: args.height\n      });\n      this.element.classList.add('rickshaw_graph');\n      this.vis = d3.select(this.element).append(\"svg:svg\").attr('width', this.width).attr('height', this.height);\n      this.discoverRange();\n    };\n\n    this._loadRenderers = function () {\n      for (var name in Rickshaw.Graph.Renderer) {\n        if (!name || !Rickshaw.Graph.Renderer.hasOwnProperty(name)) continue;\n        var r = Rickshaw.Graph.Renderer[name];\n        if (!r || !r.prototype || !r.prototype.render) continue;\n        self.registerRenderer(new r({\n          graph: self\n        }));\n      }\n    };\n\n    this.validateSeries = function (series) {\n      if (!Array.isArray(series) && !(series instanceof Rickshaw.Series)) {\n        var seriesSignature = Object.prototype.toString.apply(series);\n        throw \"series is not an array: \" + seriesSignature;\n      }\n\n      var pointsCount;\n      series.forEach(function (s) {\n        if (!(s instanceof Object)) {\n          throw \"series element is not an object: \" + s;\n        }\n\n        if (!s.data) {\n          throw \"series has no data: \" + JSON.stringify(s);\n        }\n\n        if (!Array.isArray(s.data)) {\n          throw \"series data is not an array: \" + JSON.stringify(s.data);\n        }\n\n        if (s.data.length > 0) {\n          var x = s.data[0].x;\n          var y = s.data[0].y;\n\n          if (typeof x != 'number' || typeof y != 'number' && y !== null) {\n            throw \"x and y properties of points should be numbers instead of \" + typeof x + \" and \" + typeof y;\n          }\n        }\n\n        if (s.data.length >= 3) {\n          // probe to sanity check sort order\n          if (s.data[2].x < s.data[1].x || s.data[1].x < s.data[0].x || s.data[s.data.length - 1].x < s.data[0].x) {\n            throw \"series data needs to be sorted on x values for series name: \" + s.name;\n          }\n        }\n      }, this);\n    };\n\n    this.setSeries = function (series) {\n      this.validateSeries(series);\n      this.series = series;\n\n      this.series.active = function () {\n        return self.series.filter(function (s) {\n          return !s.disabled;\n        });\n      };\n    };\n\n    this.dataDomain = function () {\n      var data = this.series.map(function (s) {\n        return s.data;\n      });\n      var min = d3.min(data.map(function (d) {\n        return d[0].x;\n      }));\n      var max = d3.max(data.map(function (d) {\n        return d[d.length - 1].x;\n      }));\n      return [min, max];\n    };\n\n    this.discoverRange = function () {\n      var domain = this.renderer.domain(); // this.*Scale is coming from the configuration dictionary\n      // which may be referenced by the Graph creator, or shared\n      // with other Graphs. We need to ensure we copy the scale\n      // so that our mutations do not change the object given to us.\n      // Hence the .copy()\n\n      this.x = (this.xScale || d3.scale.linear()).copy().domain(domain.x).range([0, this.width]);\n      this.y = (this.yScale || d3.scale.linear()).copy().domain(domain.y).range([this.height, 0]);\n      this.x.magnitude = d3.scale.linear().domain([domain.x[0] - domain.x[0], domain.x[1] - domain.x[0]]).range([0, this.width]);\n      this.y.magnitude = d3.scale.linear().domain([domain.y[0] - domain.y[0], domain.y[1] - domain.y[0]]).range([0, this.height]);\n    };\n\n    this.render = function () {\n      var stackedData = this.stackData();\n      this.discoverRange();\n      this.renderer.render();\n      this.updateCallbacks.forEach(function (callback) {\n        callback();\n      });\n    };\n\n    this.update = this.render;\n\n    this.stackData = function () {\n      var data = this.series.active().map(function (d) {\n        return d.data;\n      }).map(function (d) {\n        return d.filter(function (d) {\n          return this._slice(d);\n        }, this);\n      }, this);\n      var preserve = this.preserve;\n\n      if (!preserve) {\n        this.series.forEach(function (series) {\n          if (series.scale) {\n            // data must be preserved when a scale is used\n            preserve = true;\n          }\n        });\n      }\n\n      data = preserve ? Rickshaw.clone(data) : data;\n      this.series.active().forEach(function (series, index) {\n        if (series.scale) {\n          // apply scale to each series\n          var seriesData = data[index];\n\n          if (seriesData) {\n            seriesData.forEach(function (d) {\n              d.y = series.scale(d.y);\n            });\n          }\n        }\n      });\n      this.stackData.hooks.data.forEach(function (entry) {\n        data = entry.f.apply(self, [data]);\n      });\n      var stackedData;\n\n      if (!this.renderer.unstack) {\n        this._validateStackable();\n\n        var layout = d3.layout.stack();\n        layout.offset(self.offset);\n        stackedData = layout(data);\n      }\n\n      stackedData = stackedData || data;\n\n      if (this.renderer.unstack) {\n        stackedData.forEach(function (seriesData) {\n          seriesData.forEach(function (d) {\n            d.y0 = d.y0 === undefined ? 0 : d.y0;\n          });\n        });\n      }\n\n      this.stackData.hooks.after.forEach(function (entry) {\n        stackedData = entry.f.apply(self, [data]);\n      });\n      var i = 0;\n      this.series.forEach(function (series) {\n        if (series.disabled) return;\n        series.stack = stackedData[i++];\n      });\n      this.stackedData = stackedData;\n      return stackedData;\n    };\n\n    this._validateStackable = function () {\n      var series = this.series;\n      var pointsCount;\n      series.forEach(function (s) {\n        pointsCount = pointsCount || s.data.length;\n\n        if (pointsCount && s.data.length != pointsCount) {\n          throw \"stacked series cannot have differing numbers of points: \" + pointsCount + \" vs \" + s.data.length + \"; see Rickshaw.Series.fill()\";\n        }\n      }, this);\n    };\n\n    this.stackData.hooks = {\n      data: [],\n      after: []\n    };\n\n    this._slice = function (d) {\n      if (this.window.xMin || this.window.xMax) {\n        var isInRange = true;\n        if (this.window.xMin && d.x < this.window.xMin) isInRange = false;\n        if (this.window.xMax && d.x > this.window.xMax) isInRange = false;\n        return isInRange;\n      }\n\n      return true;\n    };\n\n    this.onUpdate = function (callback) {\n      this.updateCallbacks.push(callback);\n    };\n\n    this.onConfigure = function (callback) {\n      this.configureCallbacks.push(callback);\n    };\n\n    this.registerRenderer = function (renderer) {\n      this._renderers = this._renderers || {};\n      this._renderers[renderer.name] = renderer;\n    };\n\n    this.configure = function (args) {\n      this.config = this.config || {};\n\n      if (args.width || args.height) {\n        this.setSize(args);\n      }\n\n      Rickshaw.keys(this.defaults).forEach(function (k) {\n        this.config[k] = k in args ? args[k] : k in this ? this[k] : this.defaults[k];\n      }, this);\n      Rickshaw.keys(this.config).forEach(function (k) {\n        this[k] = this.config[k];\n      }, this);\n      if ('stack' in args) args.unstack = !args.stack;\n      var renderer = args.renderer || this.renderer && this.renderer.name || 'stack';\n      this.setRenderer(renderer, args);\n      this.configureCallbacks.forEach(function (callback) {\n        callback(args);\n      });\n    };\n\n    this.setRenderer = function (r, args) {\n      if (typeof r == 'function') {\n        this.renderer = new r({\n          graph: self\n        });\n        this.registerRenderer(this.renderer);\n      } else {\n        if (!this._renderers[r]) {\n          throw \"couldn't find renderer \" + r;\n        }\n\n        this.renderer = this._renderers[r];\n      }\n\n      if (typeof args == 'object') {\n        this.renderer.configure(args);\n      }\n    };\n\n    this.setSize = function (args) {\n      args = args || {};\n\n      if (args.width && args.height) {\n        // use explicitly specified size\n        this.width = args.width;\n        this.height = args.height;\n      } else {\n        // calc size (will cause layout reflow)\n        if (typeof window !== 'undefined') {\n          var style = window.getComputedStyle(this.element, null);\n          var elementWidth = parseInt(style.getPropertyValue('width'), 10);\n          var elementHeight = parseInt(style.getPropertyValue('height'), 10);\n        }\n\n        this.width = args.width || elementWidth || 400;\n        this.height = args.height || elementHeight || 250;\n      }\n\n      this.vis && this.vis.attr('width', this.width).attr('height', this.height);\n    };\n\n    this.initialize(args);\n  };\n\n  Rickshaw.namespace('Rickshaw.Fixtures.Color');\n\n  Rickshaw.Fixtures.Color = function () {\n    this.schemes = {};\n    this.schemes.spectrum14 = ['#ecb796', '#dc8f70', '#b2a470', '#92875a', '#716c49', '#d2ed82', '#bbe468', '#a1d05d', '#e7cbe6', '#d8aad6', '#a888c2', '#9dc2d3', '#649eb9', '#387aa3'].reverse();\n    this.schemes.spectrum2000 = ['#57306f', '#514c76', '#646583', '#738394', '#6b9c7d', '#84b665', '#a7ca50', '#bfe746', '#e2f528', '#fff726', '#ecdd00', '#d4b11d', '#de8800', '#de4800', '#c91515', '#9a0000', '#7b0429', '#580839', '#31082b'];\n    this.schemes.spectrum2001 = ['#2f243f', '#3c2c55', '#4a3768', '#565270', '#6b6b7c', '#72957f', '#86ad6e', '#a1bc5e', '#b8d954', '#d3e04e', '#ccad2a', '#cc8412', '#c1521d', '#ad3821', '#8a1010', '#681717', '#531e1e', '#3d1818', '#320a1b'];\n    this.schemes.classic9 = ['#423d4f', '#4a6860', '#848f39', '#a2b73c', '#ddcb53', '#c5a32f', '#7d5836', '#963b20', '#7c2626', '#491d37', '#2f254a'].reverse();\n    this.schemes.httpStatus = {\n      503: '#ea5029',\n      502: '#d23f14',\n      500: '#bf3613',\n      410: '#efacea',\n      409: '#e291dc',\n      403: '#f457e8',\n      408: '#e121d2',\n      401: '#b92dae',\n      405: '#f47ceb',\n      404: '#a82a9f',\n      400: '#b263c6',\n      301: '#6fa024',\n      302: '#87c32b',\n      307: '#a0d84c',\n      304: '#28b55c',\n      200: '#1a4f74',\n      206: '#27839f',\n      201: '#52adc9',\n      202: '#7c979f',\n      203: '#a5b8bd',\n      204: '#c1cdd1'\n    };\n    this.schemes.colorwheel = ['#b5b6a9', '#858772', '#785f43', '#96557e', '#4682b4', '#65b9ac', '#73c03a', '#cb513a'].reverse();\n    this.schemes.cool = ['#5e9d2f', '#73c03a', '#4682b4', '#7bc3b8', '#a9884e', '#c1b266', '#a47493', '#c09fb5'];\n    this.schemes.munin = ['#00cc00', '#0066b3', '#ff8000', '#ffcc00', '#330099', '#990099', '#ccff00', '#ff0000', '#808080', '#008f00', '#00487d', '#b35a00', '#b38f00', '#6b006b', '#8fb300', '#b30000', '#bebebe', '#80ff80', '#80c9ff', '#ffc080', '#ffe680', '#aa80ff', '#ee00cc', '#ff8080', '#666600', '#ffbfff', '#00ffcc', '#cc6699', '#999900'];\n  };\n\n  Rickshaw.namespace('Rickshaw.Fixtures.RandomData');\n\n  Rickshaw.Fixtures.RandomData = function (timeInterval) {\n    var addData;\n    timeInterval = timeInterval || 1;\n    var lastRandomValue = 200;\n    var timeBase = Math.floor(new Date().getTime() / 1000);\n\n    this.addData = function (data) {\n      var randomValue = Math.random() * 100 + 15 + lastRandomValue;\n      var index = data[0].length;\n      var counter = 1;\n      data.forEach(function (series) {\n        var randomVariance = Math.random() * 20;\n        var v = randomValue / 25 + counter++ + (Math.cos(index * counter * 11 / 960) + 2) * 15 + (Math.cos(index / 7) + 2) * 7 + (Math.cos(index / 17) + 2) * 1;\n        series.push({\n          x: index * timeInterval + timeBase,\n          y: v + randomVariance\n        });\n      });\n      lastRandomValue = randomValue * 0.85;\n    };\n\n    this.removeData = function (data) {\n      data.forEach(function (series) {\n        series.shift();\n      });\n      timeBase += timeInterval;\n    };\n  };\n\n  Rickshaw.namespace('Rickshaw.Fixtures.Time');\n\n  Rickshaw.Fixtures.Time = function () {\n    var self = this;\n    this.months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n    this.units = [{\n      name: 'decade',\n      seconds: 86400 * 365.25 * 10,\n      formatter: function formatter(d) {\n        return parseInt(d.getUTCFullYear() / 10, 10) * 10;\n      }\n    }, {\n      name: 'year',\n      seconds: 86400 * 365.25,\n      formatter: function formatter(d) {\n        return d.getUTCFullYear();\n      }\n    }, {\n      name: 'month',\n      seconds: 86400 * 30.5,\n      formatter: function formatter(d) {\n        return self.months[d.getUTCMonth()];\n      }\n    }, {\n      name: 'week',\n      seconds: 86400 * 7,\n      formatter: function formatter(d) {\n        return self.formatDate(d);\n      }\n    }, {\n      name: 'day',\n      seconds: 86400,\n      formatter: function formatter(d) {\n        return d.getUTCDate();\n      }\n    }, {\n      name: '6 hour',\n      seconds: 3600 * 6,\n      formatter: function formatter(d) {\n        return self.formatTime(d);\n      }\n    }, {\n      name: 'hour',\n      seconds: 3600,\n      formatter: function formatter(d) {\n        return self.formatTime(d);\n      }\n    }, {\n      name: '15 minute',\n      seconds: 60 * 15,\n      formatter: function formatter(d) {\n        return self.formatTime(d);\n      }\n    }, {\n      name: 'minute',\n      seconds: 60,\n      formatter: function formatter(d) {\n        return d.getUTCMinutes() + 'm';\n      }\n    }, {\n      name: '15 second',\n      seconds: 15,\n      formatter: function formatter(d) {\n        return d.getUTCSeconds() + 's';\n      }\n    }, {\n      name: 'second',\n      seconds: 1,\n      formatter: function formatter(d) {\n        return d.getUTCSeconds() + 's';\n      }\n    }, {\n      name: 'decisecond',\n      seconds: 1 / 10,\n      formatter: function formatter(d) {\n        return d.getUTCMilliseconds() + 'ms';\n      }\n    }, {\n      name: 'centisecond',\n      seconds: 1 / 100,\n      formatter: function formatter(d) {\n        return d.getUTCMilliseconds() + 'ms';\n      }\n    }];\n\n    this.unit = function (unitName) {\n      return this.units.filter(function (unit) {\n        return unitName == unit.name;\n      }).shift();\n    };\n\n    this.formatDate = function (d) {\n      return d3.time.format('%b %e')(d);\n    };\n\n    this.formatTime = function (d) {\n      return d.toUTCString().match(/(\\d+:\\d+):/)[1];\n    };\n\n    this.ceil = function (time, unit) {\n      var date, floor, year;\n\n      if (unit.name == 'month') {\n        date = new Date(time * 1000);\n        floor = Date.UTC(date.getUTCFullYear(), date.getUTCMonth()) / 1000;\n        if (floor == time) return time;\n        year = date.getUTCFullYear();\n        var month = date.getUTCMonth();\n\n        if (month == 11) {\n          month = 0;\n          year = year + 1;\n        } else {\n          month += 1;\n        }\n\n        return Date.UTC(year, month) / 1000;\n      }\n\n      if (unit.name == 'year') {\n        date = new Date(time * 1000);\n        floor = Date.UTC(date.getUTCFullYear(), 0) / 1000;\n        if (floor == time) return time;\n        year = date.getUTCFullYear() + 1;\n        return Date.UTC(year, 0) / 1000;\n      }\n\n      return Math.ceil(time / unit.seconds) * unit.seconds;\n    };\n  };\n\n  Rickshaw.namespace('Rickshaw.Fixtures.Time.Local');\n\n  Rickshaw.Fixtures.Time.Local = function () {\n    var self = this;\n    this.months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n    this.units = [{\n      name: 'decade',\n      seconds: 86400 * 365.25 * 10,\n      formatter: function formatter(d) {\n        return parseInt(d.getFullYear() / 10, 10) * 10;\n      }\n    }, {\n      name: 'year',\n      seconds: 86400 * 365.25,\n      formatter: function formatter(d) {\n        return d.getFullYear();\n      }\n    }, {\n      name: 'month',\n      seconds: 86400 * 30.5,\n      formatter: function formatter(d) {\n        return self.months[d.getMonth()];\n      }\n    }, {\n      name: 'week',\n      seconds: 86400 * 7,\n      formatter: function formatter(d) {\n        return self.formatDate(d);\n      }\n    }, {\n      name: 'day',\n      seconds: 86400,\n      formatter: function formatter(d) {\n        return d.getDate();\n      }\n    }, {\n      name: '6 hour',\n      seconds: 3600 * 6,\n      formatter: function formatter(d) {\n        return self.formatTime(d);\n      }\n    }, {\n      name: 'hour',\n      seconds: 3600,\n      formatter: function formatter(d) {\n        return self.formatTime(d);\n      }\n    }, {\n      name: '15 minute',\n      seconds: 60 * 15,\n      formatter: function formatter(d) {\n        return self.formatTime(d);\n      }\n    }, {\n      name: 'minute',\n      seconds: 60,\n      formatter: function formatter(d) {\n        return d.getMinutes();\n      }\n    }, {\n      name: '15 second',\n      seconds: 15,\n      formatter: function formatter(d) {\n        return d.getSeconds() + 's';\n      }\n    }, {\n      name: 'second',\n      seconds: 1,\n      formatter: function formatter(d) {\n        return d.getSeconds() + 's';\n      }\n    }, {\n      name: 'decisecond',\n      seconds: 1 / 10,\n      formatter: function formatter(d) {\n        return d.getMilliseconds() + 'ms';\n      }\n    }, {\n      name: 'centisecond',\n      seconds: 1 / 100,\n      formatter: function formatter(d) {\n        return d.getMilliseconds() + 'ms';\n      }\n    }];\n\n    this.unit = function (unitName) {\n      return this.units.filter(function (unit) {\n        return unitName == unit.name;\n      }).shift();\n    };\n\n    this.formatDate = function (d) {\n      return d3.time.format('%b %e')(d);\n    };\n\n    this.formatTime = function (d) {\n      return d.toString().match(/(\\d+:\\d+):/)[1];\n    };\n\n    this.ceil = function (time, unit) {\n      var date, floor, year, offset;\n\n      if (unit.name == 'day') {\n        var nearFuture = new Date((time + unit.seconds - 1) * 1000);\n        var rounded = new Date(0);\n        rounded.setFullYear(nearFuture.getFullYear());\n        rounded.setMonth(nearFuture.getMonth());\n        rounded.setDate(nearFuture.getDate());\n        rounded.setMilliseconds(0);\n        rounded.setSeconds(0);\n        rounded.setMinutes(0);\n        rounded.setHours(0);\n        return rounded.getTime() / 1000;\n      }\n\n      if (unit.name == 'month') {\n        date = new Date(time * 1000);\n        floor = new Date(date.getFullYear(), date.getMonth()).getTime() / 1000;\n        if (floor == time) return time;\n        year = date.getFullYear();\n        var month = date.getMonth();\n\n        if (month == 11) {\n          month = 0;\n          year = year + 1;\n        } else {\n          month += 1;\n        }\n\n        return new Date(year, month).getTime() / 1000;\n      }\n\n      if (unit.name == 'year') {\n        date = new Date(time * 1000);\n        floor = new Date(date.getUTCFullYear(), 0).getTime() / 1000;\n        if (floor == time) return time;\n        year = date.getFullYear() + 1;\n        return new Date(year, 0).getTime() / 1000;\n      }\n\n      offset = new Date(time * 1000).getTimezoneOffset() * 60;\n      return Math.ceil((time - offset) / unit.seconds) * unit.seconds + offset;\n    };\n  };\n\n  Rickshaw.namespace('Rickshaw.Fixtures.Number');\n\n  Rickshaw.Fixtures.Number.formatKMBT = function (y) {\n    var abs_y = Math.abs(y);\n\n    if (abs_y >= 1000000000000) {\n      return (y / 1000000000000).toFixed(2) + \"T\";\n    } else if (abs_y >= 1000000000) {\n      return (y / 1000000000).toFixed(2) + \"B\";\n    } else if (abs_y >= 1000000) {\n      return (y / 1000000).toFixed(2) + \"M\";\n    } else if (abs_y >= 1000) {\n      return (y / 1000).toFixed(2) + \"K\";\n    } else if (abs_y < 1 && abs_y > 0) {\n      return y.toFixed(2);\n    } else if (abs_y === 0) {\n      return '0';\n    } else {\n      return y;\n    }\n  };\n\n  Rickshaw.Fixtures.Number.formatBase1024KMGTP = function (y) {\n    var abs_y = Math.abs(y);\n\n    if (abs_y >= 1125899906842624) {\n      return (y / 1125899906842624).toFixed(2) + \"P\";\n    } else if (abs_y >= 1099511627776) {\n      return (y / 1099511627776).toFixed(2) + \"T\";\n    } else if (abs_y >= 1073741824) {\n      return (y / 1073741824).toFixed(2) + \"G\";\n    } else if (abs_y >= 1048576) {\n      return (y / 1048576).toFixed(2) + \"M\";\n    } else if (abs_y >= 1024) {\n      return (y / 1024).toFixed(2) + \"K\";\n    } else if (abs_y < 1 && abs_y > 0) {\n      return y.toFixed(2);\n    } else if (abs_y === 0) {\n      return '0';\n    } else {\n      return y;\n    }\n  };\n\n  Rickshaw.namespace(\"Rickshaw.Color.Palette\");\n\n  Rickshaw.Color.Palette = function (args) {\n    var color = new Rickshaw.Fixtures.Color();\n    args = args || {};\n    this.schemes = {};\n    this.scheme = color.schemes[args.scheme] || args.scheme || color.schemes.colorwheel;\n    this.runningIndex = 0;\n    this.generatorIndex = 0;\n\n    if (args.interpolatedStopCount) {\n      var schemeCount = this.scheme.length - 1;\n      var i,\n          j,\n          scheme = [];\n\n      for (i = 0; i < schemeCount; i++) {\n        scheme.push(this.scheme[i]);\n        var generator = d3.interpolateHsl(this.scheme[i], this.scheme[i + 1]);\n\n        for (j = 1; j < args.interpolatedStopCount; j++) {\n          scheme.push(generator(1 / args.interpolatedStopCount * j));\n        }\n      }\n\n      scheme.push(this.scheme[this.scheme.length - 1]);\n      this.scheme = scheme;\n    }\n\n    this.rotateCount = this.scheme.length;\n\n    this.color = function (key) {\n      return this.scheme[key] || this.scheme[this.runningIndex++] || this.interpolateColor() || '#808080';\n    };\n\n    this.interpolateColor = function () {\n      if (!Array.isArray(this.scheme)) return;\n      var color;\n\n      if (this.generatorIndex == this.rotateCount * 2 - 1) {\n        color = d3.interpolateHsl(this.scheme[this.generatorIndex], this.scheme[0])(0.5);\n        this.generatorIndex = 0;\n        this.rotateCount *= 2;\n      } else {\n        color = d3.interpolateHsl(this.scheme[this.generatorIndex], this.scheme[this.generatorIndex + 1])(0.5);\n        this.generatorIndex++;\n      }\n\n      this.scheme.push(color);\n      return color;\n    };\n  };\n\n  Rickshaw.namespace('Rickshaw.Graph.Ajax');\n  Rickshaw.Graph.Ajax = Rickshaw.Class.create({\n    initialize: function initialize(args) {\n      this.dataURL = args.dataURL;\n\n      this.onData = args.onData || function (d) {\n        return d;\n      };\n\n      this.onComplete = args.onComplete || function () {};\n\n      this.onError = args.onError || function () {};\n\n      this.args = args; // pass through to Rickshaw.Graph\n\n      this.request();\n    },\n    request: function request() {\n      jQuery.ajax({\n        url: this.dataURL,\n        dataType: 'json',\n        success: this.success.bind(this),\n        error: this.error.bind(this)\n      });\n    },\n    error: function error() {\n      console.log(\"error loading dataURL: \" + this.dataURL);\n      this.onError(this);\n    },\n    success: function success(data, status) {\n      data = this.onData(data);\n      this.args.series = this._splice({\n        data: data,\n        series: this.args.series\n      });\n      this.graph = this.graph || new Rickshaw.Graph(this.args);\n      this.graph.render();\n      this.onComplete(this);\n    },\n    _splice: function _splice(args) {\n      var data = args.data;\n      var series = args.series;\n      if (!args.series) return data;\n      series.forEach(function (s) {\n        var seriesKey = s.key || s.name;\n        if (!seriesKey) throw \"series needs a key or a name\";\n        data.forEach(function (d) {\n          var dataKey = d.key || d.name;\n          if (!dataKey) throw \"data needs a key or a name\";\n\n          if (seriesKey == dataKey) {\n            var properties = ['color', 'name', 'data'];\n            properties.forEach(function (p) {\n              if (d[p]) s[p] = d[p];\n            });\n          }\n        });\n      });\n      return series;\n    }\n  });\n  Rickshaw.namespace('Rickshaw.Graph.Annotate');\n\n  Rickshaw.Graph.Annotate = function (args) {\n    var graph = this.graph = args.graph;\n    this.elements = {\n      timeline: args.element\n    };\n    var self = this;\n    this.data = {};\n    this.elements.timeline.classList.add('rickshaw_annotation_timeline');\n\n    this.add = function (time, content, end_time) {\n      self.data[time] = self.data[time] || {\n        'boxes': []\n      };\n      self.data[time].boxes.push({\n        content: content,\n        end: end_time\n      });\n    };\n\n    this.update = function () {\n      Rickshaw.keys(self.data).forEach(function (time) {\n        var annotation = self.data[time];\n        var left = self.graph.x(time);\n\n        if (left < 0 || left > self.graph.x.range()[1]) {\n          if (annotation.element) {\n            annotation.line.classList.add('offscreen');\n            annotation.element.style.display = 'none';\n          }\n\n          annotation.boxes.forEach(function (box) {\n            if (box.rangeElement) box.rangeElement.classList.add('offscreen');\n          });\n          return;\n        }\n\n        if (!annotation.element) {\n          var element = annotation.element = document.createElement('div');\n          element.classList.add('annotation');\n          this.elements.timeline.appendChild(element);\n          element.addEventListener('click', function (e) {\n            element.classList.toggle('active');\n            annotation.line.classList.toggle('active');\n            annotation.boxes.forEach(function (box) {\n              if (box.rangeElement) box.rangeElement.classList.toggle('active');\n            });\n          }, false);\n        }\n\n        annotation.element.style.left = left + 'px';\n        annotation.element.style.display = 'block';\n        annotation.boxes.forEach(function (box) {\n          var element = box.element;\n\n          if (!element) {\n            element = box.element = document.createElement('div');\n            element.classList.add('content');\n            element.innerHTML = box.content;\n            annotation.element.appendChild(element);\n            annotation.line = document.createElement('div');\n            annotation.line.classList.add('annotation_line');\n            self.graph.element.appendChild(annotation.line);\n\n            if (box.end) {\n              box.rangeElement = document.createElement('div');\n              box.rangeElement.classList.add('annotation_range');\n              self.graph.element.appendChild(box.rangeElement);\n            }\n          }\n\n          if (box.end) {\n            var annotationRangeStart = left;\n            var annotationRangeEnd = Math.min(self.graph.x(box.end), self.graph.x.range()[1]); // annotation makes more sense at end\n\n            if (annotationRangeStart > annotationRangeEnd) {\n              annotationRangeEnd = left;\n              annotationRangeStart = Math.max(self.graph.x(box.end), self.graph.x.range()[0]);\n            }\n\n            var annotationRangeWidth = annotationRangeEnd - annotationRangeStart;\n            box.rangeElement.style.left = annotationRangeStart + 'px';\n            box.rangeElement.style.width = annotationRangeWidth + 'px';\n            box.rangeElement.classList.remove('offscreen');\n          }\n\n          annotation.line.classList.remove('offscreen');\n          annotation.line.style.left = left + 'px';\n        });\n      }, this);\n    };\n\n    this.graph.onUpdate(function () {\n      self.update();\n    });\n  };\n\n  Rickshaw.namespace('Rickshaw.Graph.Axis.Time');\n\n  Rickshaw.Graph.Axis.Time = function (args) {\n    var self = this;\n    this.graph = args.graph;\n    this.elements = [];\n    this.ticksTreatment = args.ticksTreatment || 'plain';\n    this.fixedTimeUnit = args.timeUnit;\n    var time = args.timeFixture || new Rickshaw.Fixtures.Time();\n\n    this.appropriateTimeUnit = function () {\n      var unit;\n      var units = time.units;\n      var domain = this.graph.x.domain();\n      var rangeSeconds = domain[1] - domain[0];\n      units.forEach(function (u) {\n        if (Math.floor(rangeSeconds / u.seconds) >= 2) {\n          unit = unit || u;\n        }\n      });\n      return unit || time.units[time.units.length - 1];\n    };\n\n    this.tickOffsets = function () {\n      var domain = this.graph.x.domain();\n      var unit = this.fixedTimeUnit || this.appropriateTimeUnit();\n      var count = Math.ceil((domain[1] - domain[0]) / unit.seconds);\n      var runningTick = domain[0];\n      var offsets = [];\n\n      for (var i = 0; i < count; i++) {\n        var tickValue = time.ceil(runningTick, unit);\n        runningTick = tickValue + unit.seconds / 2;\n        offsets.push({\n          value: tickValue,\n          unit: unit\n        });\n      }\n\n      return offsets;\n    };\n\n    this.render = function () {\n      this.elements.forEach(function (e) {\n        e.parentNode.removeChild(e);\n      });\n      this.elements = [];\n      var offsets = this.tickOffsets();\n      offsets.forEach(function (o) {\n        if (self.graph.x(o.value) > self.graph.x.range()[1]) return;\n        var element = document.createElement('div');\n        element.style.left = self.graph.x(o.value) + 'px';\n        element.classList.add('x_tick');\n        element.classList.add(self.ticksTreatment);\n        var title = document.createElement('div');\n        title.classList.add('title');\n        title.innerHTML = o.unit.formatter(new Date(o.value * 1000));\n        element.appendChild(title);\n        self.graph.element.appendChild(element);\n        self.elements.push(element);\n      });\n    };\n\n    this.graph.onUpdate(function () {\n      self.render();\n    });\n  };\n\n  Rickshaw.namespace('Rickshaw.Graph.Axis.X');\n\n  Rickshaw.Graph.Axis.X = function (args) {\n    var self = this;\n    var berthRate = 0.10;\n\n    this.initialize = function (args) {\n      this.graph = args.graph;\n      this.orientation = args.orientation || 'top';\n      this.color = args.color || \"#000000\";\n      this.pixelsPerTick = args.pixelsPerTick || 75;\n      if (args.ticks) this.staticTicks = args.ticks;\n      if (args.tickValues) this.tickValues = args.tickValues;\n      this.tickSize = args.tickSize || 4;\n      this.ticksTreatment = args.ticksTreatment || 'plain';\n\n      if (args.element) {\n        this.element = args.element;\n\n        this._discoverSize(args.element, args);\n\n        this.vis = d3.select(args.element).append(\"svg:svg\").attr('height', this.height).attr('width', this.width).attr('stroke', this.color).attr('class', 'rickshaw_graph x_axis_d3');\n        this.element = this.vis[0][0];\n        this.element.style.position = 'relative';\n        this.setSize({\n          width: args.width,\n          height: args.height\n        });\n      } else {\n        this.vis = this.graph.vis;\n      }\n\n      this.graph.onUpdate(function () {\n        self.render();\n      });\n    };\n\n    this.setSize = function (args) {\n      args = args || {};\n      if (!this.element) return;\n\n      this._discoverSize(this.element.parentNode, args);\n\n      this.vis.attr('height', this.height).attr('width', this.width * (1 + berthRate));\n      var berth = Math.floor(this.width * berthRate / 2);\n      this.element.style.left = -1 * berth + 'px';\n    };\n\n    this.render = function () {\n      if (this._renderWidth !== undefined && this.graph.width !== this._renderWidth) this.setSize({\n        auto: true\n      });\n      var axis = d3.svg.axis().scale(this.graph.x).orient(this.orientation);\n      axis.tickFormat(args.tickFormat || function (x) {\n        return x;\n      });\n      if (this.tickValues) axis.tickValues(this.tickValues);\n      this.ticks = this.staticTicks || Math.floor(this.graph.width / this.pixelsPerTick);\n      var berth = Math.floor(this.width * berthRate / 2) || 0;\n      var bar_offset = this.graph.renderer.name == \"bar\" && Math.ceil(this.graph.width * 0.95 / this.graph.series[0].data.length / 2) || 0;\n      var transform;\n\n      if (this.orientation == 'top') {\n        var yOffset = this.height || this.graph.height;\n        transform = 'translate(' + (berth + bar_offset) + ',' + yOffset + ')';\n      } else {\n        transform = 'translate(' + (berth + bar_offset) + ', 0)';\n      }\n\n      if (this.element) {\n        this.vis.selectAll('*').remove();\n      }\n\n      this.vis.append(\"svg:g\").attr(\"class\", [\"x_ticks_d3\", this.ticksTreatment].join(\" \")).attr(\"transform\", transform).call(axis.ticks(this.ticks).tickSubdivide(0).tickSize(this.tickSize));\n      var gridSize = (this.orientation == 'bottom' ? 1 : -1) * this.graph.height;\n      this.graph.vis.append(\"svg:g\").attr(\"class\", \"x_grid_d3\").call(axis.ticks(this.ticks).tickSubdivide(0).tickSize(gridSize)).selectAll('text').each(function () {\n        this.parentNode.setAttribute('data-x-value', this.textContent);\n      });\n      this._renderHeight = this.graph.height;\n    };\n\n    this._discoverSize = function (element, args) {\n      if (typeof window !== 'undefined') {\n        var style = window.getComputedStyle(element, null);\n        var elementHeight = parseInt(style.getPropertyValue('height'), 10);\n\n        if (!args.auto) {\n          var elementWidth = parseInt(style.getPropertyValue('width'), 10);\n        }\n      }\n\n      this.width = (args.width || elementWidth || this.graph.width) * (1 + berthRate);\n      this.height = args.height || elementHeight || 40;\n    };\n\n    this.initialize(args);\n  };\n\n  Rickshaw.namespace('Rickshaw.Graph.Axis.Y');\n  Rickshaw.Graph.Axis.Y = Rickshaw.Class.create({\n    initialize: function initialize(args) {\n      this.graph = args.graph;\n      this.orientation = args.orientation || 'right';\n      this.color = args.color || \"#000000\";\n      this.pixelsPerTick = args.pixelsPerTick || 75;\n      if (args.ticks) this.staticTicks = args.ticks;\n      if (args.tickValues) this.tickValues = args.tickValues;\n      this.tickSize = args.tickSize || 4;\n      this.ticksTreatment = args.ticksTreatment || 'plain';\n\n      this.tickFormat = args.tickFormat || function (y) {\n        return y;\n      };\n\n      this.berthRate = 0.10;\n\n      if (args.element) {\n        this.element = args.element;\n        this.vis = d3.select(args.element).append(\"svg:svg\").attr('stroke', this.color).attr('class', 'rickshaw_graph y_axis');\n        this.element = this.vis[0][0];\n        this.element.style.position = 'relative';\n        this.setSize({\n          width: args.width,\n          height: args.height\n        });\n      } else {\n        this.vis = this.graph.vis;\n      }\n\n      var self = this;\n      this.graph.onUpdate(function () {\n        self.render();\n      });\n    },\n    setSize: function setSize(args) {\n      args = args || {};\n      if (!this.element) return;\n\n      if (typeof window !== 'undefined') {\n        var style = window.getComputedStyle(this.element.parentNode, null);\n        var elementWidth = parseInt(style.getPropertyValue('width'), 10);\n\n        if (!args.auto) {\n          var elementHeight = parseInt(style.getPropertyValue('height'), 10);\n        }\n      }\n\n      this.width = args.width || elementWidth || this.graph.width * this.berthRate;\n      this.height = args.height || elementHeight || this.graph.height;\n      this.vis.attr('width', this.width).attr('height', this.height * (1 + this.berthRate));\n      var berth = this.height * this.berthRate;\n\n      if (this.orientation == 'left') {\n        this.element.style.top = -1 * berth + 'px';\n      }\n    },\n    render: function render() {\n      if (this._renderHeight !== undefined && this.graph.height !== this._renderHeight) this.setSize({\n        auto: true\n      });\n      this.ticks = this.staticTicks || Math.floor(this.graph.height / this.pixelsPerTick);\n\n      var axis = this._drawAxis(this.graph.y);\n\n      this._drawGrid(axis);\n\n      this._renderHeight = this.graph.height;\n    },\n    _drawAxis: function _drawAxis(scale) {\n      var axis = d3.svg.axis().scale(scale).orient(this.orientation);\n      axis.tickFormat(this.tickFormat);\n      if (this.tickValues) axis.tickValues(this.tickValues);\n\n      if (this.orientation == 'left') {\n        var berth = this.height * this.berthRate;\n        var transform = 'translate(' + this.width + ', ' + berth + ')';\n      }\n\n      if (this.element) {\n        this.vis.selectAll('*').remove();\n      }\n\n      this.vis.append(\"svg:g\").attr(\"class\", [\"y_ticks\", this.ticksTreatment].join(\" \")).attr(\"transform\", transform).call(axis.ticks(this.ticks).tickSubdivide(0).tickSize(this.tickSize));\n      return axis;\n    },\n    _drawGrid: function _drawGrid(axis) {\n      var gridSize = (this.orientation == 'right' ? 1 : -1) * this.graph.width;\n      this.graph.vis.append(\"svg:g\").attr(\"class\", \"y_grid\").call(axis.ticks(this.ticks).tickSubdivide(0).tickSize(gridSize)).selectAll('text').each(function () {\n        this.parentNode.setAttribute('data-y-value', this.textContent);\n      });\n    }\n  });\n  Rickshaw.namespace('Rickshaw.Graph.Axis.Y.Scaled');\n  Rickshaw.Graph.Axis.Y.Scaled = Rickshaw.Class.create(Rickshaw.Graph.Axis.Y, {\n    initialize: function initialize($super, args) {\n      if (typeof args.scale === 'undefined') {\n        throw new Error('Scaled requires scale');\n      }\n\n      this.scale = args.scale;\n\n      if (typeof args.grid === 'undefined') {\n        this.grid = true;\n      } else {\n        this.grid = args.grid;\n      }\n\n      $super(args);\n    },\n    _drawAxis: function _drawAxis($super, scale) {\n      // Adjust scale's domain to compensate for adjustments to the\n      // renderer's domain (e.g. padding).\n      var domain = this.scale.domain();\n      var renderDomain = this.graph.renderer.domain().y;\n      var extents = [Math.min.apply(Math, domain), Math.max.apply(Math, domain)]; // A mapping from the ideal render domain [0, 1] to the extent\n      // of the original scale's domain.  This is used to calculate\n      // the extents of the adjusted domain.\n\n      var extentMap = d3.scale.linear().domain([0, 1]).range(extents);\n      var adjExtents = [extentMap(renderDomain[0]), extentMap(renderDomain[1])]; // A mapping from the original domain to the adjusted domain.\n\n      var adjustment = d3.scale.linear().domain(extents).range(adjExtents); // Make a copy of the custom scale, apply the adjusted domain, and\n      // copy the range to match the graph's scale.\n\n      var adjustedScale = this.scale.copy().domain(domain.map(adjustment)).range(scale.range());\n      return $super(adjustedScale);\n    },\n    _drawGrid: function _drawGrid($super, axis) {\n      if (this.grid) {\n        // only draw the axis if the grid option is true\n        $super(axis);\n      }\n    }\n  });\n  Rickshaw.namespace('Rickshaw.Graph.Behavior.Series.Highlight');\n\n  Rickshaw.Graph.Behavior.Series.Highlight = function (args) {\n    this.graph = args.graph;\n    this.legend = args.legend;\n    var self = this;\n    var propertiesSafe = {};\n    var activeLine = null;\n\n    var disabledColor = args.disabledColor || function (seriesColor) {\n      return d3.interpolateRgb(seriesColor, d3.rgb('#d8d8d8'))(0.8).toString();\n    };\n\n    var transformFn = args.transform || function (isActive, series) {\n      var newProperties = {};\n\n      if (!isActive) {\n        // backwards compability\n        newProperties.color = disabledColor(series.color);\n      }\n\n      return newProperties;\n    };\n\n    this.addHighlightEvents = function (l) {\n      l.element.addEventListener('mouseover', function (e) {\n        if (activeLine) return;else activeLine = l;\n        self.legend.lines.forEach(function (line) {\n          var newProperties;\n          var isActive = false;\n\n          if (l === line) {\n            isActive = true; // if we're not in a stacked renderer bring active line to the top\n\n            if (self.graph.renderer.unstack && (line.series.renderer ? line.series.renderer.unstack : true)) {\n              var seriesIndex = self.graph.series.indexOf(line.series);\n              line.originalIndex = seriesIndex;\n              var series = self.graph.series.splice(seriesIndex, 1)[0];\n              self.graph.series.push(series);\n            }\n          }\n\n          newProperties = transformFn(isActive, line.series);\n          propertiesSafe[line.series.name] = propertiesSafe[line.series.name] || {\n            color: line.series.color,\n            stroke: line.series.stroke\n          };\n\n          if (newProperties.color) {\n            line.series.color = newProperties.color;\n          }\n\n          if (newProperties.stroke) {\n            line.series.stroke = newProperties.stroke;\n          }\n        });\n        self.graph.update();\n      }, false);\n      l.element.addEventListener('mouseout', function (e) {\n        if (!activeLine) return;else activeLine = null;\n        self.legend.lines.forEach(function (line) {\n          // return reordered series to its original place\n          if (l === line && line.hasOwnProperty('originalIndex')) {\n            var series = self.graph.series.pop();\n            self.graph.series.splice(line.originalIndex, 0, series);\n            delete line.originalIndex;\n          }\n\n          var lineProperties = propertiesSafe[line.series.name];\n\n          if (lineProperties) {\n            line.series.color = lineProperties.color;\n            line.series.stroke = lineProperties.stroke;\n          }\n        });\n        self.graph.update();\n      }, false);\n    };\n\n    if (this.legend) {\n      this.legend.lines.forEach(function (l) {\n        self.addHighlightEvents(l);\n      });\n    }\n  };\n\n  Rickshaw.namespace('Rickshaw.Graph.Behavior.Series.Order');\n\n  Rickshaw.Graph.Behavior.Series.Order = function (args) {\n    this.graph = args.graph;\n    this.legend = args.legend;\n    var self = this;\n\n    if (typeof window.jQuery == 'undefined') {\n      throw \"couldn't find jQuery at window.jQuery\";\n    }\n\n    if (typeof window.jQuery.ui == 'undefined') {\n      throw \"couldn't find jQuery UI at window.jQuery.ui\";\n    }\n\n    jQuery(function () {\n      jQuery(self.legend.list).sortable({\n        containment: 'parent',\n        tolerance: 'pointer',\n        update: function update(event, ui) {\n          var series = [];\n          jQuery(self.legend.list).find('li').each(function (index, item) {\n            if (!item.series) return;\n            series.push(item.series);\n          });\n\n          for (var i = self.graph.series.length - 1; i >= 0; i--) {\n            self.graph.series[i] = series.shift();\n          }\n\n          self.graph.update();\n        }\n      });\n      jQuery(self.legend.list).disableSelection();\n    }); //hack to make jquery-ui sortable behave\n\n    this.graph.onUpdate(function () {\n      var h = window.getComputedStyle(self.legend.element).height;\n      self.legend.element.style.height = h;\n    });\n  };\n\n  Rickshaw.namespace('Rickshaw.Graph.Behavior.Series.Toggle');\n\n  Rickshaw.Graph.Behavior.Series.Toggle = function (args) {\n    this.graph = args.graph;\n    this.legend = args.legend;\n    var self = this;\n\n    this.addAnchor = function (line) {\n      var anchor = document.createElement('a');\n      anchor.innerHTML = '&#10004;';\n      anchor.classList.add('action');\n      line.element.insertBefore(anchor, line.element.firstChild);\n\n      anchor.onclick = function (e) {\n        if (line.series.disabled) {\n          line.series.enable();\n          line.element.classList.remove('disabled');\n        } else {\n          if (this.graph.series.filter(function (s) {\n            return !s.disabled;\n          }).length <= 1) return;\n          line.series.disable();\n          line.element.classList.add('disabled');\n        }\n\n        self.graph.update();\n      }.bind(this);\n\n      var label = line.element.getElementsByTagName('span')[0];\n\n      label.onclick = function (e) {\n        var disableAllOtherLines = line.series.disabled;\n\n        if (!disableAllOtherLines) {\n          for (var i = 0; i < self.legend.lines.length; i++) {\n            var l = self.legend.lines[i];\n\n            if (line.series === l.series) {// noop\n            } else if (l.series.disabled) {// noop\n            } else {\n              disableAllOtherLines = true;\n              break;\n            }\n          }\n        } // show all or none\n\n\n        if (disableAllOtherLines) {\n          // these must happen first or else we try ( and probably fail ) to make a no line graph\n          line.series.enable();\n          line.element.classList.remove('disabled');\n          self.legend.lines.forEach(function (l) {\n            if (line.series === l.series) {// noop\n            } else {\n              l.series.disable();\n              l.element.classList.add('disabled');\n            }\n          });\n        } else {\n          self.legend.lines.forEach(function (l) {\n            l.series.enable();\n            l.element.classList.remove('disabled');\n          });\n        }\n\n        self.graph.update();\n      };\n    };\n\n    if (this.legend) {\n      if (typeof jQuery != 'undefined' && jQuery(this.legend.list).sortable) {\n        jQuery(this.legend.list).sortable({\n          start: function start(event, ui) {\n            ui.item.bind('no.onclick', function (event) {\n              event.preventDefault();\n            });\n          },\n          stop: function stop(event, ui) {\n            setTimeout(function () {\n              ui.item.unbind('no.onclick');\n            }, 250);\n          }\n        });\n      }\n\n      this.legend.lines.forEach(function (l) {\n        self.addAnchor(l);\n      });\n    }\n\n    this._addBehavior = function () {\n      this.graph.series.forEach(function (s) {\n        s.disable = function () {\n          if (self.graph.series.length <= 1) {\n            throw 'only one series left';\n          }\n\n          s.disabled = true;\n        };\n\n        s.enable = function () {\n          s.disabled = false;\n        };\n      });\n    };\n\n    this._addBehavior();\n\n    this.updateBehaviour = function () {\n      this._addBehavior();\n    };\n  };\n\n  Rickshaw.namespace('Rickshaw.Graph.DragZoom');\n  Rickshaw.Graph.DragZoom = Rickshaw.Class.create({\n    initialize: function initialize(args) {\n      if (!args || !args.graph) {\n        throw new Error(\"Rickshaw.Graph.DragZoom needs a reference to a graph\");\n      }\n\n      var defaults = {\n        opacity: 0.5,\n        fill: 'steelblue',\n        minimumTimeSelection: 60,\n        callback: function callback() {}\n      };\n      this.graph = args.graph;\n      this.svg = d3.select(this.graph.element).select(\"svg\");\n      this.svgWidth = parseInt(this.svg.attr(\"width\"), 10);\n      this.opacity = args.opacity || defaults.opacity;\n      this.fill = args.fill || defaults.fill;\n      this.minimumTimeSelection = args.minimumTimeSelection || defaults.minimumTimeSelection;\n      this.callback = args.callback || defaults.callback;\n      this.registerMouseEvents();\n    },\n    registerMouseEvents: function registerMouseEvents() {\n      var self = this;\n      var ESCAPE_KEYCODE = 27;\n      var rectangle;\n      var drag = {\n        startDt: null,\n        stopDt: null,\n        startPX: null,\n        stopPX: null\n      };\n      this.svg.on(\"mousedown\", onMousedown);\n\n      function onMouseup(datum, index) {\n        drag.stopDt = pointAsDate(d3.event);\n        var windowAfterDrag = [drag.startDt, drag.stopDt].sort(compareNumbers);\n        self.graph.window.xMin = windowAfterDrag[0];\n        self.graph.window.xMax = windowAfterDrag[1];\n        var endTime = self.graph.window.xMax;\n        var range = self.graph.window.xMax - self.graph.window.xMin;\n        reset(this);\n\n        if (range < self.minimumTimeSelection || isNaN(range)) {\n          return;\n        }\n\n        self.graph.update();\n        self.callback({\n          range: range,\n          endTime: endTime\n        });\n      }\n\n      function onMousemove() {\n        var offset = drag.stopPX = d3.event.offsetX || d3.event.layerX;\n\n        if (offset > self.svgWidth - 1 || offset < 1) {\n          return;\n        }\n\n        var limits = [drag.startPX, offset].sort(compareNumbers);\n        var selectionWidth = limits[1] - limits[0];\n\n        if (isNaN(selectionWidth)) {\n          return reset(this);\n        }\n\n        rectangle.attr(\"fill\", self.fill).attr(\"x\", limits[0]).attr(\"width\", selectionWidth);\n      }\n\n      function onMousedown() {\n        var el = d3.select(this);\n        rectangle = el.append(\"rect\").style(\"opacity\", self.opacity).attr(\"y\", 0).attr(\"height\", \"100%\");\n\n        if (d3.event.preventDefault) {\n          d3.event.preventDefault();\n        } else {\n          d3.event.returnValue = false;\n        }\n\n        drag.target = d3.event.target;\n        drag.startDt = pointAsDate(d3.event);\n        drag.startPX = d3.event.offsetX || d3.event.layerX;\n        el.on(\"mousemove\", onMousemove);\n        d3.select(document).on(\"mouseup\", onMouseup);\n        d3.select(document).on(\"keyup\", function () {\n          if (d3.event.keyCode === ESCAPE_KEYCODE) {\n            reset(this);\n          }\n        });\n      }\n\n      function reset(el) {\n        var s = d3.select(el);\n        s.on(\"mousemove\", null);\n        d3.select(document).on(\"mouseup\", null);\n        drag = {};\n        rectangle.remove();\n      }\n\n      function compareNumbers(a, b) {\n        return a - b;\n      }\n\n      function pointAsDate(e) {\n        return Math.floor(self.graph.x.invert(e.offsetX || e.layerX));\n      }\n    }\n  });\n  Rickshaw.namespace('Rickshaw.Graph.HoverDetail');\n  Rickshaw.Graph.HoverDetail = Rickshaw.Class.create({\n    initialize: function initialize(args) {\n      var graph = this.graph = args.graph;\n\n      this.xFormatter = args.xFormatter || function (x) {\n        return new Date(x * 1000).toUTCString();\n      };\n\n      this.yFormatter = args.yFormatter || function (y) {\n        return y === null ? y : y.toFixed(2);\n      };\n\n      var element = this.element = document.createElement('div');\n      element.className = 'detail inactive';\n      this.visible = true;\n      graph.element.appendChild(element);\n      this.lastEvent = null;\n\n      this._addListeners();\n\n      this.onShow = args.onShow;\n      this.onHide = args.onHide;\n      this.onRender = args.onRender;\n      this.formatter = args.formatter || this.formatter;\n    },\n    formatter: function formatter(series, x, y, formattedX, formattedY, d) {\n      return series.name + ':&nbsp;' + formattedY;\n    },\n    update: function update(e) {\n      e = e || this.lastEvent;\n      if (!e) return;\n      this.lastEvent = e;\n      if (!e.target.nodeName.match(/^(path|svg|rect|circle)$/)) return;\n      var graph = this.graph;\n      var rect = graph.element.getBoundingClientRect();\n      var eventX = e.clientX - rect.left;\n      var eventY = e.clientY - rect.top;\n      var j = 0;\n      var points = [];\n      var nearestPoint;\n      this.graph.series.active().forEach(function (series) {\n        var data = this.graph.stackedData[j++];\n        if (!data.length) return;\n        var domainX = graph.x.invert(eventX);\n        var domainIndexScale = d3.scale.linear().domain([data[0].x, data.slice(-1)[0].x]).range([0, data.length - 1]);\n        var approximateIndex = Math.round(domainIndexScale(domainX));\n        if (approximateIndex == data.length - 1) approximateIndex--;\n        var dataIndex = Math.min(approximateIndex || 0, data.length - 1);\n\n        for (var i = approximateIndex; i < data.length - 1;) {\n          if (!data[i] || !data[i + 1]) break;\n\n          if (data[i].x <= domainX && data[i + 1].x > domainX) {\n            dataIndex = Math.abs(domainX - data[i].x) < Math.abs(domainX - data[i + 1].x) ? i : i + 1;\n            break;\n          }\n\n          if (data[i + 1].x <= domainX) {\n            i++;\n          } else {\n            i--;\n          }\n        }\n\n        if (dataIndex < 0) dataIndex = 0;\n        var value = data[dataIndex];\n        var distance = Math.sqrt(Math.pow(Math.abs(graph.x(value.x) - eventX), 2) + Math.pow(Math.abs(graph.y(value.y + value.y0) - eventY), 2));\n        var xFormatter = series.xFormatter || this.xFormatter;\n        var yFormatter = series.yFormatter || this.yFormatter;\n        var point = {\n          formattedXValue: xFormatter(value.x),\n          formattedYValue: yFormatter(series.scale ? series.scale.invert(value.y) : value.y),\n          series: series,\n          value: value,\n          distance: distance,\n          order: j,\n          name: series.name\n        };\n\n        if (!nearestPoint || distance < nearestPoint.distance) {\n          nearestPoint = point;\n        }\n\n        points.push(point);\n      }, this);\n      if (!nearestPoint) return;\n      nearestPoint.active = true;\n      var domainX = nearestPoint.value.x;\n      var formattedXValue = nearestPoint.formattedXValue;\n      this.element.innerHTML = '';\n      this.element.style.left = graph.x(domainX) + 'px';\n      this.visible && this.render({\n        points: points,\n        detail: points,\n        // for backwards compatibility\n        mouseX: eventX,\n        mouseY: eventY,\n        formattedXValue: formattedXValue,\n        domainX: domainX\n      });\n    },\n    hide: function hide() {\n      this.visible = false;\n      this.element.classList.add('inactive');\n\n      if (typeof this.onHide == 'function') {\n        this.onHide();\n      }\n    },\n    show: function show() {\n      this.visible = true;\n      this.element.classList.remove('inactive');\n\n      if (typeof this.onShow == 'function') {\n        this.onShow();\n      }\n    },\n    render: function render(args) {\n      var graph = this.graph;\n      var points = args.points;\n      var point = points.filter(function (p) {\n        return p.active;\n      }).shift();\n      if (point.value.y === null) return;\n      var formattedXValue = point.formattedXValue;\n      var formattedYValue = point.formattedYValue;\n      this.element.innerHTML = '';\n      this.element.style.left = graph.x(point.value.x) + 'px';\n      var xLabel = document.createElement('div');\n      xLabel.className = 'x_label';\n      xLabel.innerHTML = formattedXValue;\n      this.element.appendChild(xLabel);\n      var item = document.createElement('div');\n      item.className = 'item'; // invert the scale if this series displays using a scale\n\n      var series = point.series;\n      var actualY = series.scale ? series.scale.invert(point.value.y) : point.value.y;\n      item.innerHTML = this.formatter(series, point.value.x, actualY, formattedXValue, formattedYValue, point);\n      item.style.top = this.graph.y(point.value.y0 + point.value.y) + 'px';\n      this.element.appendChild(item);\n      var dot = document.createElement('div');\n      dot.className = 'dot';\n      dot.style.top = item.style.top;\n      dot.style.borderColor = series.color;\n      this.element.appendChild(dot);\n\n      if (point.active) {\n        item.classList.add('active');\n        dot.classList.add('active');\n      } // Assume left alignment until the element has been displayed and\n      // bounding box calculations are possible.\n\n\n      var alignables = [xLabel, item];\n      alignables.forEach(function (el) {\n        el.classList.add('left');\n      });\n      this.show(); // If left-alignment results in any error, try right-alignment.\n\n      var leftAlignError = this._calcLayoutError(alignables);\n\n      if (leftAlignError > 0) {\n        alignables.forEach(function (el) {\n          el.classList.remove('left');\n          el.classList.add('right');\n        }); // If right-alignment is worse than left alignment, switch back.\n\n        var rightAlignError = this._calcLayoutError(alignables);\n\n        if (rightAlignError > leftAlignError) {\n          alignables.forEach(function (el) {\n            el.classList.remove('right');\n            el.classList.add('left');\n          });\n        }\n      }\n\n      if (typeof this.onRender == 'function') {\n        this.onRender(args);\n      }\n    },\n    _calcLayoutError: function _calcLayoutError(alignables) {\n      // Layout error is calculated as the number of linear pixels by which\n      // an alignable extends past the left or right edge of the parent.\n      var parentRect = this.element.parentNode.getBoundingClientRect();\n      var error = 0;\n      var alignRight = alignables.forEach(function (el) {\n        var rect = el.getBoundingClientRect();\n\n        if (!rect.width) {\n          return;\n        }\n\n        if (rect.right > parentRect.right) {\n          error += rect.right - parentRect.right;\n        }\n\n        if (rect.left < parentRect.left) {\n          error += parentRect.left - rect.left;\n        }\n      });\n      return error;\n    },\n    _addListeners: function _addListeners() {\n      // Keep reference for later removal.\n      this.mousemoveListener = function (e) {\n        this.visible = true;\n        this.update(e);\n      }.bind(this); // Add listener.\n\n\n      this.graph.element.addEventListener('mousemove', this.mousemoveListener, false);\n      this.graph.onUpdate(function () {\n        this.update();\n      }.bind(this)); // Keep reference for later removal.\n\n      this.mouseoutListener = function (e) {\n        if (e.relatedTarget && !(e.relatedTarget.compareDocumentPosition(this.graph.element) & Node.DOCUMENT_POSITION_CONTAINS)) {\n          this.hide();\n        }\n      }.bind(this); // Add listener.\n\n\n      this.graph.element.addEventListener('mouseout', this.mouseoutListener, false);\n    },\n    _removeListeners: function _removeListeners() {\n      if (this.mousemoveListener) {\n        this.graph.element.removeEventListener('mousemove', this.mousemoveListener, false);\n      }\n\n      if (this.mouseoutListener) {\n        this.graph.element.removeEventListener('mouseout', this.mouseoutListener, false);\n      }\n    }\n  });\n  Rickshaw.namespace('Rickshaw.Graph.JSONP');\n  Rickshaw.Graph.JSONP = Rickshaw.Class.create(Rickshaw.Graph.Ajax, {\n    request: function request() {\n      jQuery.ajax({\n        url: this.dataURL,\n        dataType: 'jsonp',\n        success: this.success.bind(this),\n        error: this.error.bind(this)\n      });\n    }\n  });\n  Rickshaw.namespace('Rickshaw.Graph.Legend');\n  Rickshaw.Graph.Legend = Rickshaw.Class.create({\n    className: 'rickshaw_legend',\n    initialize: function initialize(args) {\n      this.element = args.element;\n      this.graph = args.graph;\n      this.naturalOrder = args.naturalOrder;\n      this.colorKey = args.colorKey || 'color';\n      this.element.classList.add(this.className);\n      this.list = document.createElement('ul');\n      this.element.appendChild(this.list);\n      this.render(); // we could bind this.render.bind(this) here\n      // but triggering the re-render would lose the added\n      // behavior of the series toggle\n\n      this.graph.onUpdate(function () {});\n    },\n    render: function render() {\n      var self = this;\n\n      while (this.list.firstChild) {\n        this.list.removeChild(this.list.firstChild);\n      }\n\n      this.lines = [];\n      var series = this.graph.series.map(function (s) {\n        return s;\n      });\n\n      if (!this.naturalOrder) {\n        series = series.reverse();\n      }\n\n      series.forEach(function (s) {\n        self.addLine(s);\n      });\n    },\n    addLine: function addLine(series) {\n      var line = document.createElement('li');\n      line.className = 'line';\n\n      if (series.disabled) {\n        line.className += ' disabled';\n      }\n\n      if (series.className) {\n        d3.select(line).classed(series.className, true);\n      }\n\n      var swatch = document.createElement('div');\n      swatch.className = 'swatch';\n      swatch.style.backgroundColor = series[this.colorKey];\n      line.appendChild(swatch);\n      var label = document.createElement('span');\n      label.className = 'label';\n      label.innerHTML = series.name;\n      line.appendChild(label);\n      this.list.appendChild(line);\n      line.series = series;\n\n      if (series.noLegend) {\n        line.style.display = 'none';\n      }\n\n      var _line = {\n        element: line,\n        series: series\n      };\n\n      if (this.shelving) {\n        this.shelving.addAnchor(_line);\n        this.shelving.updateBehaviour();\n      }\n\n      if (this.highlighter) {\n        this.highlighter.addHighlightEvents(_line);\n      }\n\n      this.lines.push(_line);\n      return line;\n    }\n  });\n  Rickshaw.namespace('Rickshaw.Graph.RangeSlider');\n  Rickshaw.Graph.RangeSlider = Rickshaw.Class.create({\n    initialize: function initialize(args) {\n      var $ = jQuery;\n      var self = this;\n      var element = this.element = args.element;\n      var graphs = this.graphs = args.graphs;\n\n      if (!graphs) {\n        graphs = this.graph = args.graph;\n      }\n\n      if (graphs.constructor !== Array) {\n        graphs = [graphs];\n      }\n\n      this.graph = graphs[0];\n      this.slideCallbacks = [];\n      this.build();\n\n      for (var i = 0; i < graphs.length; i++) {\n        graphs[i].onUpdate(function () {\n          self.update();\n        }.bind(self));\n\n        (function (idx) {\n          graphs[idx].onConfigure(function () {\n            $(this.element)[0].style.width = graphs[idx].width + 'px';\n          }.bind(self));\n        })(i);\n      }\n    },\n    build: function build() {\n      var domain;\n      var element = this.element;\n      var $ = jQuery;\n      var self = this;\n      var graphs = this.graphs || this.graph;\n\n      if (graphs.constructor !== Array) {\n        graphs = [graphs];\n      } // base the slider's min/max on the first graph\n\n\n      this.graph = graphs[0];\n      domain = graphs[0].dataDomain();\n      $(function () {\n        $(element).slider({\n          range: true,\n          min: domain[0],\n          max: domain[1],\n          values: [domain[0], domain[1]],\n          start: function start(event, ui) {\n            self.slideStarted({\n              event: event,\n              ui: ui\n            });\n          },\n          stop: function stop(event, ui) {\n            self.slideFinished({\n              event: event,\n              ui: ui\n            });\n          },\n          slide: function slide(event, ui) {\n            if (!self.slideShouldUpdate(event, ui)) return;\n            if (ui.values[1] <= ui.values[0]) return;\n\n            for (var i = 0; i < graphs.length; i++) {\n              self.processSlideChange({\n                event: event,\n                ui: ui,\n                graph: graphs[i]\n              });\n            }\n          }\n        });\n      });\n      graphs[0].onConfigure(function () {\n        $(this.element)[0].style.width = graphs[0].width + 'px';\n      }.bind(this));\n    },\n    update: function update() {\n      var element = this.element;\n      var graph = this.graph;\n      var $ = jQuery;\n      var values = $(element).slider('option', 'values');\n      var domain = graph.dataDomain();\n      $(element).slider('option', 'min', domain[0]);\n      $(element).slider('option', 'max', domain[1]);\n\n      if (graph.window.xMin == null) {\n        values[0] = domain[0];\n      }\n\n      if (graph.window.xMax == null) {\n        values[1] = domain[1];\n      }\n\n      $(element).slider('option', 'values', values);\n    },\n    onSlide: function onSlide(callback) {\n      this.slideCallbacks.push(callback);\n    },\n    processSlideChange: function processSlideChange(args) {\n      var event = args.event;\n      var ui = args.ui;\n      var graph = args.graph;\n      graph.window.xMin = ui.values[0];\n      graph.window.xMax = ui.values[1];\n      graph.update();\n      var domain = graph.dataDomain(); // if we're at an extreme, stick there\n\n      if (domain[0] == ui.values[0]) {\n        graph.window.xMin = undefined;\n      }\n\n      if (domain[1] == ui.values[1]) {\n        graph.window.xMax = undefined;\n      }\n\n      this.slideCallbacks.forEach(function (callback) {\n        callback(graph, graph.window.xMin, graph.window.xMax);\n      });\n    },\n    // allows the slide updates to bail out if sliding is not permitted\n    slideShouldUpdate: function slideShouldUpdate() {\n      return true;\n    },\n    slideStarted: function slideStarted() {\n      return;\n    },\n    slideFinished: function slideFinished() {\n      return;\n    }\n  });\n  Rickshaw.namespace('Rickshaw.Graph.RangeSlider.Preview');\n  Rickshaw.Graph.RangeSlider.Preview = Rickshaw.Class.create({\n    initialize: function initialize(args) {\n      if (!args.element) throw \"Rickshaw.Graph.RangeSlider.Preview needs a reference to an element\";\n      if (!args.graph && !args.graphs) throw \"Rickshaw.Graph.RangeSlider.Preview needs a reference to an graph or an array of graphs\";\n      this.element = args.element;\n      this.element.style.position = 'relative';\n      this.graphs = args.graph ? [args.graph] : args.graphs;\n      this.defaults = {\n        height: 75,\n        width: 400,\n        gripperColor: undefined,\n        frameTopThickness: 3,\n        frameHandleThickness: 10,\n        frameColor: \"#d4d4d4\",\n        frameOpacity: 1,\n        minimumFrameWidth: 0,\n        heightRatio: 0.2\n      };\n      this.heightRatio = args.heightRatio || this.defaults.heightRatio;\n      this.defaults.gripperColor = d3.rgb(this.defaults.frameColor).darker().toString();\n      this.configureCallbacks = [];\n      this.slideCallbacks = [];\n      this.previews = [];\n      if (!args.width) this.widthFromGraph = true;\n      if (!args.height) this.heightFromGraph = true;\n\n      if (this.widthFromGraph || this.heightFromGraph) {\n        this.graphs[0].onConfigure(function () {\n          this.configure(args);\n          this.render();\n        }.bind(this));\n      }\n\n      args.width = args.width || this.graphs[0].width || this.defaults.width;\n      args.height = args.height || this.graphs[0].height * this.heightRatio || this.defaults.height;\n      this.configure(args);\n      this.render();\n    },\n    onSlide: function onSlide(callback) {\n      this.slideCallbacks.push(callback);\n    },\n    onConfigure: function onConfigure(callback) {\n      this.configureCallbacks.push(callback);\n    },\n    configure: function configure(args) {\n      this.config = this.config || {};\n      this.configureCallbacks.forEach(function (callback) {\n        callback(args);\n      });\n      Rickshaw.keys(this.defaults).forEach(function (k) {\n        this.config[k] = k in args ? args[k] : k in this.config ? this.config[k] : this.defaults[k];\n      }, this);\n\n      if ('width' in args || 'height' in args) {\n        if (this.widthFromGraph) {\n          this.config.width = this.graphs[0].width;\n        }\n\n        if (this.heightFromGraph) {\n          this.config.height = this.graphs[0].height * this.heightRatio;\n          this.previewHeight = this.config.height;\n        }\n\n        this.previews.forEach(function (preview) {\n          var height = this.previewHeight / this.graphs.length - this.config.frameTopThickness * 2;\n          var width = this.config.width - this.config.frameHandleThickness * 2;\n          preview.setSize({\n            width: width,\n            height: height\n          });\n\n          if (this.svg) {\n            var svgHeight = height + this.config.frameHandleThickness * 2;\n            var svgWidth = width + this.config.frameHandleThickness * 2;\n            this.svg.style(\"width\", svgWidth + \"px\");\n            this.svg.style(\"height\", svgHeight + \"px\");\n          }\n        }, this);\n      }\n    },\n    render: function render() {\n      var self = this;\n      this.svg = d3.select(this.element).selectAll(\"svg.rickshaw_range_slider_preview\").data([null]);\n      this.previewHeight = this.config.height - this.config.frameTopThickness * 2;\n      this.previewWidth = this.config.width - this.config.frameHandleThickness * 2;\n      this.currentFrame = [0, this.previewWidth];\n\n      var buildGraph = function buildGraph(parent, index) {\n        var graphArgs = Rickshaw.extend({}, parent.config);\n        var height = self.previewHeight / self.graphs.length;\n        var renderer = parent.renderer.name;\n        Rickshaw.extend(graphArgs, {\n          element: this.appendChild(document.createElement(\"div\")),\n          height: height,\n          width: self.previewWidth,\n          series: parent.series,\n          renderer: renderer\n        });\n        var graph = new Rickshaw.Graph(graphArgs);\n        self.previews.push(graph);\n        parent.onUpdate(function () {\n          graph.render();\n          self.render();\n        });\n        parent.onConfigure(function (args) {\n          // don't propagate height\n          delete args.height;\n          args.width = args.width - self.config.frameHandleThickness * 2;\n          graph.configure(args);\n          graph.render();\n        });\n        graph.render();\n      };\n\n      var graphContainer = d3.select(this.element).selectAll(\"div.rickshaw_range_slider_preview_container\").data(this.graphs);\n      var translateCommand = \"translate(\" + this.config.frameHandleThickness + \"px, \" + this.config.frameTopThickness + \"px)\";\n      graphContainer.enter().append(\"div\").classed(\"rickshaw_range_slider_preview_container\", true).style(\"-webkit-transform\", translateCommand).style(\"-moz-transform\", translateCommand).style(\"-ms-transform\", translateCommand).style(\"transform\", translateCommand).each(buildGraph);\n      graphContainer.exit().remove(); // Use the first graph as the \"master\" for the frame state\n\n      var masterGraph = this.graphs[0];\n      var domainScale = d3.scale.linear().domain([0, this.previewWidth]).range(masterGraph.dataDomain());\n      var currentWindow = [masterGraph.window.xMin, masterGraph.window.xMax];\n      this.currentFrame[0] = currentWindow[0] === undefined ? 0 : Math.round(domainScale.invert(currentWindow[0]));\n      if (this.currentFrame[0] < 0) this.currentFrame[0] = 0;\n      this.currentFrame[1] = currentWindow[1] === undefined ? this.previewWidth : domainScale.invert(currentWindow[1]);\n\n      if (this.currentFrame[1] - this.currentFrame[0] < self.config.minimumFrameWidth) {\n        this.currentFrame[1] = (this.currentFrame[0] || 0) + self.config.minimumFrameWidth;\n      }\n\n      this.svg.enter().append(\"svg\").classed(\"rickshaw_range_slider_preview\", true).style(\"height\", this.config.height + \"px\").style(\"width\", this.config.width + \"px\").style(\"position\", \"absolute\").style(\"top\", 0);\n\n      this._renderDimming();\n\n      this._renderFrame();\n\n      this._renderGrippers();\n\n      this._renderHandles();\n\n      this._renderMiddle();\n\n      this._registerMouseEvents();\n    },\n    _renderDimming: function _renderDimming() {\n      var element = this.svg.selectAll(\"path.dimming\").data([null]);\n      element.enter().append(\"path\").attr(\"fill\", \"white\").attr(\"fill-opacity\", \"0.7\").attr(\"fill-rule\", \"evenodd\").classed(\"dimming\", true);\n      var path = \"\";\n      path += \" M \" + this.config.frameHandleThickness + \" \" + this.config.frameTopThickness;\n      path += \" h \" + this.previewWidth;\n      path += \" v \" + this.previewHeight;\n      path += \" h \" + -this.previewWidth;\n      path += \" z \";\n      path += \" M \" + Math.max(this.currentFrame[0], this.config.frameHandleThickness) + \" \" + this.config.frameTopThickness;\n      path += \" H \" + Math.min(this.currentFrame[1] + this.config.frameHandleThickness * 2, this.previewWidth + this.config.frameHandleThickness);\n      path += \" v \" + this.previewHeight;\n      path += \" H \" + Math.max(this.currentFrame[0], this.config.frameHandleThickness);\n      path += \" z\";\n      element.attr(\"d\", path);\n    },\n    _renderFrame: function _renderFrame() {\n      var element = this.svg.selectAll(\"path.frame\").data([null]);\n      element.enter().append(\"path\").attr(\"stroke\", \"white\").attr(\"stroke-width\", \"1px\").attr(\"stroke-linejoin\", \"round\").attr(\"fill\", this.config.frameColor).attr(\"fill-opacity\", this.config.frameOpacity).attr(\"fill-rule\", \"evenodd\").classed(\"frame\", true);\n      var path = \"\";\n      path += \" M \" + this.currentFrame[0] + \" 0\";\n      path += \" H \" + (this.currentFrame[1] + this.config.frameHandleThickness * 2);\n      path += \" V \" + this.config.height;\n      path += \" H \" + this.currentFrame[0];\n      path += \" z\";\n      path += \" M \" + (this.currentFrame[0] + this.config.frameHandleThickness) + \" \" + this.config.frameTopThickness;\n      path += \" H \" + (this.currentFrame[1] + this.config.frameHandleThickness);\n      path += \" v \" + this.previewHeight;\n      path += \" H \" + (this.currentFrame[0] + this.config.frameHandleThickness);\n      path += \" z\";\n      element.attr(\"d\", path);\n    },\n    _renderGrippers: function _renderGrippers() {\n      var gripper = this.svg.selectAll(\"path.gripper\").data([null]);\n      gripper.enter().append(\"path\").attr(\"stroke\", this.config.gripperColor).classed(\"gripper\", true);\n      var path = \"\";\n      [0.4, 0.6].forEach(function (spacing) {\n        path += \" M \" + Math.round(this.currentFrame[0] + this.config.frameHandleThickness * spacing) + \" \" + Math.round(this.config.height * 0.3);\n        path += \" V \" + Math.round(this.config.height * 0.7);\n        path += \" M \" + Math.round(this.currentFrame[1] + this.config.frameHandleThickness * (1 + spacing)) + \" \" + Math.round(this.config.height * 0.3);\n        path += \" V \" + Math.round(this.config.height * 0.7);\n      }.bind(this));\n      gripper.attr(\"d\", path);\n    },\n    _renderHandles: function _renderHandles() {\n      var leftHandle = this.svg.selectAll(\"rect.left_handle\").data([null]);\n      leftHandle.enter().append(\"rect\").attr('width', this.config.frameHandleThickness).style(\"cursor\", \"ew-resize\").style(\"fill-opacity\", \"0\").classed(\"left_handle\", true);\n      leftHandle.attr('x', this.currentFrame[0]).attr('height', this.config.height);\n      var rightHandle = this.svg.selectAll(\"rect.right_handle\").data([null]);\n      rightHandle.enter().append(\"rect\").attr('width', this.config.frameHandleThickness).style(\"cursor\", \"ew-resize\").style(\"fill-opacity\", \"0\").classed(\"right_handle\", true);\n      rightHandle.attr('x', this.currentFrame[1] + this.config.frameHandleThickness).attr('height', this.config.height);\n    },\n    _renderMiddle: function _renderMiddle() {\n      var middleHandle = this.svg.selectAll(\"rect.middle_handle\").data([null]);\n      middleHandle.enter().append(\"rect\").style(\"cursor\", \"move\").style(\"fill-opacity\", \"0\").classed(\"middle_handle\", true);\n      middleHandle.attr('width', Math.max(0, this.currentFrame[1] - this.currentFrame[0])).attr('x', this.currentFrame[0] + this.config.frameHandleThickness).attr('height', this.config.height);\n    },\n    _registerMouseEvents: function _registerMouseEvents() {\n      var element = d3.select(this.element);\n      var drag = {\n        target: null,\n        start: null,\n        stop: null,\n        left: false,\n        right: false,\n        rigid: false\n      };\n      var self = this;\n\n      function onMousemove(datum, index) {\n        drag.stop = self._getClientXFromEvent(d3.event, drag);\n        var distanceTraveled = drag.stop - drag.start;\n        var frameAfterDrag = self.frameBeforeDrag.slice(0);\n        var minimumFrameWidth = self.config.minimumFrameWidth;\n\n        if (drag.rigid) {\n          minimumFrameWidth = self.frameBeforeDrag[1] - self.frameBeforeDrag[0];\n        }\n\n        if (drag.left) {\n          frameAfterDrag[0] = Math.max(frameAfterDrag[0] + distanceTraveled, 0);\n        }\n\n        if (drag.right) {\n          frameAfterDrag[1] = Math.min(frameAfterDrag[1] + distanceTraveled, self.previewWidth);\n        }\n\n        var currentFrameWidth = frameAfterDrag[1] - frameAfterDrag[0];\n\n        if (currentFrameWidth <= minimumFrameWidth) {\n          if (drag.left) {\n            frameAfterDrag[0] = frameAfterDrag[1] - minimumFrameWidth;\n          }\n\n          if (drag.right) {\n            frameAfterDrag[1] = frameAfterDrag[0] + minimumFrameWidth;\n          }\n\n          if (frameAfterDrag[0] <= 0) {\n            frameAfterDrag[1] -= frameAfterDrag[0];\n            frameAfterDrag[0] = 0;\n          }\n\n          if (frameAfterDrag[1] >= self.previewWidth) {\n            frameAfterDrag[0] -= frameAfterDrag[1] - self.previewWidth;\n            frameAfterDrag[1] = self.previewWidth;\n          }\n        }\n\n        self.graphs.forEach(function (graph) {\n          var domainScale = d3.scale.linear().interpolate(d3.interpolateNumber).domain([0, self.previewWidth]).range(graph.dataDomain());\n          var windowAfterDrag = [domainScale(frameAfterDrag[0]), domainScale(frameAfterDrag[1])];\n          self.slideCallbacks.forEach(function (callback) {\n            callback(graph, windowAfterDrag[0], windowAfterDrag[1]);\n          });\n\n          if (frameAfterDrag[0] === 0) {\n            windowAfterDrag[0] = undefined;\n          }\n\n          if (frameAfterDrag[1] === self.previewWidth) {\n            windowAfterDrag[1] = undefined;\n          }\n\n          graph.window.xMin = windowAfterDrag[0];\n          graph.window.xMax = windowAfterDrag[1];\n          graph.update();\n        });\n      }\n\n      function onMousedown() {\n        drag.target = d3.event.target;\n        drag.start = self._getClientXFromEvent(d3.event, drag);\n        self.frameBeforeDrag = self.currentFrame.slice();\n        d3.event.preventDefault ? d3.event.preventDefault() : d3.event.returnValue = false;\n        d3.select(document).on(\"mousemove.rickshaw_range_slider_preview\", onMousemove);\n        d3.select(document).on(\"mouseup.rickshaw_range_slider_preview\", onMouseup);\n        d3.select(document).on(\"touchmove.rickshaw_range_slider_preview\", onMousemove);\n        d3.select(document).on(\"touchend.rickshaw_range_slider_preview\", onMouseup);\n        d3.select(document).on(\"touchcancel.rickshaw_range_slider_preview\", onMouseup);\n      }\n\n      function onMousedownLeftHandle(datum, index) {\n        drag.left = true;\n        onMousedown();\n      }\n\n      function onMousedownRightHandle(datum, index) {\n        drag.right = true;\n        onMousedown();\n      }\n\n      function onMousedownMiddleHandle(datum, index) {\n        drag.left = true;\n        drag.right = true;\n        drag.rigid = true;\n        onMousedown();\n      }\n\n      function onMouseup(datum, index) {\n        d3.select(document).on(\"mousemove.rickshaw_range_slider_preview\", null);\n        d3.select(document).on(\"mouseup.rickshaw_range_slider_preview\", null);\n        d3.select(document).on(\"touchmove.rickshaw_range_slider_preview\", null);\n        d3.select(document).on(\"touchend.rickshaw_range_slider_preview\", null);\n        d3.select(document).on(\"touchcancel.rickshaw_range_slider_preview\", null);\n        delete self.frameBeforeDrag;\n        drag.left = false;\n        drag.right = false;\n        drag.rigid = false;\n      }\n\n      element.select(\"rect.left_handle\").on(\"mousedown\", onMousedownLeftHandle);\n      element.select(\"rect.right_handle\").on(\"mousedown\", onMousedownRightHandle);\n      element.select(\"rect.middle_handle\").on(\"mousedown\", onMousedownMiddleHandle);\n      element.select(\"rect.left_handle\").on(\"touchstart\", onMousedownLeftHandle);\n      element.select(\"rect.right_handle\").on(\"touchstart\", onMousedownRightHandle);\n      element.select(\"rect.middle_handle\").on(\"touchstart\", onMousedownMiddleHandle);\n    },\n    _getClientXFromEvent: function _getClientXFromEvent(event, drag) {\n      switch (event.type) {\n        case 'touchstart':\n        case 'touchmove':\n          var touchList = event.changedTouches;\n          var touch = null;\n\n          for (var touchIndex = 0; touchIndex < touchList.length; touchIndex++) {\n            if (touchList[touchIndex].target === drag.target) {\n              touch = touchList[touchIndex];\n              break;\n            }\n          }\n\n          return touch !== null ? touch.clientX : undefined;\n\n        default:\n          return event.clientX;\n      }\n    }\n  });\n  Rickshaw.namespace(\"Rickshaw.Graph.Renderer\");\n  Rickshaw.Graph.Renderer = Rickshaw.Class.create({\n    initialize: function initialize(args) {\n      this.graph = args.graph;\n      this.tension = args.tension || this.tension;\n      this.configure(args);\n    },\n    seriesPathFactory: function seriesPathFactory() {//implement in subclass\n    },\n    seriesStrokeFactory: function seriesStrokeFactory() {// implement in subclass\n    },\n    defaults: function defaults() {\n      return {\n        tension: 0.8,\n        strokeWidth: 2,\n        unstack: true,\n        padding: {\n          top: 0.01,\n          right: 0,\n          bottom: 0.01,\n          left: 0\n        },\n        stroke: false,\n        fill: false,\n        opacity: 1\n      };\n    },\n    domain: function domain(data) {\n      // Requires that at least one series contains some data\n      var stackedData = data || this.graph.stackedData || this.graph.stackData(); // filter out any series that may be empty in the current x-domain\n\n      stackedData = stackedData.filter(function (a) {\n        return a && a.length !== 0;\n      });\n      var xMin = +Infinity;\n      var xMax = -Infinity;\n      var yMin = +Infinity;\n      var yMax = -Infinity;\n      stackedData.forEach(function (series) {\n        series.forEach(function (d) {\n          if (d.y == null) return;\n          var y = d.y + d.y0;\n          if (y < yMin) yMin = y;\n          if (y > yMax) yMax = y;\n        });\n        if (!series.length) return;\n        if (series[0].x < xMin) xMin = series[0].x;\n        if (series[series.length - 1].x > xMax) xMax = series[series.length - 1].x;\n      });\n      xMin -= (xMax - xMin) * this.padding.left;\n      xMax += (xMax - xMin) * this.padding.right;\n      yMin = this.graph.min === 'auto' ? yMin : this.graph.min || 0;\n      yMax = this.graph.max === undefined ? yMax : this.graph.max;\n\n      if (this.graph.min === 'auto' || yMin < 0) {\n        yMin -= (yMax - yMin) * this.padding.bottom;\n      }\n\n      if (this.graph.max === undefined) {\n        yMax += (yMax - yMin) * this.padding.top;\n      }\n\n      return {\n        x: [xMin, xMax],\n        y: [yMin, yMax]\n      };\n    },\n    render: function render(args) {\n      args = args || {};\n      var graph = this.graph;\n      var series = args.series || graph.series;\n      var vis = args.vis || graph.vis;\n      vis.selectAll('*').remove();\n      var data = series.filter(function (s) {\n        return !s.disabled;\n      }).map(function (s) {\n        return s.stack;\n      });\n      var pathNodes = vis.selectAll(\"path.path\").data(data).enter().append(\"svg:path\").classed('path', true).attr(\"d\", this.seriesPathFactory());\n\n      if (this.stroke) {\n        var strokeNodes = vis.selectAll('path.stroke').data(data).enter().append(\"svg:path\").classed('stroke', true).attr(\"d\", this.seriesStrokeFactory());\n      }\n\n      var i = 0;\n      series.forEach(function (series) {\n        if (series.disabled) return;\n        series.path = pathNodes[0][i];\n        if (this.stroke) series.stroke = strokeNodes[0][i];\n\n        this._styleSeries(series);\n\n        i++;\n      }, this);\n    },\n    _styleSeries: function _styleSeries(series) {\n      var fill = this.fill ? series.color : 'none';\n      var stroke = this.stroke ? series.color : 'none';\n      var strokeWidth = series.strokeWidth ? series.strokeWidth : this.strokeWidth;\n      var opacity = series.opacity === undefined ? this.opacity : series.opacity;\n      series.path.setAttribute('fill', fill);\n      series.path.setAttribute('stroke', stroke);\n      series.path.setAttribute('stroke-width', strokeWidth);\n      series.path.setAttribute('opacity', opacity);\n\n      if (series.className) {\n        d3.select(series.path).classed(series.className, true);\n      }\n\n      if (series.className && this.stroke) {\n        d3.select(series.stroke).classed(series.className, true);\n      }\n    },\n    configure: function configure(args) {\n      args = args || {};\n      Rickshaw.keys(this.defaults()).forEach(function (key) {\n        if (!args.hasOwnProperty(key)) {\n          this[key] = this[key] || this.graph[key] || this.defaults()[key];\n          return;\n        }\n\n        if (typeof this.defaults()[key] == 'object') {\n          Rickshaw.keys(this.defaults()[key]).forEach(function (k) {\n            this[key][k] = args[key][k] !== undefined ? args[key][k] : this[key][k] !== undefined ? this[key][k] : this.defaults()[key][k];\n          }, this);\n        } else {\n          this[key] = args[key] !== undefined ? args[key] : this[key] !== undefined ? this[key] : this.graph[key] !== undefined ? this.graph[key] : this.defaults()[key];\n        }\n      }, this);\n    },\n    setStrokeWidth: function setStrokeWidth(strokeWidth) {\n      if (strokeWidth !== undefined) {\n        this.strokeWidth = strokeWidth;\n      }\n    },\n    setTension: function setTension(tension) {\n      if (tension !== undefined) {\n        this.tension = tension;\n      }\n    }\n  });\n  Rickshaw.namespace('Rickshaw.Graph.Renderer.Line');\n  Rickshaw.Graph.Renderer.Line = Rickshaw.Class.create(Rickshaw.Graph.Renderer, {\n    name: 'line',\n    defaults: function defaults($super) {\n      return Rickshaw.extend($super(), {\n        unstack: true,\n        fill: false,\n        stroke: true\n      });\n    },\n    seriesPathFactory: function seriesPathFactory() {\n      var graph = this.graph;\n      var factory = d3.svg.line().x(function (d) {\n        return graph.x(d.x);\n      }).y(function (d) {\n        return graph.y(d.y);\n      }).interpolate(this.graph.interpolation).tension(this.tension);\n      factory.defined && factory.defined(function (d) {\n        return d.y !== null;\n      });\n      return factory;\n    }\n  });\n  Rickshaw.namespace('Rickshaw.Graph.Renderer.Stack');\n  Rickshaw.Graph.Renderer.Stack = Rickshaw.Class.create(Rickshaw.Graph.Renderer, {\n    name: 'stack',\n    defaults: function defaults($super) {\n      return Rickshaw.extend($super(), {\n        fill: true,\n        stroke: false,\n        unstack: false\n      });\n    },\n    seriesPathFactory: function seriesPathFactory() {\n      var graph = this.graph;\n      var factory = d3.svg.area().x(function (d) {\n        return graph.x(d.x);\n      }).y0(function (d) {\n        return graph.y(d.y0);\n      }).y1(function (d) {\n        return graph.y(d.y + d.y0);\n      }).interpolate(this.graph.interpolation).tension(this.tension);\n      factory.defined && factory.defined(function (d) {\n        return d.y !== null;\n      });\n      return factory;\n    }\n  });\n  Rickshaw.namespace('Rickshaw.Graph.Renderer.Bar');\n  Rickshaw.Graph.Renderer.Bar = Rickshaw.Class.create(Rickshaw.Graph.Renderer, {\n    name: 'bar',\n    defaults: function defaults($super) {\n      var defaults = Rickshaw.extend($super(), {\n        gapSize: 0.05,\n        unstack: false,\n        opacity: 1.0\n      });\n      delete defaults.tension;\n      return defaults;\n    },\n    initialize: function initialize($super, args) {\n      args = args || {};\n      this.gapSize = args.gapSize || this.gapSize;\n      $super(args);\n    },\n    domain: function domain($super) {\n      var domain = $super();\n\n      var frequentInterval = this._frequentInterval(this.graph.stackedData.slice(-1).shift());\n\n      domain.x[1] += Number(frequentInterval.magnitude);\n      return domain;\n    },\n    barWidth: function barWidth(series) {\n      var frequentInterval = this._frequentInterval(series.stack);\n\n      var barWidth = this.graph.x.magnitude(frequentInterval.magnitude) * (1 - this.gapSize);\n      return barWidth;\n    },\n    render: function render(args) {\n      args = args || {};\n      var graph = this.graph;\n      var series = args.series || graph.series;\n      var vis = args.vis || graph.vis;\n      vis.selectAll('*').remove();\n      var barWidth = this.barWidth(series.active()[0]);\n      var barXOffset = 0;\n      var activeSeriesCount = series.filter(function (s) {\n        return !s.disabled;\n      }).length;\n      var seriesBarWidth = this.unstack ? barWidth / activeSeriesCount : barWidth;\n\n      var transform = function transform(d) {\n        // add a matrix transform for negative values\n        var matrix = [1, 0, 0, d.y < 0 ? -1 : 1, 0, d.y < 0 ? graph.y.magnitude(Math.abs(d.y)) * 2 : 0];\n        return \"matrix(\" + matrix.join(',') + \")\";\n      };\n\n      series.forEach(function (series) {\n        if (series.disabled) return;\n        var barWidth = this.barWidth(series);\n        var nodes = vis.selectAll(\"path\").data(series.stack.filter(function (d) {\n          return d.y !== null;\n        })).enter().append(\"svg:rect\").attr(\"x\", function (d) {\n          return graph.x(d.x) + barXOffset;\n        }).attr(\"y\", function (d) {\n          return graph.y(d.y0 + Math.abs(d.y)) * (d.y < 0 ? -1 : 1);\n        }).attr(\"width\", seriesBarWidth).attr(\"height\", function (d) {\n          return graph.y.magnitude(Math.abs(d.y));\n        }).attr(\"opacity\", series.opacity).attr(\"transform\", transform);\n        Array.prototype.forEach.call(nodes[0], function (n) {\n          n.setAttribute('fill', series.color);\n        });\n        if (this.unstack) barXOffset += seriesBarWidth;\n      }, this);\n    },\n    _frequentInterval: function _frequentInterval(data) {\n      var intervalCounts = {};\n\n      for (var i = 0; i < data.length - 1; i++) {\n        var interval = data[i + 1].x - data[i].x;\n        intervalCounts[interval] = intervalCounts[interval] || 0;\n        intervalCounts[interval]++;\n      }\n\n      var frequentInterval = {\n        count: 0,\n        magnitude: 1\n      }; // Sorting object's keys returned to guarantee consistency when iterating over\n      // Keys order in `for .. in` loop is not specified and browsers behave differently here\n      // This results with different invterval value being calculated for different browsers\n      // See last but one section here: http://www.ecma-international.org/ecma-262/5.1/#sec-12.6.4\n\n      var keysSorted = Rickshaw.keys(intervalCounts).sort(function asc(a, b) {\n        return Number(a) - Number(b);\n      });\n      keysSorted.forEach(function (i) {\n        if (frequentInterval.count < intervalCounts[i]) {\n          frequentInterval = {\n            count: intervalCounts[i],\n            magnitude: i\n          };\n        }\n      });\n      return frequentInterval;\n    }\n  });\n  Rickshaw.namespace('Rickshaw.Graph.Renderer.Area');\n  Rickshaw.Graph.Renderer.Area = Rickshaw.Class.create(Rickshaw.Graph.Renderer, {\n    name: 'area',\n    defaults: function defaults($super) {\n      return Rickshaw.extend($super(), {\n        unstack: false,\n        fill: false,\n        stroke: false\n      });\n    },\n    seriesPathFactory: function seriesPathFactory() {\n      var graph = this.graph;\n      var factory = d3.svg.area().x(function (d) {\n        return graph.x(d.x);\n      }).y0(function (d) {\n        return graph.y(d.y0);\n      }).y1(function (d) {\n        return graph.y(d.y + d.y0);\n      }).interpolate(graph.interpolation).tension(this.tension);\n      factory.defined && factory.defined(function (d) {\n        return d.y !== null;\n      });\n      return factory;\n    },\n    seriesStrokeFactory: function seriesStrokeFactory() {\n      var graph = this.graph;\n      var factory = d3.svg.line().x(function (d) {\n        return graph.x(d.x);\n      }).y(function (d) {\n        return graph.y(d.y + d.y0);\n      }).interpolate(graph.interpolation).tension(this.tension);\n      factory.defined && factory.defined(function (d) {\n        return d.y !== null;\n      });\n      return factory;\n    },\n    render: function render(args) {\n      args = args || {};\n      var graph = this.graph;\n      var series = args.series || graph.series;\n      var vis = args.vis || graph.vis;\n      vis.selectAll('*').remove(); // insert or stacked areas so strokes lay on top of areas\n\n      var method = this.unstack ? 'append' : 'insert';\n      var data = series.filter(function (s) {\n        return !s.disabled;\n      }).map(function (s) {\n        return s.stack;\n      });\n      var nodes = vis.selectAll(\"path\").data(data).enter()[method](\"svg:g\", 'g');\n      nodes.append(\"svg:path\").attr(\"d\", this.seriesPathFactory()).attr(\"class\", 'area');\n\n      if (this.stroke) {\n        nodes.append(\"svg:path\").attr(\"d\", this.seriesStrokeFactory()).attr(\"class\", 'line');\n      }\n\n      var i = 0;\n      series.forEach(function (series) {\n        if (series.disabled) return;\n        series.path = nodes[0][i++];\n\n        this._styleSeries(series);\n      }, this);\n    },\n    _styleSeries: function _styleSeries(series) {\n      if (!series.path) return;\n      d3.select(series.path).select('.area').attr('fill', series.color);\n\n      if (this.stroke) {\n        d3.select(series.path).select('.line').attr('fill', 'none').attr('stroke', series.stroke || d3.interpolateRgb(series.color, 'black')(0.125)).attr('stroke-width', this.strokeWidth);\n      }\n\n      if (series.className) {\n        series.path.setAttribute('class', series.className);\n      }\n    }\n  });\n  Rickshaw.namespace('Rickshaw.Graph.Renderer.ScatterPlot');\n  Rickshaw.Graph.Renderer.ScatterPlot = Rickshaw.Class.create(Rickshaw.Graph.Renderer, {\n    name: 'scatterplot',\n    defaults: function defaults($super) {\n      return Rickshaw.extend($super(), {\n        unstack: true,\n        fill: true,\n        stroke: false,\n        padding: {\n          top: 0.01,\n          right: 0.01,\n          bottom: 0.01,\n          left: 0.01\n        },\n        dotSize: 4\n      });\n    },\n    initialize: function initialize($super, args) {\n      $super(args);\n    },\n    render: function render(args) {\n      args = args || {};\n      var graph = this.graph;\n      var series = args.series || graph.series;\n      var vis = args.vis || graph.vis;\n      var dotSize = this.dotSize;\n      vis.selectAll('*').remove();\n      series.forEach(function (series) {\n        if (series.disabled) return;\n        var opacity = series.opacity === undefined ? 1 : series.opacity;\n        var nodes = vis.selectAll(\"path\").data(series.stack.filter(function (d) {\n          return d.y !== null;\n        })).enter().append(\"svg:circle\").attr(\"cx\", function (d) {\n          return graph.x(d.x);\n        }).attr(\"cy\", function (d) {\n          return graph.y(d.y);\n        }).attr(\"r\", function (d) {\n          return \"r\" in d ? d.r : dotSize;\n        }).attr(\"opacity\", function (d) {\n          return \"opacity\" in d ? d.opacity : opacity;\n        });\n\n        if (series.className) {\n          nodes.classed(series.className, true);\n        }\n\n        Array.prototype.forEach.call(nodes[0], function (n) {\n          n.setAttribute('fill', series.color);\n        });\n      }, this);\n    }\n  });\n  Rickshaw.namespace('Rickshaw.Graph.Renderer.Multi');\n  Rickshaw.Graph.Renderer.Multi = Rickshaw.Class.create(Rickshaw.Graph.Renderer, {\n    name: 'multi',\n    initialize: function initialize($super, args) {\n      $super(args);\n    },\n    defaults: function defaults($super) {\n      return Rickshaw.extend($super(), {\n        unstack: true,\n        fill: false,\n        stroke: true\n      });\n    },\n    configure: function configure($super, args) {\n      args = args || {};\n      this.config = args;\n      $super(args);\n    },\n    domain: function domain($super) {\n      this.graph.stackData();\n      var domains = [];\n\n      var groups = this._groups();\n\n      this._stack(groups);\n\n      groups.forEach(function (group) {\n        var data = group.series.filter(function (s) {\n          return !s.disabled;\n        }).map(function (s) {\n          return s.stack;\n        });\n        if (!data.length) return;\n        var domain = null;\n\n        if (group.renderer && group.renderer.domain) {\n          domain = group.renderer.domain(data);\n        } else {\n          domain = $super(data);\n        }\n\n        domains.push(domain);\n      });\n      var xMin = d3.min(domains.map(function (d) {\n        return d.x[0];\n      }));\n      var xMax = d3.max(domains.map(function (d) {\n        return d.x[1];\n      }));\n      var yMin = d3.min(domains.map(function (d) {\n        return d.y[0];\n      }));\n      var yMax = d3.max(domains.map(function (d) {\n        return d.y[1];\n      }));\n      return {\n        x: [xMin, xMax],\n        y: [yMin, yMax]\n      };\n    },\n    _groups: function _groups() {\n      var graph = this.graph;\n      var renderGroups = {};\n      graph.series.forEach(function (series) {\n        if (series.disabled) return;\n\n        if (!renderGroups[series.renderer]) {\n          var ns = \"http://www.w3.org/2000/svg\";\n          var vis = document.createElementNS(ns, 'g');\n          graph.vis[0][0].appendChild(vis);\n          var renderer = graph._renderers[series.renderer];\n          var config = {};\n          var defaults = [this.defaults(), renderer.defaults(), this.config, this.graph];\n          defaults.forEach(function (d) {\n            Rickshaw.extend(config, d);\n          });\n          renderer.configure(config);\n          renderGroups[series.renderer] = {\n            renderer: renderer,\n            series: [],\n            vis: d3.select(vis)\n          };\n        }\n\n        renderGroups[series.renderer].series.push(series);\n      }, this);\n      var groups = [];\n      Object.keys(renderGroups).forEach(function (key) {\n        var group = renderGroups[key];\n        groups.push(group);\n      });\n      return groups;\n    },\n    _stack: function _stack(groups) {\n      groups.forEach(function (group) {\n        var series = group.series.filter(function (series) {\n          return !series.disabled;\n        });\n        var data = series.map(function (series) {\n          return series.stack;\n        });\n\n        if (!group.renderer.unstack) {\n          var layout = d3.layout.stack();\n          var stackedData = Rickshaw.clone(layout(data));\n          series.forEach(function (series, index) {\n            series._stack = Rickshaw.clone(stackedData[index]);\n          });\n        }\n      }, this);\n      return groups;\n    },\n    render: function render() {\n      this.graph.series.forEach(function (series) {\n        if (!series.renderer) {\n          throw new Error(\"Each series needs a renderer for graph 'multi' renderer\");\n        }\n      });\n      this.graph.vis.selectAll('*').remove();\n\n      var groups = this._groups();\n\n      groups = this._stack(groups);\n      groups.forEach(function (group) {\n        var series = group.series.filter(function (series) {\n          return !series.disabled;\n        });\n\n        series.active = function () {\n          return series;\n        };\n\n        group.renderer.render({\n          series: series,\n          vis: group.vis\n        });\n        series.forEach(function (s) {\n          s.stack = s._stack || s.stack || s.data;\n        });\n      });\n    }\n  });\n  Rickshaw.namespace('Rickshaw.Graph.Renderer.LinePlot');\n  Rickshaw.Graph.Renderer.LinePlot = Rickshaw.Class.create(Rickshaw.Graph.Renderer, {\n    name: 'lineplot',\n    defaults: function defaults($super) {\n      return Rickshaw.extend($super(), {\n        unstack: true,\n        fill: false,\n        stroke: true,\n        padding: {\n          top: 0.01,\n          right: 0.01,\n          bottom: 0.01,\n          left: 0.01\n        },\n        dotSize: 3,\n        strokeWidth: 2\n      });\n    },\n    seriesPathFactory: function seriesPathFactory() {\n      var graph = this.graph;\n      var factory = d3.svg.line().x(function (d) {\n        return graph.x(d.x);\n      }).y(function (d) {\n        return graph.y(d.y);\n      }).interpolate(this.graph.interpolation).tension(this.tension);\n      factory.defined && factory.defined(function (d) {\n        return d.y !== null;\n      });\n      return factory;\n    },\n    render: function render(args) {\n      args = args || {};\n      var graph = this.graph;\n      var series = args.series || graph.series;\n      var vis = args.vis || graph.vis;\n      var dotSize = this.dotSize;\n      vis.selectAll('*').remove();\n      var data = series.filter(function (s) {\n        return !s.disabled;\n      }).map(function (s) {\n        return s.stack;\n      });\n      var nodes = vis.selectAll(\"path\").data(data).enter().append(\"svg:path\").attr(\"d\", this.seriesPathFactory());\n      var i = 0;\n      series.forEach(function (series) {\n        if (series.disabled) return;\n        series.path = nodes[0][i++];\n\n        this._styleSeries(series);\n      }, this);\n      series.forEach(function (series) {\n        if (series.disabled) return;\n        var nodes = vis.selectAll(\"x\").data(series.stack.filter(function (d) {\n          return d.y !== null;\n        })).enter().append(\"svg:circle\").attr(\"cx\", function (d) {\n          return graph.x(d.x);\n        }).attr(\"cy\", function (d) {\n          return graph.y(d.y);\n        }).attr(\"r\", function (d) {\n          return \"r\" in d ? d.r : dotSize;\n        });\n        Array.prototype.forEach.call(nodes[0], function (n) {\n          if (!n) return;\n          n.setAttribute('data-color', series.color);\n          n.setAttribute('fill', 'white');\n          n.setAttribute('stroke', series.color);\n          n.setAttribute('stroke-width', this.strokeWidth);\n        }.bind(this));\n      }, this);\n    }\n  });\n  Rickshaw.namespace('Rickshaw.Graph.Smoother');\n  Rickshaw.Graph.Smoother = Rickshaw.Class.create({\n    initialize: function initialize(args) {\n      this.graph = args.graph;\n      this.element = args.element;\n      this.aggregationScale = 1;\n      this.build();\n      this.graph.stackData.hooks.data.push({\n        name: 'smoother',\n        orderPosition: 50,\n        f: this.transformer.bind(this)\n      });\n    },\n    build: function build() {\n      var self = this;\n      var $ = jQuery;\n\n      if (this.element) {\n        $(function () {\n          $(self.element).slider({\n            min: 1,\n            max: 100,\n            slide: function slide(event, ui) {\n              self.setScale(ui.value);\n            }\n          });\n        });\n      }\n    },\n    setScale: function setScale(scale) {\n      if (scale < 1) {\n        throw \"scale out of range: \" + scale;\n      }\n\n      this.aggregationScale = scale;\n      this.graph.update();\n    },\n    transformer: function transformer(data) {\n      if (this.aggregationScale == 1) return data;\n      var aggregatedData = [];\n      data.forEach(function (seriesData) {\n        var aggregatedSeriesData = [];\n\n        while (seriesData.length) {\n          var avgX = 0,\n              avgY = 0;\n          var slice = seriesData.splice(0, this.aggregationScale);\n          slice.forEach(function (d) {\n            avgX += d.x / slice.length;\n            avgY += d.y / slice.length;\n          });\n          aggregatedSeriesData.push({\n            x: avgX,\n            y: avgY\n          });\n        }\n\n        aggregatedData.push(aggregatedSeriesData);\n      }.bind(this));\n      return aggregatedData;\n    }\n  });\n  Rickshaw.namespace('Rickshaw.Graph.Socketio');\n  Rickshaw.Graph.Socketio = Rickshaw.Class.create(Rickshaw.Graph.Ajax, {\n    request: function request() {\n      var socket = io.connect(this.dataURL);\n      var self = this;\n      socket.on('rickshaw', function (data) {\n        self.success(data);\n      });\n    }\n  });\n  Rickshaw.namespace('Rickshaw.Series');\n  Rickshaw.Series = Rickshaw.Class.create(Array, {\n    initialize: function initialize(data, palette, options) {\n      options = options || {};\n      this.palette = new Rickshaw.Color.Palette(palette);\n      this.timeBase = typeof options.timeBase === 'undefined' ? Math.floor(new Date().getTime() / 1000) : options.timeBase;\n      var timeInterval = typeof options.timeInterval == 'undefined' ? 1000 : options.timeInterval;\n      this.setTimeInterval(timeInterval);\n\n      if (data && typeof data == \"object\" && Array.isArray(data)) {\n        data.forEach(function (item) {\n          this.addItem(item);\n        }, this);\n      }\n    },\n    addItem: function addItem(item) {\n      if (typeof item.name === 'undefined') {\n        throw 'addItem() needs a name';\n      }\n\n      item.color = item.color || this.palette.color(item.name);\n      item.data = item.data || []; // backfill, if necessary\n\n      if (item.data.length === 0 && this.length && this.getIndex() > 0) {\n        this[0].data.forEach(function (plot) {\n          item.data.push({\n            x: plot.x,\n            y: 0\n          });\n        });\n      } else if (item.data.length === 0) {\n        item.data.push({\n          x: this.timeBase - (this.timeInterval || 0),\n          y: 0\n        });\n      }\n\n      this.push(item);\n\n      if (this.legend) {\n        this.legend.addLine(this.itemByName(item.name));\n      }\n    },\n    addData: function addData(data, x) {\n      var index = this.getIndex();\n      Rickshaw.keys(data).forEach(function (name) {\n        if (!this.itemByName(name)) {\n          this.addItem({\n            name: name\n          });\n        }\n      }, this);\n      this.forEach(function (item) {\n        item.data.push({\n          x: x || (index * this.timeInterval || 1) + this.timeBase,\n          y: data[item.name] || 0\n        });\n      }, this);\n    },\n    getIndex: function getIndex() {\n      return this[0] && this[0].data && this[0].data.length ? this[0].data.length : 0;\n    },\n    itemByName: function itemByName(name) {\n      for (var i = 0; i < this.length; i++) {\n        if (this[i].name == name) return this[i];\n      }\n    },\n    setTimeInterval: function setTimeInterval(iv) {\n      this.timeInterval = iv / 1000;\n    },\n    setTimeBase: function setTimeBase(t) {\n      this.timeBase = t;\n    },\n    dump: function dump() {\n      var data = {\n        timeBase: this.timeBase,\n        timeInterval: this.timeInterval,\n        items: []\n      };\n      this.forEach(function (item) {\n        var newItem = {\n          color: item.color,\n          name: item.name,\n          data: []\n        };\n        item.data.forEach(function (plot) {\n          newItem.data.push({\n            x: plot.x,\n            y: plot.y\n          });\n        });\n        data.items.push(newItem);\n      });\n      return data;\n    },\n    load: function load(data) {\n      if (data.timeInterval) {\n        this.timeInterval = data.timeInterval;\n      }\n\n      if (data.timeBase) {\n        this.timeBase = data.timeBase;\n      }\n\n      if (data.items) {\n        data.items.forEach(function (item) {\n          this.push(item);\n\n          if (this.legend) {\n            this.legend.addLine(this.itemByName(item.name));\n          }\n        }, this);\n      }\n    }\n  });\n\n  Rickshaw.Series.zeroFill = function (series) {\n    Rickshaw.Series.fill(series, 0);\n  };\n\n  Rickshaw.Series.fill = function (series, fill) {\n    var x;\n    var i = 0;\n    var data = series.map(function (s) {\n      return s.data;\n    });\n\n    while (i < Math.max.apply(null, data.map(function (d) {\n      return d.length;\n    }))) {\n      x = Math.min.apply(null, data.filter(function (d) {\n        return d[i];\n      }).map(function (d) {\n        return d[i].x;\n      }));\n      data.forEach(function (d) {\n        if (!d[i] || d[i].x != x) {\n          d.splice(i, 0, {\n            x: x,\n            y: fill\n          });\n        }\n      });\n      i++;\n    }\n  };\n\n  Rickshaw.namespace('Rickshaw.Series.FixedDuration');\n  Rickshaw.Series.FixedDuration = Rickshaw.Class.create(Rickshaw.Series, {\n    initialize: function initialize(data, palette, options) {\n      options = options || {};\n\n      if (typeof options.timeInterval === 'undefined') {\n        throw new Error('FixedDuration series requires timeInterval');\n      }\n\n      if (typeof options.maxDataPoints === 'undefined') {\n        throw new Error('FixedDuration series requires maxDataPoints');\n      }\n\n      this.palette = new Rickshaw.Color.Palette(palette);\n      this.timeBase = typeof options.timeBase === 'undefined' ? Math.floor(new Date().getTime() / 1000) : options.timeBase;\n      this.setTimeInterval(options.timeInterval);\n\n      if (this[0] && this[0].data && this[0].data.length) {\n        this.currentSize = this[0].data.length;\n        this.currentIndex = this[0].data.length;\n      } else {\n        this.currentSize = 0;\n        this.currentIndex = 0;\n      }\n\n      this.maxDataPoints = options.maxDataPoints;\n\n      if (data && typeof data == \"object\" && Array.isArray(data)) {\n        data.forEach(function (item) {\n          this.addItem(item);\n        }, this);\n        this.currentSize += 1;\n        this.currentIndex += 1;\n      } // reset timeBase for zero-filled values if needed\n\n\n      this.timeBase -= (this.maxDataPoints - this.currentSize) * this.timeInterval; // zero-fill up to maxDataPoints size if we don't have that much data yet\n\n      if (typeof this.maxDataPoints !== 'undefined' && this.currentSize < this.maxDataPoints) {\n        for (var i = this.maxDataPoints - this.currentSize - 1; i > 1; i--) {\n          this.currentSize += 1;\n          this.currentIndex += 1;\n          this.forEach(function (item) {\n            item.data.unshift({\n              x: ((i - 1) * this.timeInterval || 1) + this.timeBase,\n              y: 0,\n              i: i\n            });\n          }, this);\n        }\n      }\n    },\n    addData: function addData($super, data, x) {\n      $super(data, x);\n      this.currentSize += 1;\n      this.currentIndex += 1;\n\n      if (this.maxDataPoints !== undefined) {\n        while (this.currentSize > this.maxDataPoints) {\n          this.dropData();\n        }\n      }\n    },\n    dropData: function dropData() {\n      this.forEach(function (item) {\n        item.data.splice(0, 1);\n      });\n      this.currentSize -= 1;\n    },\n    getIndex: function getIndex() {\n      return this.currentIndex;\n    }\n  });\n  return Rickshaw;\n});","map":null,"metadata":{},"sourceType":"script"}